{
  "analysisComplete": "Analysis complete.",
  "analysisFailed": "Analysis failed due to an error.",
  "buildSummary": {
    "title": "Build Summary",
    "status": "Status",
    "buildTime": "Build Started At",
    "totalTime": "Total Time",
    "analysisPhase": "Analysis Phase",
    "executionPhase": "Execution Phase",
    "exitCodeSuccess": "SUCCESS",
    "exitCodeFailure": "FAILURE"
  },
  "buildEnv": {
    "title": "Build Environment & Options",
    "invocationDetails": "Invocation Details",
    "command": "Command",
    "targets": "Targets",
    "explicitOptions": "Explicit Command-Line Options",
    "canonicalCommandLine": "Canonical Command Line",
    "optionsDescription": "Options Description"
  },
  "performanceMetrics": {
    "title": "Performance Metrics",
    "executionCaching": "Execution & Caching",
    "actionsCreated": "Actions Created",
    "actionsExecuted": "Actions Executed",
    "actionCache": "Action Cache",
    "actionCacheHit": "hit",
    "actionCacheHits": "hits",
    "actionCacheMisses": "misses",
    "cacheMissBreakdown": "Cache Miss Breakdown",
    "cacheMissReason": {
      "NotCached": "Not Cached",
      "DigestMismatch": "Digest Mismatch",
      "CorruptedCacheEntry": "Corrupted Cache Entry",
      "UnconditionalExecution": "Unconditional Execution",
      "DifferentDeps": "Different Deps",
      "DifferentActionKey": "Different Action Key",
      "DifferentEnvironment": "Different Environment",
      "DifferentFiles": "Different Files",
      "explanation": "> **Why did my cache miss?** `Digest Mismatch` is the most common reason, indicating a change in the command, inputs, or environment. `Not Cached` means no entry was found. `Unconditional Execution` happens when an action is tagged 'no-cache'."
    },
    "memoryUsage": "Memory Usage",
    "peakHeap": "Peak Heap Size (Post GC)",
    "usedHeapPostBuild": "Used Heap (Post Build)",
    "gcByType": "Garbage Collection by Type",
    "totalGc": "Total Garbage Collected",
    "gcType": {
      "G1YoungGeneration": "G1 Young Generation",
      "G1OldGeneration": "G1 Old Generation",
      "G1EdenSpace": "G1 Eden Space",
      "G1OldGen": "G1 Old Gen",
      "G1SurvivorSpace": "G1 Survivor Space",
      "CodeHeapprofilednmethods": "CodeHeap 'profiled nmethods'",
      "CodeHeapnon-profilednmethods": "CodeHeap 'non-profiled nmethods'",
      "Metaspace": "Metaspace",
      "CompressedClassSpace": "Compressed Class Space",
      "ZGC": "ZGC",
      "Shenandoah": "Shenandoah",
      "ParNew": "ParNew",
      "ConcurrentMarkSweep": "ConcurrentMarkSweep"
    },
    "gcExplanation": "> **What is Garbage Collection (GC)?** It's the process by which the Java Virtual Machine (JVM) reclaims memory occupied by objects that are no longer in use. Frequent or large GC events can pause the build, impacting performance. `Young Generation` GC is typically fast and frequent, cleaning up short-lived objects. `Old Generation` GC is less frequent but can cause longer pauses, as it scans long-lived objects."
  },
  "artifactMetrics": {
    "title": "Artifact Metrics",
    "metric": "Metric",
    "count": "Count",
    "size": "Size",
    "sourceRead": "Source Artifacts Read",
    "outputSeen": "Output Artifacts Seen",
    "topLevel": "Top-Level Artifacts"
  },
  "buildGraphMetrics": {
    "title": "Build Graph Metrics",
    "totalActions": "Total Actions in Graph",
    "totalOutputs": "Total Output Artifacts",
    "topSkyFunctions": "Top 10 Built SkyFunctions",
    "skyFunction": "SkyFunction",
    "evalCount": "Eval Count",
    "skyFunctionsExplanation": "> **What are SkyFunctions?** They are the core evaluation units in Bazel's Skyframe engine. High counts for `FILE_STATE` and `DIRECTORY_LISTING` are normal as Bazel checks for file changes. A high count for `CONFIGURED_TARGET` indicates a large number of targets were analyzed in the build."
  },
  "workerNetworkMetrics": {
    "title": "Worker & Network Metrics",
    "totalWorkerActions": "Total Worker Actions",
    "networkTraffic": "Network Traffic",
    "sent": "Sent",
    "received": "Received",
    "explanation": "> **What are Bazel Workers?** Workers are long-running processes that Bazel can send individual action requests to. For tools that have a high startup cost (like compilers or linters), using persistent workers can dramatically speed up builds by avoiding repeated process creation."
  },
  "buildToolLogs": {
    "title": "Build Tool Logs",
    "criticalPathSummary": "Critical Path Summary"
  },
  "problemsFailures": {
    "problemsTitle": "Problems",
    "failedTargetsTitle": "Failed Targets"
  },
  "actionDetails": {
    "titleAll": "All Action Details",
    "titleFailed": "Failed Action Details",
    "actionCount": "action",
    "actionCountPlural": "actions",
    "statusSuccess": "SUCCESS",
    "statusFailure": "FAILURE",
    "type": "Type",
    "duration": "Duration",
    "primaryOutput": "Primary Output",
    "commandLine": "Command Line",
    "stderr": "Stderr",
    "searchPlaceholder": "Search actions...",
    "copyButton": "Copy",
    "copiedButton": "Copied!",
    "badgeActions": "{{count}} actions",
    "badgeFailed": "{{count}} failed",
    "badgeTotalTime": "Total Time"
  },
  "testSummary": {
    "title": "Test Summary",
    "target": "Target",
    "status": "Status",
    "total": "Total",
    "passed": "Passed",
    "failed": "Failed"
  },
  "slowestActions": {
    "title": "Top 10 Slowest Actions",
    "duration": "Duration",
    "actionType": "Action Type",
    "outputTarget": "Output/Target"
  },
  "buildOutputs": {
    "title": "Build Outputs",
    "target": "Target",
    "files": "Files"
  },
  "convenienceSymlinks": {
    "title": "Convenience Symlinks",
    "path": "Path",
    "action": "Action",
    "target": "Target"
  }
}
