// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: src/main/java/com/google/devtools/build/lib/buildeventstream/proto/build_event_stream.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../../../../../../../google/protobuf/any";
import { Duration } from "../../../../../../../../../../google/protobuf/duration";
import { Timestamp } from "../../../../../../../../../../google/protobuf/timestamp";
import { ActionCacheStatistics } from "../../../../../../../../protobuf/action_cache";
import { CommandLine } from "../../../../../../../../protobuf/command_line";
import {
  FailureDetail,
  Worker_Code,
  worker_CodeFromJSON,
  worker_CodeToJSON,
} from "../../../../../../../../protobuf/failure_details";
import { InvocationPolicy } from "../../../../../../../../protobuf/invocation_policy";
import { PackageLoadMetrics } from "../../packages/metrics/package_load_metrics";

export const protobufPackage = "build_event_stream";

/**
 * Enumeration type characterizing the size of a test, as specified by the
 * test rule.
 */
export enum TestSize {
  UNKNOWN = 0,
  SMALL = 1,
  MEDIUM = 2,
  LARGE = 3,
  ENORMOUS = 4,
  UNRECOGNIZED = -1,
}

export function testSizeFromJSON(object: any): TestSize {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return TestSize.UNKNOWN;
    case 1:
    case "SMALL":
      return TestSize.SMALL;
    case 2:
    case "MEDIUM":
      return TestSize.MEDIUM;
    case 3:
    case "LARGE":
      return TestSize.LARGE;
    case 4:
    case "ENORMOUS":
      return TestSize.ENORMOUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestSize.UNRECOGNIZED;
  }
}

export function testSizeToJSON(object: TestSize): string {
  switch (object) {
    case TestSize.UNKNOWN:
      return "UNKNOWN";
    case TestSize.SMALL:
      return "SMALL";
    case TestSize.MEDIUM:
      return "MEDIUM";
    case TestSize.LARGE:
      return "LARGE";
    case TestSize.ENORMOUS:
      return "ENORMOUS";
    case TestSize.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TestStatus {
  NO_STATUS = 0,
  PASSED = 1,
  FLAKY = 2,
  TIMEOUT = 3,
  FAILED = 4,
  INCOMPLETE = 5,
  REMOTE_FAILURE = 6,
  FAILED_TO_BUILD = 7,
  TOOL_HALTED_BEFORE_TESTING = 8,
  UNRECOGNIZED = -1,
}

export function testStatusFromJSON(object: any): TestStatus {
  switch (object) {
    case 0:
    case "NO_STATUS":
      return TestStatus.NO_STATUS;
    case 1:
    case "PASSED":
      return TestStatus.PASSED;
    case 2:
    case "FLAKY":
      return TestStatus.FLAKY;
    case 3:
    case "TIMEOUT":
      return TestStatus.TIMEOUT;
    case 4:
    case "FAILED":
      return TestStatus.FAILED;
    case 5:
    case "INCOMPLETE":
      return TestStatus.INCOMPLETE;
    case 6:
    case "REMOTE_FAILURE":
      return TestStatus.REMOTE_FAILURE;
    case 7:
    case "FAILED_TO_BUILD":
      return TestStatus.FAILED_TO_BUILD;
    case 8:
    case "TOOL_HALTED_BEFORE_TESTING":
      return TestStatus.TOOL_HALTED_BEFORE_TESTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestStatus.UNRECOGNIZED;
  }
}

export function testStatusToJSON(object: TestStatus): string {
  switch (object) {
    case TestStatus.NO_STATUS:
      return "NO_STATUS";
    case TestStatus.PASSED:
      return "PASSED";
    case TestStatus.FLAKY:
      return "FLAKY";
    case TestStatus.TIMEOUT:
      return "TIMEOUT";
    case TestStatus.FAILED:
      return "FAILED";
    case TestStatus.INCOMPLETE:
      return "INCOMPLETE";
    case TestStatus.REMOTE_FAILURE:
      return "REMOTE_FAILURE";
    case TestStatus.FAILED_TO_BUILD:
      return "FAILED_TO_BUILD";
    case TestStatus.TOOL_HALTED_BEFORE_TESTING:
      return "TOOL_HALTED_BEFORE_TESTING";
    case TestStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Identifier for a build event. It is deliberately structured to also provide
 * information about which build target etc the event is related to.
 *
 * Events are chained via the event id as follows: each event has an id and a
 * set of ids of children events such that apart from the initial event each
 * event has an id that is mentioned as child id in an earlier event and a build
 * invocation is complete if and only if all direct and indirect children of the
 * initial event have been posted.
 */
export interface BuildEventId {
  unknown?: BuildEventId_UnknownBuildEventId | undefined;
  progress?: BuildEventId_ProgressId | undefined;
  started?: BuildEventId_BuildStartedId | undefined;
  unstructuredCommandLine?: BuildEventId_UnstructuredCommandLineId | undefined;
  structuredCommandLine?: BuildEventId_StructuredCommandLineId | undefined;
  workspaceStatus?: BuildEventId_WorkspaceStatusId | undefined;
  optionsParsed?: BuildEventId_OptionsParsedId | undefined;
  fetch?: BuildEventId_FetchId | undefined;
  configuration?: BuildEventId_ConfigurationId | undefined;
  targetConfigured?: BuildEventId_TargetConfiguredId | undefined;
  pattern?: BuildEventId_PatternExpandedId | undefined;
  patternSkipped?: BuildEventId_PatternExpandedId | undefined;
  namedSet?: BuildEventId_NamedSetOfFilesId | undefined;
  targetCompleted?: BuildEventId_TargetCompletedId | undefined;
  actionCompleted?: BuildEventId_ActionCompletedId | undefined;
  unconfiguredLabel?: BuildEventId_UnconfiguredLabelId | undefined;
  configuredLabel?: BuildEventId_ConfiguredLabelId | undefined;
  testResult?: BuildEventId_TestResultId | undefined;
  testProgress?: BuildEventId_TestProgressId | undefined;
  testSummary?: BuildEventId_TestSummaryId | undefined;
  targetSummary?: BuildEventId_TargetSummaryId | undefined;
  buildFinished?: BuildEventId_BuildFinishedId | undefined;
  buildToolLogs?: BuildEventId_BuildToolLogsId | undefined;
  buildMetrics?: BuildEventId_BuildMetricsId | undefined;
  workspace?: BuildEventId_WorkspaceConfigId | undefined;
  buildMetadata?: BuildEventId_BuildMetadataId | undefined;
  convenienceSymlinksIdentified?: BuildEventId_ConvenienceSymlinksIdentifiedId | undefined;
  execRequest?: BuildEventId_ExecRequestId | undefined;
}

/**
 * Generic identifier for a build event. This is the default type of
 * BuildEventId, but should not be used outside testing; nevertheless,
 * tools should handle build events with this kind of id gracefully.
 */
export interface BuildEventId_UnknownBuildEventId {
  details: string;
}

/**
 * Identifier of an event reporting progress. Those events are also used to
 * chain in events that come early.
 */
export interface BuildEventId_ProgressId {
  /**
   * Unique identifier. No assumption should be made about how the ids are
   * assigned; the only meaningful operation on this field is test for
   * equality.
   */
  opaqueCount: number;
}

/**
 * Identifier of an event indicating the beginning of a build; this will
 * normally be the first event.
 */
export interface BuildEventId_BuildStartedId {
}

/**
 * Identifier on an event indicating the original commandline received by
 * the bazel server.
 */
export interface BuildEventId_UnstructuredCommandLineId {
}

/** Identifier on an event describing the commandline received by Bazel. */
export interface BuildEventId_StructuredCommandLineId {
  /**
   * A title for this command line value, as there may be multiple.
   * For example, a single invocation may wish to report both the literal and
   * canonical command lines, and this label would be used to differentiate
   * between both versions.
   */
  commandLineLabel: string;
}

/** Identifier of an event indicating the workspace status. */
export interface BuildEventId_WorkspaceStatusId {
}

/**
 * Identifier on an event reporting on the options included in the command
 * line, both explicitly and implicitly.
 */
export interface BuildEventId_OptionsParsedId {
}

/**
 * Identifier of an event reporting that an external resource was fetched
 * from.
 */
export interface BuildEventId_FetchId {
  /** The external resource that was fetched from. */
  url: string;
  /** The downloader used to fetch the resource. */
  downloader: BuildEventId_FetchId_Downloader;
}

export enum BuildEventId_FetchId_Downloader {
  UNKNOWN = 0,
  HTTP = 1,
  GRPC = 2,
  UNRECOGNIZED = -1,
}

export function buildEventId_FetchId_DownloaderFromJSON(object: any): BuildEventId_FetchId_Downloader {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return BuildEventId_FetchId_Downloader.UNKNOWN;
    case 1:
    case "HTTP":
      return BuildEventId_FetchId_Downloader.HTTP;
    case 2:
    case "GRPC":
      return BuildEventId_FetchId_Downloader.GRPC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuildEventId_FetchId_Downloader.UNRECOGNIZED;
  }
}

export function buildEventId_FetchId_DownloaderToJSON(object: BuildEventId_FetchId_Downloader): string {
  switch (object) {
    case BuildEventId_FetchId_Downloader.UNKNOWN:
      return "UNKNOWN";
    case BuildEventId_FetchId_Downloader.HTTP:
      return "HTTP";
    case BuildEventId_FetchId_Downloader.GRPC:
      return "GRPC";
    case BuildEventId_FetchId_Downloader.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Identifier of an event indicating that a target pattern has been expanded
 * further.
 * Messages of this shape are also used to describe parts of a pattern that
 * have been skipped for some reason, if the actual expansion was still
 * carried out (e.g., if keep_going is set). In this case, the
 * pattern_skipped choice in the id field is to be made.
 */
export interface BuildEventId_PatternExpandedId {
  pattern: string[];
}

export interface BuildEventId_WorkspaceConfigId {
}

export interface BuildEventId_BuildMetadataId {
}

/**
 * Identifier of an event indicating that a target has been expanded by
 * identifying for which configurations it should be build.
 */
export interface BuildEventId_TargetConfiguredId {
  label: string;
  /**
   * If empty, the id refers to the expansion of the target. If not-empty,
   * the id refers to the expansion of an aspect applied to the (already
   * expanded) target.
   *
   * For example, when building an apple_binary that depends on proto_library
   * "//:foo_proto", there will be two TargetConfigured events for
   * "//:foo_proto":
   *
   * 1. An event with an empty aspect, corresponding to actions producing
   * language-agnostic outputs from the proto_library; and
   * 2. An event with aspect "ObjcProtoAspect", corresponding to Objective-C
   * code generation.
   */
  aspect: string;
}

/**
 * Identifier of an event introducing a named set of files (usually artifacts)
 * to be referred to in later messages.
 */
export interface BuildEventId_NamedSetOfFilesId {
  /**
   * Identifier of the file set; this is an opaque string valid only for the
   * particular instance of the event stream.
   */
  id: string;
}

/** Identifier of an event introducing a configuration. */
export interface BuildEventId_ConfigurationId {
  /**
   * Identifier of the configuration; users of the protocol should not make
   * any assumptions about it having any structure, or equality of the
   * identifier between different streams.
   *
   * A value of "none" means the null configuration. It is used for targets
   * that are not configurable, for example, source files.
   */
  id: string;
}

/**
 * Identifier of an event indicating that a target was built completely; this
 * does not include running the test if the target is a test target.
 */
export interface BuildEventId_TargetCompletedId {
  label: string;
  /** The configuration for which the target was built. */
  configuration:
    | BuildEventId_ConfigurationId
    | undefined;
  /**
   * If empty, the id refers to the completion of the target. If not-empty,
   * the id refers to the completion of an aspect applied to the (already
   * completed) target.
   *
   * For example, when building an apple_binary that depends on proto_library
   * "//:foo_proto", there will be two TargetCompleted events for
   * "//:foo_proto":
   *
   * 1. An event with an empty aspect, corresponding to actions producing
   * language-agnostic outputs from the proto_library; and
   * 2. An event with aspect "ObjcProtoAspect", corresponding to Objective-C
   * code generation.
   */
  aspect: string;
}

/**
 * Identifier of an event reporting that an action was completed (not all
 * actions are reported, only the ones that can be considered important;
 * this includes all failed actions).
 */
export interface BuildEventId_ActionCompletedId {
  primaryOutput: string;
  /** Optional, the label of the owner of the action, for reference. */
  label: string;
  /** Optional, the id of the configuration of the action owner. */
  configuration: BuildEventId_ConfigurationId | undefined;
}

/**
 * Identifier of an event reporting an event associated with an unconfigured
 * label. Usually, this indicates a failure due to a missing input file. In
 * any case, it will report some form of error (i.e., the payload will be an
 * Aborted event); there are no regular events using this identifier. The
 * purpose of those events is to serve as the root cause of a failed target.
 */
export interface BuildEventId_UnconfiguredLabelId {
  label: string;
}

/**
 * Identifier of an event reporting an event associated with a configured
 * label, usually a visibility error. In any case, an event with such an
 * id will always report some form of error (i.e., the payload will be an
 * Aborted event); there are no regular events using this identifier.
 */
export interface BuildEventId_ConfiguredLabelId {
  label: string;
  configuration: BuildEventId_ConfigurationId | undefined;
}

/**
 * Identifier of an event reporting on an individual test run. The label
 * identifies the test that is reported about, the remaining fields are
 * in such a way as to uniquely identify the action within a build. In fact,
 * attempts for the same test, run, shard triple are counted sequentially,
 * starting with 1.
 */
export interface BuildEventId_TestResultId {
  label: string;
  configuration: BuildEventId_ConfigurationId | undefined;
  run: number;
  shard: number;
  attempt: number;
}

/** Identifier of an event reporting progress of an individual test run. */
export interface BuildEventId_TestProgressId {
  /** The label of the target for the action. */
  label: string;
  /** The configuration under which the action is running. */
  configuration:
    | BuildEventId_ConfigurationId
    | undefined;
  /** The run number of the test action (e.g. for runs_per_test > 1). */
  run: number;
  /** For sharded tests, the shard number of the test action. */
  shard: number;
  /**
   * The execution attempt number which may increase due to retries (e.g. for
   * flaky tests).
   */
  attempt: number;
  /**
   * An incrementing count used to differentiate TestProgressIds for the same
   * test attempt.
   */
  opaqueCount: number;
}

/** Identifier of an event reporting the summary of a test. */
export interface BuildEventId_TestSummaryId {
  label: string;
  configuration: BuildEventId_ConfigurationId | undefined;
}

/** Identifier of an event reporting the summary of a target. */
export interface BuildEventId_TargetSummaryId {
  label: string;
  configuration: BuildEventId_ConfigurationId | undefined;
}

/** Identifier of the BuildFinished event, indicating the end of a build. */
export interface BuildEventId_BuildFinishedId {
}

/**
 * Identifier of an event providing additional logs/statistics after
 * completion of the build.
 */
export interface BuildEventId_BuildToolLogsId {
}

/**
 * Identifier of an event providing build metrics after completion
 * of the build.
 */
export interface BuildEventId_BuildMetricsId {
}

/** Identifier of an event providing convenience symlinks information. */
export interface BuildEventId_ConvenienceSymlinksIdentifiedId {
}

/** Identifier of an event providing the ExecRequest of a run command. */
export interface BuildEventId_ExecRequestId {
}

/**
 * Payload of an event summarizing the progress of the build so far. Those
 * events are also used to be parents of events where the more logical parent
 * event cannot be posted yet as the needed information is not yet complete.
 */
export interface Progress {
  /**
   * The next chunk of stdout that bazel produced since the last progress event
   * or the beginning of the build.
   * Consumers that need to reason about the relative order of stdout and stderr
   * can assume that stderr has been emitted before stdout if both are present,
   * on a best-effort basis.
   */
  stdout: string;
  /**
   * The next chunk of stderr that bazel produced since the last progress event
   * or the beginning of the build.
   * Consumers that need to reason about the relative order of stdout and stderr
   * can assume that stderr has been emitted before stdout if both are present,
   * on a best-effort basis.
   */
  stderr: string;
}

/**
 * Payload of an event indicating that an expected event will not come, as
 * the build is aborted prematurely for some reason.
 */
export interface Aborted {
  reason: Aborted_AbortReason;
  /**
   * A human readable description with more details about there reason, where
   * available and useful.
   */
  description: string;
}

export enum Aborted_AbortReason {
  UNKNOWN = 0,
  /** USER_INTERRUPTED - The user requested the build to be aborted (e.g., by hitting Ctl-C). */
  USER_INTERRUPTED = 1,
  /** NO_ANALYZE - The user requested that no analysis be performed. */
  NO_ANALYZE = 8,
  /** NO_BUILD - The user requested that no build be carried out. */
  NO_BUILD = 9,
  /** TIME_OUT - The build or target was aborted as a timeout was exceeded. */
  TIME_OUT = 2,
  /**
   * REMOTE_ENVIRONMENT_FAILURE - The build or target was aborted as some remote environment (e.g., for
   * remote execution of actions) was not available in the expected way.
   */
  REMOTE_ENVIRONMENT_FAILURE = 3,
  /**
   * INTERNAL - Failure due to reasons entirely internal to the build tool, i.e. an
   * unexpected crash due to programmer error.
   */
  INTERNAL = 4,
  /** LOADING_FAILURE - A Failure occurred in the loading phase of a target. */
  LOADING_FAILURE = 5,
  /** ANALYSIS_FAILURE - A Failure occurred in the analysis phase of a target. */
  ANALYSIS_FAILURE = 6,
  /** SKIPPED - Target build was skipped (e.g. due to incompatible CPU constraints). */
  SKIPPED = 7,
  /**
   * INCOMPLETE - Build incomplete due to an earlier build failure (e.g. --keep_going was
   * set to false causing the build be ended upon failure).
   */
  INCOMPLETE = 10,
  /** OUT_OF_MEMORY - The build tool ran out of memory and crashed. */
  OUT_OF_MEMORY = 11,
  UNRECOGNIZED = -1,
}

export function aborted_AbortReasonFromJSON(object: any): Aborted_AbortReason {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return Aborted_AbortReason.UNKNOWN;
    case 1:
    case "USER_INTERRUPTED":
      return Aborted_AbortReason.USER_INTERRUPTED;
    case 8:
    case "NO_ANALYZE":
      return Aborted_AbortReason.NO_ANALYZE;
    case 9:
    case "NO_BUILD":
      return Aborted_AbortReason.NO_BUILD;
    case 2:
    case "TIME_OUT":
      return Aborted_AbortReason.TIME_OUT;
    case 3:
    case "REMOTE_ENVIRONMENT_FAILURE":
      return Aborted_AbortReason.REMOTE_ENVIRONMENT_FAILURE;
    case 4:
    case "INTERNAL":
      return Aborted_AbortReason.INTERNAL;
    case 5:
    case "LOADING_FAILURE":
      return Aborted_AbortReason.LOADING_FAILURE;
    case 6:
    case "ANALYSIS_FAILURE":
      return Aborted_AbortReason.ANALYSIS_FAILURE;
    case 7:
    case "SKIPPED":
      return Aborted_AbortReason.SKIPPED;
    case 10:
    case "INCOMPLETE":
      return Aborted_AbortReason.INCOMPLETE;
    case 11:
    case "OUT_OF_MEMORY":
      return Aborted_AbortReason.OUT_OF_MEMORY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Aborted_AbortReason.UNRECOGNIZED;
  }
}

export function aborted_AbortReasonToJSON(object: Aborted_AbortReason): string {
  switch (object) {
    case Aborted_AbortReason.UNKNOWN:
      return "UNKNOWN";
    case Aborted_AbortReason.USER_INTERRUPTED:
      return "USER_INTERRUPTED";
    case Aborted_AbortReason.NO_ANALYZE:
      return "NO_ANALYZE";
    case Aborted_AbortReason.NO_BUILD:
      return "NO_BUILD";
    case Aborted_AbortReason.TIME_OUT:
      return "TIME_OUT";
    case Aborted_AbortReason.REMOTE_ENVIRONMENT_FAILURE:
      return "REMOTE_ENVIRONMENT_FAILURE";
    case Aborted_AbortReason.INTERNAL:
      return "INTERNAL";
    case Aborted_AbortReason.LOADING_FAILURE:
      return "LOADING_FAILURE";
    case Aborted_AbortReason.ANALYSIS_FAILURE:
      return "ANALYSIS_FAILURE";
    case Aborted_AbortReason.SKIPPED:
      return "SKIPPED";
    case Aborted_AbortReason.INCOMPLETE:
      return "INCOMPLETE";
    case Aborted_AbortReason.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case Aborted_AbortReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Payload of an event indicating the beginning of a new build. Usually, events
 * of those type start a new build-event stream. The target pattern requested
 * to be build is contained in one of the announced child events; it is an
 * invariant that precisely one of the announced child events has a non-empty
 * target pattern.
 */
export interface BuildStarted {
  uuid: string;
  /**
   * Start of the build in ms since the epoch.
   *
   * Deprecated, use `start_time` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  startTimeMillis: string;
  /** Start of the build. */
  startTime:
    | Date
    | undefined;
  /** Version of the build tool that is running. */
  buildToolVersion: string;
  /** A human-readable description of all the non-default option settings */
  optionsDescription: string;
  /** The name of the command that the user invoked. */
  command: string;
  /** The working directory from which the build tool was invoked. */
  workingDirectory: string;
  /** The directory of the workspace. */
  workspaceDirectory: string;
  /** The process ID of the Bazel server. */
  serverPid: string;
}

/** Configuration related to the blaze workspace and output tree. */
export interface WorkspaceConfig {
  /**
   * The root of the local blaze exec root. All output files live underneath
   * this at "blaze-out/".
   */
  localExecRoot: string;
}

/**
 * Payload of an event reporting the command-line of the invocation as
 * originally received by the server. Note that this is not the command-line
 * given by the user, as the client adds information about the invocation,
 * like name and relevant entries of rc-files and client environment variables.
 * However, it does contain enough information to reproduce the build
 * invocation.
 */
export interface UnstructuredCommandLine {
  args: string[];
}

/** Payload of an event reporting on the parsed options, grouped in various ways. */
export interface OptionsParsed {
  startupOptions: string[];
  explicitStartupOptions: string[];
  cmdLine: string[];
  explicitCmdLine: string[];
  invocationPolicy: InvocationPolicy | undefined;
  toolTag: string;
}

/**
 * Payload of an event indicating that an external resource was fetched. This
 * event will only occur in streams where an actual fetch happened, not in ones
 * where a cached copy of the entity to be fetched was used.
 */
export interface Fetch {
  success: boolean;
}

/**
 * Payload of an event reporting the workspace status. Key-value pairs can be
 * provided by specifying the workspace_status_command to an executable that
 * returns one key-value pair per line of output (key and value separated by a
 * space).
 */
export interface WorkspaceStatus {
  item: WorkspaceStatus_Item[];
}

export interface WorkspaceStatus_Item {
  key: string;
  value: string;
}

/**
 * Payload of an event reporting custom key-value metadata associated with the
 * build.
 */
export interface BuildMetadata {
  /** Custom metadata for the build. */
  metadata: { [key: string]: string };
}

export interface BuildMetadata_MetadataEntry {
  key: string;
  value: string;
}

/** Payload of an event reporting details of a given configuration. */
export interface Configuration {
  mnemonic: string;
  platformName: string;
  cpu: string;
  makeVariable: { [key: string]: string };
  /** Whether this configuration is used for building tools. */
  isTool: boolean;
}

export interface Configuration_MakeVariableEntry {
  key: string;
  value: string;
}

/**
 * Payload of the event indicating the expansion of a target pattern.
 * The main information is in the chaining part: the id will contain the
 * target pattern that was expanded and the children id will contain the
 * target or target pattern it was expanded to.
 */
export interface PatternExpanded {
  /**
   * All test suites requested via top-level target patterns. Does not include
   * test suites whose label matched a negative pattern.
   */
  testSuiteExpansions: PatternExpanded_TestSuiteExpansion[];
}

/**
 * Represents a test_suite target and the tests that it expanded to. Nested
 * test suites are recursively expanded. The test labels only contain the
 * final test targets, not any nested suites.
 */
export interface PatternExpanded_TestSuiteExpansion {
  /** The label of the test_suite rule. */
  suiteLabel: string;
  /**
   * Labels of the test targets included in the suite. Includes all tests in
   * the suite regardless of any filters or negative patterns which may result
   * in the test not actually being run.
   */
  testLabels: string[];
}

/**
 * Payload of the event indicating that the configurations for a target have
 * been identified. As with pattern expansion the main information is in the
 * chaining part: the id will contain the target that was configured and the
 * children id will contain the configured targets it was configured to.
 */
export interface TargetConfigured {
  /**
   * The kind of target (e.g.,  e.g. "cc_library rule", "source file",
   * "generated file") where the completion is reported.
   */
  targetKind: string;
  /** The size of the test, if the target is a test target. Unset otherwise. */
  testSize: TestSize;
  /**
   * List of all tags associated with this target (for all possible
   * configurations).
   */
  tag: string[];
}

export interface File {
  /**
   * A sequence of prefixes to apply to the file name to construct a full path.
   * In most but not all cases, there will be 3 entries:
   *  1. A root output directory, eg "bazel-out"
   *  2. A configuration mnemonic, eg "k8-fastbuild"
   *  3. An output category, eg "genfiles"
   */
  pathPrefix: string[];
  /** identifier indicating the nature of the file (e.g., "stdout", "stderr") */
  name: string;
  /**
   * A location where the contents of the file can be found. The string is
   * encoded according to RFC2396.
   */
  uri?:
    | string
    | undefined;
  /** The contents of the file, if they are guaranteed to be short. */
  contents?:
    | Uint8Array
    | undefined;
  /** The symlink target path, if the file is an unresolved symlink. */
  symlinkTargetPath?:
    | string
    | undefined;
  /**
   * Digest of the file, using the build tool's configured digest algorithm,
   * hex-encoded.
   */
  digest: string;
  /** Length of the file in bytes. */
  length: string;
}

/**
 * Payload of a message to describe a set of files, usually build artifacts, to
 * be referred to later by their name. In this way, files that occur identically
 * as outputs of several targets have to be named only once.
 */
export interface NamedSetOfFiles {
  /** Files that belong to this named set of files. */
  files: File[];
  /** Other named sets whose members also belong to this set. */
  fileSets: BuildEventId_NamedSetOfFilesId[];
}

/**
 * Payload of the event indicating the completion of an action. The main purpose
 * of posting those events is to provide details on the root cause for a target
 * failing; however, consumers of the build-event protocol must not assume
 * that only failed actions are posted.
 */
export interface ActionExecuted {
  success: boolean;
  /** The mnemonic of the action that was executed */
  type: string;
  /** The exit code of the action, if it is available. */
  exitCode: number;
  /**
   * Location where to find the standard output of the action
   * (e.g., a file path).
   */
  stdout:
    | File
    | undefined;
  /**
   * Location where to find the standard error of the action
   * (e.g., a file path).
   */
  stderr:
    | File
    | undefined;
  /**
   * Deprecated. This field is now present on ActionCompletedId.
   *
   * @deprecated
   */
  label: string;
  /**
   * Deprecated. This field is now present on ActionCompletedId.
   *
   * @deprecated
   */
  configuration:
    | BuildEventId_ConfigurationId
    | undefined;
  /** Primary output; only provided for successful actions. */
  primaryOutput:
    | File
    | undefined;
  /** The command-line of the action, if the action is a command. */
  commandLine: string[];
  /** Only populated if success = false, and sometimes not even then. */
  failureDetail:
    | FailureDetail
    | undefined;
  /** Start of action execution, before any attempted execution begins. */
  startTime:
    | Date
    | undefined;
  /** End of action execution, after all attempted execution completes. */
  endTime:
    | Date
    | undefined;
  /**
   * Additional details about action execution supplied by strategies. Bazel
   * options will determine which strategy details are included when multiple
   * strategies are involved in a single action's execution.
   *
   * The default type will be `tools.proto.SpawnExec` found in `spawn.proto`.
   */
  strategyDetails: Any[];
}

/** Collection of all output files belonging to that output group. */
export interface OutputGroup {
  /** Name of the output group */
  name: string;
  /** List of file sets that belong to this output group as well. */
  fileSets: BuildEventId_NamedSetOfFilesId[];
  /**
   * Indicates that one or more of the output group's files were not built
   * successfully (the generating action failed).
   */
  incomplete: boolean;
  /**
   * Inlined files that belong to this output group, requested via
   * --experimental_build_event_output_group_mode.
   */
  inlineFiles: File[];
}

/**
 * Payload of the event indicating the completion of a target. The target is
 * specified in the id. If the target failed the root causes are provided as
 * children events.
 */
export interface TargetComplete {
  success: boolean;
  /**
   * The kind of target (e.g.,  e.g. "cc_library rule", "source file",
   * "generated file") where the completion is reported.
   * Deprecated: use the target_kind field in TargetConfigured instead.
   *
   * @deprecated
   */
  targetKind: string;
  /**
   * The size of the test, if the target is a test target. Unset otherwise.
   * Deprecated: use the test_size field in TargetConfigured instead.
   *
   * @deprecated
   */
  testSize: TestSize;
  /**
   * The output files are arranged by their output group. If an output file
   * is part of multiple output groups, it appears once in each output
   * group.
   */
  outputGroup: OutputGroup[];
  /**
   * Temporarily, also report the important outputs directly. This is only to
   * allow existing clients help transition to the deduplicated representation;
   * new clients should not use it.
   *
   * @deprecated
   */
  importantOutput: File[];
  /**
   * Report output artifacts (referenced transitively via output_group) which
   * emit directories instead of singleton files. These directory_output entries
   * will never include a uri.
   */
  directoryOutput: File[];
  /** List of tags associated with this configured target. */
  tag: string[];
  /**
   * The timeout specified for test actions under this configured target.
   *
   * Deprecated, use `test_timeout` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  testTimeoutSeconds: string;
  /** The timeout specified for test actions under this configured target. */
  testTimeout:
    | Duration
    | undefined;
  /**
   * Failure information about the target, only populated if success is false,
   * and sometimes not even then. Equal to one of the ActionExecuted
   * failure_detail fields for one of the root cause ActionExecuted events.
   */
  failureDetail: FailureDetail | undefined;
}

/** Payload on events reporting about individual test action. */
export interface TestResult {
  /** The status of this test. */
  status: TestStatus;
  /**
   * Additional details about the status of the test. This is intended for
   * user display and must not be parsed.
   */
  statusDetails: string;
  /** True, if the reported attempt is taken from the tool's local cache. */
  cachedLocally: boolean;
  /**
   * Time in milliseconds since the epoch at which the test attempt was started.
   * Note: for cached test results, this is time can be before the start of the
   * build.
   *
   * Deprecated, use `test_attempt_start` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  testAttemptStartMillisEpoch: string;
  /**
   * Time at which the test attempt was started.
   * Note: for cached test results, this is time can be before the start of the
   * build.
   */
  testAttemptStart:
    | Date
    | undefined;
  /**
   * Time the test took to run. For locally cached results, this is the time
   * the cached invocation took when it was invoked.
   *
   * Deprecated, use `test_attempt_duration` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  testAttemptDurationMillis: string;
  /**
   * Time the test took to run. For locally cached results, this is the time
   * the cached invocation took when it was invoked.
   */
  testAttemptDuration:
    | Duration
    | undefined;
  /**
   * Files (logs, test.xml, undeclared outputs, etc) generated by that test
   * action.
   */
  testActionOutput: File[];
  /** Warnings generated by that test action. */
  warning: string[];
  executionInfo: TestResult_ExecutionInfo | undefined;
}

/**
 * Message providing optional meta data on the execution of the test action,
 * if available.
 */
export interface TestResult_ExecutionInfo {
  /**
   * Deprecated, use TargetComplete.test_timeout instead.
   *
   * @deprecated
   */
  timeoutSeconds: number;
  /**
   * Name of the strategy to execute this test action (e.g., "local",
   * "remote")
   */
  strategy: string;
  /** True, if the reported attempt was a cache hit in a remote cache. */
  cachedRemotely: boolean;
  /** The exit code of the test action. */
  exitCode: number;
  /**
   * The hostname of the machine where the test action was executed (in case
   * of remote execution), if known.
   */
  hostname: string;
  timingBreakdown: TestResult_ExecutionInfo_TimingBreakdown | undefined;
  resourceUsage: TestResult_ExecutionInfo_ResourceUsage[];
}

/**
 * Represents a hierarchical timing breakdown of an activity.
 * The top level time should be the total time of the activity.
 * Invariant: `time` >= sum of `time`s of all direct children.
 */
export interface TestResult_ExecutionInfo_TimingBreakdown {
  child: TestResult_ExecutionInfo_TimingBreakdown[];
  name: string;
  /**
   * Deprecated, use `time` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  timeMillis: string;
  time: Duration | undefined;
}

export interface TestResult_ExecutionInfo_ResourceUsage {
  name: string;
  value: string;
}

/** Event payload providing information about an active, individual test run. */
export interface TestProgress {
  /**
   * Identifies a resource that may provide information about an active test
   * run. The resource is not necessarily a file and may need to be queried
   * for information. The URI is not guaranteed to be available after the test
   * completes. The string is encoded according to RFC2396.
   */
  uri: string;
}

/** Payload of the event summarizing a test. */
export interface TestSummary {
  /**
   * Wrapper around BlazeTestStatus to support importing that enum to proto3.
   * Overall status of test, accumulated over all runs, shards, and attempts.
   */
  overallStatus: TestStatus;
  /**
   * Total number of shard attempts.
   * E.g., if a target has 4 runs, 3 shards, each with 2 attempts,
   * then total_run_count will be 4*3*2 = 24.
   */
  totalRunCount: number;
  /** Value of runs_per_test for the test. */
  runCount: number;
  /**
   * Number of attempts.
   * If there are a different number of attempts per shard, the highest attempt
   * count across all shards for each run is used.
   */
  attemptCount: number;
  /** Number of shards. */
  shardCount: number;
  /** Path to logs of passed runs. */
  passed: File[];
  /** Path to logs of failed runs; */
  failed: File[];
  /** Total number of cached test actions */
  totalNumCached: number;
  /**
   * When the test first started running.
   *
   * Deprecated, use `first_start_time` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  firstStartTimeMillis: string;
  /** When the test first started running. */
  firstStartTime:
    | Date
    | undefined;
  /**
   * When the last test action completed.
   *
   * Deprecated, use `last_stop_time` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  lastStopTimeMillis: string;
  /** When the test first started running. */
  lastStopTime:
    | Date
    | undefined;
  /**
   * The total runtime of the test.
   *
   * Deprecated, use `total_run` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  totalRunDurationMillis: string;
  /** The total runtime of the test. */
  totalRunDuration: Duration | undefined;
}

/** Payload of the event summarizing a target (test or non-test). */
export interface TargetSummary {
  /** Conjunction of TargetComplete events for this target, including aspects. */
  overallBuildSuccess: boolean;
  /**
   * For non-test targets, set to NO_STATUS. For test targets, identical to
   * TestSummary.overall_status.
   *
   * There are some cases where the `build` command on a test target succeeds,
   * but the `test` command on the same target results in FAILED_TO_BUILD. In
   * such cases, TargetComplete.overall_build_success is true, but this field is
   * FAILED_TO_BUILD, and TestSummary may be missing.
   * TODO - b/186996003: TestSummary is a child of TargetComplete and should be
   *  posted.
   */
  overallTestStatus: TestStatus;
}

/** Event indicating the end of a build. */
export interface BuildFinished {
  /**
   * If the build succeeded or failed.
   *
   * @deprecated
   */
  overallSuccess: boolean;
  /**
   * The overall status of the build. A build was successful iff
   * ExitCode.code equals 0.
   */
  exitCode:
    | BuildFinished_ExitCode
    | undefined;
  /**
   * End of the build in ms since the epoch.
   *
   * Deprecated, use `finish_time` instead.
   *
   * TODO(yannic): Remove.
   *
   * @deprecated
   */
  finishTimeMillis: string;
  /** End of the build. */
  finishTime:
    | Date
    | undefined;
  /** @deprecated */
  anomalyReport:
    | BuildFinished_AnomalyReport
    | undefined;
  /** Only populated if success = false, and sometimes not even then. */
  failureDetail: FailureDetail | undefined;
}

/**
 * Exit code of a build. The possible values correspond to the predefined
 * codes in bazel's lib.ExitCode class, as well as any custom exit code a
 * module might define. The predefined exit codes are subject to change (but
 * rarely do) and are not part of the public API.
 *
 * A build was successful iff ExitCode.code equals 0.
 */
export interface BuildFinished_ExitCode {
  /** The name of the exit code. */
  name: string;
  /** The exit code. */
  code: number;
}

/** Things that happened during the build that could be of interest. */
export interface BuildFinished_AnomalyReport {
  /**
   * Was the build suspended at any time during the build.
   * Examples of suspensions are SIGSTOP, or the hardware being put to sleep.
   * If was_suspended is true, then most of the timings for this build are
   * suspect.
   * NOTE: This is no longer set and is deprecated.
   */
  wasSuspended: boolean;
}

export interface BuildMetrics {
  actionSummary: BuildMetrics_ActionSummary | undefined;
  memoryMetrics: BuildMetrics_MemoryMetrics | undefined;
  targetMetrics: BuildMetrics_TargetMetrics | undefined;
  packageMetrics: BuildMetrics_PackageMetrics | undefined;
  timingMetrics: BuildMetrics_TimingMetrics | undefined;
  cumulativeMetrics: BuildMetrics_CumulativeMetrics | undefined;
  artifactMetrics: BuildMetrics_ArtifactMetrics | undefined;
  buildGraphMetrics: BuildMetrics_BuildGraphMetrics | undefined;
  workerMetrics: BuildMetrics_WorkerMetrics[];
  networkMetrics: BuildMetrics_NetworkMetrics | undefined;
  workerPoolMetrics: BuildMetrics_WorkerPoolMetrics | undefined;
  dynamicExecutionMetrics: BuildMetrics_DynamicExecutionMetrics | undefined;
  remoteAnalysisCacheStatistics: BuildMetrics_RemoteAnalysisCacheStatistics | undefined;
}

export interface BuildMetrics_ActionSummary {
  /**
   * The total number of actions created and registered during the build,
   * including both aspects and configured targets. This metric includes
   * unused actions that were constructed but not executed during this build.
   * It does not include actions that were created on prior builds that are
   * still valid, even if those actions had to be re-executed on this build.
   * For the total number of actions that would be created if this invocation
   * were "clean", see BuildGraphMetrics below.
   */
  actionsCreated: string;
  /**
   * The total number of actions created this build just by configured
   * targets. Used mainly to allow consumers of actions_created, which used to
   * not include aspects' actions, to normalize across the Blaze release that
   * switched actions_created to include all created actions.
   */
  actionsCreatedNotIncludingAspects: string;
  /**
   * The total number of actions executed during the build. This includes any
   * remote cache hits, but excludes local action cache hits.
   */
  actionsExecuted: string;
  /** Contains the top N actions by number of actions executed. */
  actionData: BuildMetrics_ActionSummary_ActionData[];
  /**
   * Deprecated. The total number of remote cache hits.
   *
   * @deprecated
   */
  remoteCacheHits: string;
  runnerCount: BuildMetrics_ActionSummary_RunnerCount[];
  actionCacheStatistics: ActionCacheStatistics | undefined;
}

export interface BuildMetrics_ActionSummary_ActionData {
  mnemonic: string;
  /**
   * The total number of actions of this type executed during the build. As
   * above, includes remote cache hits but excludes local action cache hits.
   */
  actionsExecuted: string;
  /**
   * When the first action of this type started being executed, in
   * milliseconds from the epoch.
   */
  firstStartedMs: string;
  /**
   * When the last action of this type ended being executed, in
   * milliseconds from the epoch.
   */
  lastEndedMs: string;
  /**
   * Accumulated CPU time of all spawned actions of this type.
   * This is only set if all the actions reported a time
   */
  systemTime: Duration | undefined;
  userTime:
    | Duration
    | undefined;
  /** The total number of actions of this type registered during the build. */
  actionsCreated: string;
}

export interface BuildMetrics_ActionSummary_RunnerCount {
  name: string;
  count: number;
  execKind: string;
}

export interface BuildMetrics_MemoryMetrics {
  /**
   * Size of the JVM heap post build in bytes. This is only collected if
   * --memory_profile is set, since it forces a full GC.
   */
  usedHeapSizePostBuild: string;
  /**
   * Size of the peak JVM heap size in bytes post GC. Note that this reports 0
   * if there was no major GC during the build.
   */
  peakPostGcHeapSize: string;
  /**
   * Size of the peak tenured space JVM heap size event in bytes post GC. Note
   * that this reports 0 if there was no major GC during the build.
   */
  peakPostGcTenuredSpaceHeapSize: string;
  garbageMetrics: BuildMetrics_MemoryMetrics_GarbageMetrics[];
}

export interface BuildMetrics_MemoryMetrics_GarbageMetrics {
  /** Type of garbage collected, e.g. G1 Old Gen. */
  type: string;
  /**
   * Number of bytes of garbage of the given type collected during this
   * invocation.
   */
  garbageCollected: string;
}

export interface BuildMetrics_TargetMetrics {
  /**
   * DEPRECATED
   * No longer populated. It never measured what it was supposed to (targets
   * loaded): it counted targets that were analyzed even if the underlying
   * package had not changed.
   * TODO(janakr): rename and remove.
   */
  targetsLoaded: string;
  /**
   * Number of targets/aspects configured during this build. Does not include
   * targets/aspects that were configured on prior builds on this server and
   * were cached. See BuildGraphMetrics below if you need that.
   */
  targetsConfigured: string;
  /**
   * Number of configured targets analyzed during this build. Does not include
   * aspects. Used mainly to allow consumers of targets_configured, which used
   * to not include aspects, to normalize across the Blaze release that
   * switched targets_configured to include aspects.
   */
  targetsConfiguredNotIncludingAspects: string;
}

export interface BuildMetrics_PackageMetrics {
  /**
   * Number of BUILD files (aka packages) successfully loaded during this
   * build.
   *
   * [For Bazel binaries built at source states] Before Dec 2021, this value
   * was the number of packages attempted to be loaded, for a particular
   * definition of "attempted".
   *
   * After Dec 2021, this value would sometimes overcount because the same
   * package could sometimes be attempted to be loaded multiple times due to
   * memory pressure.
   *
   * After Feb 2022, this value is the number of packages successfully
   * loaded.
   */
  packagesLoaded: string;
  /** Loading time metrics per package. */
  packageLoadMetrics: PackageLoadMetrics[];
}

export interface BuildMetrics_TimingMetrics {
  /**
   * For Skymeld, it's possible that
   * analysis_phase_time_in_ms + execution_phase_time_in_ms >= wall_time_in_ms
   *
   * The CPU time in milliseconds consumed during this build.
   */
  cpuTimeInMs: string;
  /** The elapsed wall time in milliseconds during this build. */
  wallTimeInMs: string;
  /**
   * The elapsed wall time in milliseconds during the analysis phase.
   * When analysis and execution phases are interleaved, this measures the
   * elapsed time from the first analysis work to the last.
   */
  analysisPhaseTimeInMs: string;
  /**
   * The elapsed wall time in milliseconds during the execution phase.
   * When analysis and execution phases are interleaved, this measures the
   * elapsed time from the first action execution (excluding workspace status
   * actions) to the last.
   */
  executionPhaseTimeInMs: string;
  /**
   * The elapsed wall time in milliseconds until the first action execution
   * started (excluding workspace status actions).
   */
  actionsExecutionStartInMs: string;
}

export interface BuildMetrics_CumulativeMetrics {
  /**
   * One-indexed number of "analyses" the server has run, including the
   * current one. Will be incremented for every build/test/cquery/etc. command
   * that reaches the analysis phase.
   */
  numAnalyses: number;
  /**
   * One-indexed number of "builds" the server has run, including the current
   * one. Will be incremented for every build/test/run/etc. command that
   * reaches the execution phase.
   */
  numBuilds: number;
}

export interface BuildMetrics_ArtifactMetrics {
  /**
   * Measures all source files newly read this build. Does not include
   * unchanged sources on incremental builds.
   */
  sourceArtifactsRead:
    | BuildMetrics_ArtifactMetrics_FilesMetric
    | undefined;
  /**
   * Measures all output artifacts from executed actions. This includes
   * actions that were cached locally (via the action cache) or remotely (via
   * a remote cache or executor), but does *not* include outputs of actions
   * that were cached internally in Skyframe.
   */
  outputArtifactsSeen:
    | BuildMetrics_ArtifactMetrics_FilesMetric
    | undefined;
  /**
   * Measures all output artifacts from actions that were cached locally
   * via the action cache. These artifacts were already present on disk at the
   * start of the build. Does not include Skyframe-cached actions' outputs.
   */
  outputArtifactsFromActionCache:
    | BuildMetrics_ArtifactMetrics_FilesMetric
    | undefined;
  /**
   * Measures all artifacts that belong to a top-level output group. Does not
   * deduplicate, so if there are two top-level targets in this build that
   * share an artifact, it will be counted twice.
   */
  topLevelArtifacts: BuildMetrics_ArtifactMetrics_FilesMetric | undefined;
}

export interface BuildMetrics_ArtifactMetrics_FilesMetric {
  sizeInBytes: string;
  count: number;
}

/** Data about the evaluation of Skyfunctions. */
export interface BuildMetrics_EvaluationStat {
  /** Name of the Skyfunction. */
  skyfunctionName: string;
  /** How many times a given operation was carried out on a Skyfunction. */
  count: string;
}

/**
 * Information about the size and shape of the build graph. Some fields may
 * not be populated if Bazel was able to skip steps due to caching.
 */
export interface BuildMetrics_BuildGraphMetrics {
  /**
   * How many configured targets/aspects were in this build, including any
   * that were analyzed on a prior build and are still valid. May not be
   * populated if analysis phase was fully cached. Note: for historical
   * reasons this includes input/output files and other configured targets
   * that do not actually have associated actions.
   */
  actionLookupValueCount: number;
  /**
   * How many configured targets alone were in this build: always at most
   * action_lookup_value_count. Useful mainly for historical comparisons to
   * TargetMetrics.targets_configured, which used to not count aspects. This
   * also includes configured targets that do not have associated actions.
   */
  actionLookupValueCountNotIncludingAspects: number;
  /**
   * How many actions belonged to the configured targets/aspects above. It may
   * not be necessary to execute all of these actions to build the requested
   * targets. May not be populated if analysis phase was fully cached.
   */
  actionCount: number;
  /**
   * How many actions belonged to configured targets: always at most
   * action_count. Useful mainly for historical comparisons to
   * ActionMetrics.actions_created, which used to not count aspects' actions.
   */
  actionCountNotIncludingAspects: number;
  /**
   * How many "input file" configured targets there were: one per source file.
   * Should agree with artifact_metrics.source_artifacts_read.count above,
   */
  inputFileConfiguredTargetCount: number;
  /**
   * How many "output file" configured targets there were: output files that
   * are targets (not implicit outputs).
   */
  outputFileConfiguredTargetCount: number;
  /**
   * How many "other" configured targets there were (like alias,
   * package_group, and other non-rule non-file configured targets).
   */
  otherConfiguredTargetCount: number;
  /**
   * How many artifacts are outputs of the above actions. May not be populated
   * if analysis phase was fully cached.
   */
  outputArtifactCount: number;
  /**
   * How many Skyframe nodes there are in memory at the end of the build. This
   * may underestimate the number of nodes when running with memory-saving
   * settings or with Skybuild, and may overestimate if there are nodes from
   * prior evaluations still in the cache.
   */
  postInvocationSkyframeNodeCount: number;
  /**
   * Number of SkyValues that were dirtied during the build. Dirtied nodes are
   * those that transitively depend on a node that changed by itself (e.g. one
   * representing a file in the file system)
   */
  dirtiedValues: BuildMetrics_EvaluationStat[];
  /**
   * Number of SkyValues that changed by themselves. For example, when a file
   * on the file system changes, the SkyValue representing it will change.
   */
  changedValues: BuildMetrics_EvaluationStat[];
  /**
   * Number of SkyValues that were built. This means that they were evaluated
   * and were found to have changed from their previous version.
   */
  builtValues: BuildMetrics_EvaluationStat[];
  /**
   * Number of SkyValues that were evaluated and found clean, i.e. equal to
   * their previous version.
   */
  cleanedValues: BuildMetrics_EvaluationStat[];
  /**
   * Number of evaluations to build SkyValues. This includes restarted
   * evaluations, which means there can be multiple evaluations per built
   * SkyValue. Subtract built_values from this number to get the number of
   * restarted evaluations.
   */
  evaluatedValues: BuildMetrics_EvaluationStat[];
  ruleClass: BuildMetrics_BuildGraphMetrics_RuleClassCount[];
  aspect: BuildMetrics_BuildGraphMetrics_AspectCount[];
}

/**
 * For SkyKeys in 'done values' where the SkyValue is of type
 * RuleConfiguredTargetValue, we pull those out separately and report the
 * ruleClass and action count.
 */
export interface BuildMetrics_BuildGraphMetrics_RuleClassCount {
  /** Unique key for the rule class. */
  key: string;
  /** String name of the rule_class (not guaranteed unique) */
  ruleClass: string;
  /** how many rule instances of this type were seen. */
  count: string;
  /** how many actions were created by this rule class. */
  actionCount: string;
}

/** For SkyKeys whose function name is ASPECT break out that information */
export interface BuildMetrics_BuildGraphMetrics_AspectCount {
  /** Unique key for Aspect. */
  key: string;
  /** usually the same as above, but can differ in some cases. */
  aspectName: string;
  /** number of aspects created of this type. */
  count: string;
  /** number of actions created by aspects of this type. */
  actionCount: string;
}

/** Information about all workers that were alive during the invocation. */
export interface BuildMetrics_WorkerMetrics {
  /**
   * Deprecated. Use worker_ids instead of this field.
   *
   * @deprecated
   */
  workerId: number;
  /** Ids of workers. Could be multiple in case of multiplex workers */
  workerIds: number[];
  /** Worker process id. If there is no process for worker, equals to zero. */
  processId: number;
  /** Mnemonic of running worker. */
  mnemonic: string;
  /** Multiplex or singleplex worker. */
  isMultiplex: boolean;
  /** Using worker sandbox file system or not. */
  isSandbox: boolean;
  /**
   * TODO(b/300067854): Deprecate since all worker metrics should have their
   * WorkerStats set.
   */
  isMeasurable: boolean;
  /**
   * Hash value of worker key. Needed to distinguish worker pools with same
   * menmonic but with different worker keys.
   */
  workerKeyHash: string;
  workerStatus: BuildMetrics_WorkerMetrics_WorkerStatus;
  code?: Worker_Code | undefined;
  actionsExecuted: string;
  priorActionsExecuted: string;
  /** Combined workers statistics. */
  workerStats: BuildMetrics_WorkerMetrics_WorkerStats[];
}

export enum BuildMetrics_WorkerMetrics_WorkerStatus {
  /**
   * NOT_STARTED - Used to indicate a worker instance where the process has not been
   * created yet. In reality this isn't logged, but leaving this here as a
   * possible option in the future.
   */
  NOT_STARTED = 0,
  ALIVE = 1,
  KILLED_DUE_TO_MEMORY_PRESSURE = 2,
  /**
   * KILLED_UNKNOWN - Indicates that the worker process was killed due to a reason unknown to
   * Bazel at the point of measurement; if a known cause (below) comes along
   * later on, this field will be updated.
   */
  KILLED_UNKNOWN = 3,
  KILLED_DUE_TO_INTERRUPTED_EXCEPTION = 4,
  KILLED_DUE_TO_IO_EXCEPTION = 5,
  KILLED_DUE_TO_USER_EXEC_EXCEPTION = 6,
  UNRECOGNIZED = -1,
}

export function buildMetrics_WorkerMetrics_WorkerStatusFromJSON(object: any): BuildMetrics_WorkerMetrics_WorkerStatus {
  switch (object) {
    case 0:
    case "NOT_STARTED":
      return BuildMetrics_WorkerMetrics_WorkerStatus.NOT_STARTED;
    case 1:
    case "ALIVE":
      return BuildMetrics_WorkerMetrics_WorkerStatus.ALIVE;
    case 2:
    case "KILLED_DUE_TO_MEMORY_PRESSURE":
      return BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_MEMORY_PRESSURE;
    case 3:
    case "KILLED_UNKNOWN":
      return BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_UNKNOWN;
    case 4:
    case "KILLED_DUE_TO_INTERRUPTED_EXCEPTION":
      return BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_INTERRUPTED_EXCEPTION;
    case 5:
    case "KILLED_DUE_TO_IO_EXCEPTION":
      return BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_IO_EXCEPTION;
    case 6:
    case "KILLED_DUE_TO_USER_EXEC_EXCEPTION":
      return BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_USER_EXEC_EXCEPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuildMetrics_WorkerMetrics_WorkerStatus.UNRECOGNIZED;
  }
}

export function buildMetrics_WorkerMetrics_WorkerStatusToJSON(object: BuildMetrics_WorkerMetrics_WorkerStatus): string {
  switch (object) {
    case BuildMetrics_WorkerMetrics_WorkerStatus.NOT_STARTED:
      return "NOT_STARTED";
    case BuildMetrics_WorkerMetrics_WorkerStatus.ALIVE:
      return "ALIVE";
    case BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_MEMORY_PRESSURE:
      return "KILLED_DUE_TO_MEMORY_PRESSURE";
    case BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_UNKNOWN:
      return "KILLED_UNKNOWN";
    case BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_INTERRUPTED_EXCEPTION:
      return "KILLED_DUE_TO_INTERRUPTED_EXCEPTION";
    case BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_IO_EXCEPTION:
      return "KILLED_DUE_TO_IO_EXCEPTION";
    case BuildMetrics_WorkerMetrics_WorkerStatus.KILLED_DUE_TO_USER_EXEC_EXCEPTION:
      return "KILLED_DUE_TO_USER_EXEC_EXCEPTION";
    case BuildMetrics_WorkerMetrics_WorkerStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information collected from worker at some point. */
export interface BuildMetrics_WorkerMetrics_WorkerStats {
  /** Epoch unix time of collection of metrics. */
  collectTimeInMs: string;
  /** Memory usage of worker process at the end of the build. */
  workerMemoryInKb: number;
  /** Memory usage of the worker process prior to the invocation. */
  priorWorkerMemoryInKb: number;
  /** Epoch unix time of last action started on specific worker. */
  lastActionStartTimeInMs: string;
}

/** Information about host network. */
export interface BuildMetrics_NetworkMetrics {
  systemNetworkStats: BuildMetrics_NetworkMetrics_SystemNetworkStats | undefined;
}

/**
 * Information for all the network traffic going on on the host machine
 * during the invocation.
 */
export interface BuildMetrics_NetworkMetrics_SystemNetworkStats {
  /** Total bytes sent during the invocation. */
  bytesSent: string;
  /** Total bytes received during the invocation. */
  bytesRecv: string;
  /** Total packets sent during the invocation. */
  packetsSent: string;
  /** Total packets received during the invocation. */
  packetsRecv: string;
  /** Peak bytes/sec sent during the invocation. */
  peakBytesSentPerSec: string;
  /** Peak bytes/sec received during the invocation. */
  peakBytesRecvPerSec: string;
  /** Peak packets/sec sent during the invocation. */
  peakPacketsSentPerSec: string;
  /** Peak packets/sec received during the invocation. */
  peakPacketsRecvPerSec: string;
}

/** Information about worker pool actions. */
export interface BuildMetrics_WorkerPoolMetrics {
  /**
   * Statistics of worker pool per worker pool hash. Basically it's a map from
   * worker pool hash to statistics.
   */
  workerPoolStats: BuildMetrics_WorkerPoolMetrics_WorkerPoolStats[];
}

export interface BuildMetrics_WorkerPoolMetrics_WorkerPoolStats {
  /**
   * Hash of worker pool these stats are for. Contains information about
   * startup flags.
   */
  hash: number;
  /** Mnemonic of workers these stats are for. */
  mnemonic: string;
  /** Number of workers created during a build. */
  createdCount: string;
  /**
   * Number of workers destroyed during a build (sum of all workers
   * destroyed by eviction, UserExecException, IoException,
   * InterruptedException and unknown reasons below).
   */
  destroyedCount: string;
  /** Number of workers evicted during a build. */
  evictedCount: string;
  /** Number of workers destroyed due to UserExecExceptions. */
  userExecExceptionDestroyedCount: string;
  /** Number of workers destroyed due to IoExceptions. */
  ioExceptionDestroyedCount: string;
  /** Number of workers destroyed due to InterruptedExceptions. */
  interruptedExceptionDestroyedCount: string;
  /** Number of workers destroyed due to an unknown reason. */
  unknownDestroyedCount: string;
  /** Number of workers alive at the end of the build. */
  aliveCount: string;
}

/** Information about dynamic execution. */
export interface BuildMetrics_DynamicExecutionMetrics {
  /** Race statistics grouped by mnemonic, local_name, remote_name. */
  raceStatistics: BuildMetrics_DynamicExecutionMetrics_RaceStatistics[];
}

export interface BuildMetrics_DynamicExecutionMetrics_RaceStatistics {
  /** Mnemonic of the action. */
  mnemonic: string;
  /** Name of runner of local branch. */
  localRunner: string;
  /** Name of runner of remote branch. */
  remoteRunner: string;
  /** Number of wins of local branch in race. */
  localWins: number;
  /** Number of wins of remote branch in race. */
  remoteWins: number;
}

/** Statistics about remote analysis caching */
export interface BuildMetrics_RemoteAnalysisCacheStatistics {
  cacheHits: string;
  cacheMisses: string;
  valueStoreValueBytesReceived: string;
  valueStoreValueBytesSent: string;
  valueStoreKeyBytesSent: string;
  valueStoreWriteOps: string;
  valueStoreReadOpsSuccessful: string;
  valueStoreReadOpsNotFound: string;
  valueStoreReadBatches: string;
  valueStoreWriteBatches: string;
  analysisCacheBytesReceived: string;
  analysisCacheKeyBytesSent: string;
  analysisCacheOps: string;
  analysisCacheBatches: string;
}

/** Event providing additional statistics/logs after completion of the build. */
export interface BuildToolLogs {
  log: File[];
}

/**
 * Event describing all convenience symlinks (i.e., workspace symlinks) to be
 * created or deleted once the execution phase has begun. Note that this event
 * does not say anything about whether or not the build tool actually executed
 * these filesystem operations; it only says what logical operations should be
 * performed. This event is emitted exactly once per build; if no symlinks are
 * to be modified, the event is still emitted with empty contents.
 */
export interface ConvenienceSymlinksIdentified {
  convenienceSymlinks: ConvenienceSymlink[];
}

/**
 * The message that contains what type of action to perform on a given path and
 * target of a symlink.
 */
export interface ConvenienceSymlink {
  /**
   * The path of the symlink to be created or deleted, absolute or relative to
   * the workspace, creating any directories necessary. If a symlink already
   * exists at that location, then it should be replaced by a symlink pointing
   * to the new target.
   */
  path: string;
  /** The operation we are performing on the symlink. */
  action: ConvenienceSymlink_Action;
  /**
   * If action is CREATE, this is the target path (relative to the output base)
   * that the symlink should point to.
   *
   * If action is DELETE, this field is not set.
   */
  target: string;
}

export enum ConvenienceSymlink_Action {
  UNKNOWN = 0,
  /**
   * CREATE - Indicates a symlink should be created, or overwritten if it already
   * exists.
   */
  CREATE = 1,
  /** DELETE - Indicates a symlink should be deleted if it already exists. */
  DELETE = 2,
  UNRECOGNIZED = -1,
}

export function convenienceSymlink_ActionFromJSON(object: any): ConvenienceSymlink_Action {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return ConvenienceSymlink_Action.UNKNOWN;
    case 1:
    case "CREATE":
      return ConvenienceSymlink_Action.CREATE;
    case 2:
    case "DELETE":
      return ConvenienceSymlink_Action.DELETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConvenienceSymlink_Action.UNRECOGNIZED;
  }
}

export function convenienceSymlink_ActionToJSON(object: ConvenienceSymlink_Action): string {
  switch (object) {
    case ConvenienceSymlink_Action.UNKNOWN:
      return "UNKNOWN";
    case ConvenienceSymlink_Action.CREATE:
      return "CREATE";
    case ConvenienceSymlink_Action.DELETE:
      return "DELETE";
    case ConvenienceSymlink_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Event that contains the ExecRequest of a run command announced only after a
 * successful build and before trying to execute the requested command-line.
 */
export interface ExecRequestConstructed {
  workingDirectory: Uint8Array;
  argv: Uint8Array[];
  environmentVariable: EnvironmentVariable[];
  environmentVariableToClear: Uint8Array[];
  shouldExec: boolean;
}

/** An environment variable provided by a run command after a successful build. */
export interface EnvironmentVariable {
  name: Uint8Array;
  value: Uint8Array;
}

/**
 * Message describing a build event. Events will have an identifier that
 * is unique within a given build invocation; they also announce follow-up
 * events as children. More details, which are specific to the kind of event
 * that is observed, is provided in the payload. More options for the payload
 * might be added in the future.
 */
export interface BuildEvent {
  id: BuildEventId | undefined;
  children: BuildEventId[];
  lastMessage: boolean;
  progress?: Progress | undefined;
  aborted?: Aborted | undefined;
  started?: BuildStarted | undefined;
  unstructuredCommandLine?: UnstructuredCommandLine | undefined;
  structuredCommandLine?: CommandLine | undefined;
  optionsParsed?: OptionsParsed | undefined;
  workspaceStatus?: WorkspaceStatus | undefined;
  fetch?: Fetch | undefined;
  configuration?: Configuration | undefined;
  expanded?: PatternExpanded | undefined;
  configured?: TargetConfigured | undefined;
  action?: ActionExecuted | undefined;
  namedSetOfFiles?: NamedSetOfFiles | undefined;
  completed?: TargetComplete | undefined;
  testResult?: TestResult | undefined;
  testProgress?: TestProgress | undefined;
  testSummary?: TestSummary | undefined;
  targetSummary?: TargetSummary | undefined;
  finished?: BuildFinished | undefined;
  buildToolLogs?: BuildToolLogs | undefined;
  buildMetrics?: BuildMetrics | undefined;
  workspaceInfo?: WorkspaceConfig | undefined;
  buildMetadata?: BuildMetadata | undefined;
  convenienceSymlinksIdentified?: ConvenienceSymlinksIdentified | undefined;
  execRequest?: ExecRequestConstructed | undefined;
}

function createBaseBuildEventId(): BuildEventId {
  return {
    unknown: undefined,
    progress: undefined,
    started: undefined,
    unstructuredCommandLine: undefined,
    structuredCommandLine: undefined,
    workspaceStatus: undefined,
    optionsParsed: undefined,
    fetch: undefined,
    configuration: undefined,
    targetConfigured: undefined,
    pattern: undefined,
    patternSkipped: undefined,
    namedSet: undefined,
    targetCompleted: undefined,
    actionCompleted: undefined,
    unconfiguredLabel: undefined,
    configuredLabel: undefined,
    testResult: undefined,
    testProgress: undefined,
    testSummary: undefined,
    targetSummary: undefined,
    buildFinished: undefined,
    buildToolLogs: undefined,
    buildMetrics: undefined,
    workspace: undefined,
    buildMetadata: undefined,
    convenienceSymlinksIdentified: undefined,
    execRequest: undefined,
  };
}

export const BuildEventId: MessageFns<BuildEventId> = {
  encode(message: BuildEventId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unknown !== undefined) {
      BuildEventId_UnknownBuildEventId.encode(message.unknown, writer.uint32(10).fork()).join();
    }
    if (message.progress !== undefined) {
      BuildEventId_ProgressId.encode(message.progress, writer.uint32(18).fork()).join();
    }
    if (message.started !== undefined) {
      BuildEventId_BuildStartedId.encode(message.started, writer.uint32(26).fork()).join();
    }
    if (message.unstructuredCommandLine !== undefined) {
      BuildEventId_UnstructuredCommandLineId.encode(message.unstructuredCommandLine, writer.uint32(90).fork()).join();
    }
    if (message.structuredCommandLine !== undefined) {
      BuildEventId_StructuredCommandLineId.encode(message.structuredCommandLine, writer.uint32(146).fork()).join();
    }
    if (message.workspaceStatus !== undefined) {
      BuildEventId_WorkspaceStatusId.encode(message.workspaceStatus, writer.uint32(114).fork()).join();
    }
    if (message.optionsParsed !== undefined) {
      BuildEventId_OptionsParsedId.encode(message.optionsParsed, writer.uint32(98).fork()).join();
    }
    if (message.fetch !== undefined) {
      BuildEventId_FetchId.encode(message.fetch, writer.uint32(138).fork()).join();
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(122).fork()).join();
    }
    if (message.targetConfigured !== undefined) {
      BuildEventId_TargetConfiguredId.encode(message.targetConfigured, writer.uint32(130).fork()).join();
    }
    if (message.pattern !== undefined) {
      BuildEventId_PatternExpandedId.encode(message.pattern, writer.uint32(34).fork()).join();
    }
    if (message.patternSkipped !== undefined) {
      BuildEventId_PatternExpandedId.encode(message.patternSkipped, writer.uint32(82).fork()).join();
    }
    if (message.namedSet !== undefined) {
      BuildEventId_NamedSetOfFilesId.encode(message.namedSet, writer.uint32(106).fork()).join();
    }
    if (message.targetCompleted !== undefined) {
      BuildEventId_TargetCompletedId.encode(message.targetCompleted, writer.uint32(42).fork()).join();
    }
    if (message.actionCompleted !== undefined) {
      BuildEventId_ActionCompletedId.encode(message.actionCompleted, writer.uint32(50).fork()).join();
    }
    if (message.unconfiguredLabel !== undefined) {
      BuildEventId_UnconfiguredLabelId.encode(message.unconfiguredLabel, writer.uint32(154).fork()).join();
    }
    if (message.configuredLabel !== undefined) {
      BuildEventId_ConfiguredLabelId.encode(message.configuredLabel, writer.uint32(170).fork()).join();
    }
    if (message.testResult !== undefined) {
      BuildEventId_TestResultId.encode(message.testResult, writer.uint32(66).fork()).join();
    }
    if (message.testProgress !== undefined) {
      BuildEventId_TestProgressId.encode(message.testProgress, writer.uint32(234).fork()).join();
    }
    if (message.testSummary !== undefined) {
      BuildEventId_TestSummaryId.encode(message.testSummary, writer.uint32(58).fork()).join();
    }
    if (message.targetSummary !== undefined) {
      BuildEventId_TargetSummaryId.encode(message.targetSummary, writer.uint32(210).fork()).join();
    }
    if (message.buildFinished !== undefined) {
      BuildEventId_BuildFinishedId.encode(message.buildFinished, writer.uint32(74).fork()).join();
    }
    if (message.buildToolLogs !== undefined) {
      BuildEventId_BuildToolLogsId.encode(message.buildToolLogs, writer.uint32(162).fork()).join();
    }
    if (message.buildMetrics !== undefined) {
      BuildEventId_BuildMetricsId.encode(message.buildMetrics, writer.uint32(178).fork()).join();
    }
    if (message.workspace !== undefined) {
      BuildEventId_WorkspaceConfigId.encode(message.workspace, writer.uint32(186).fork()).join();
    }
    if (message.buildMetadata !== undefined) {
      BuildEventId_BuildMetadataId.encode(message.buildMetadata, writer.uint32(194).fork()).join();
    }
    if (message.convenienceSymlinksIdentified !== undefined) {
      BuildEventId_ConvenienceSymlinksIdentifiedId.encode(
        message.convenienceSymlinksIdentified,
        writer.uint32(202).fork(),
      ).join();
    }
    if (message.execRequest !== undefined) {
      BuildEventId_ExecRequestId.encode(message.execRequest, writer.uint32(226).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unknown = BuildEventId_UnknownBuildEventId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.progress = BuildEventId_ProgressId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.started = BuildEventId_BuildStartedId.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.unstructuredCommandLine = BuildEventId_UnstructuredCommandLineId.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.structuredCommandLine = BuildEventId_StructuredCommandLineId.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.workspaceStatus = BuildEventId_WorkspaceStatusId.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.optionsParsed = BuildEventId_OptionsParsedId.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.fetch = BuildEventId_FetchId.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.targetConfigured = BuildEventId_TargetConfiguredId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pattern = BuildEventId_PatternExpandedId.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.patternSkipped = BuildEventId_PatternExpandedId.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.namedSet = BuildEventId_NamedSetOfFilesId.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targetCompleted = BuildEventId_TargetCompletedId.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.actionCompleted = BuildEventId_ActionCompletedId.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.unconfiguredLabel = BuildEventId_UnconfiguredLabelId.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.configuredLabel = BuildEventId_ConfiguredLabelId.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.testResult = BuildEventId_TestResultId.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.testProgress = BuildEventId_TestProgressId.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.testSummary = BuildEventId_TestSummaryId.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.targetSummary = BuildEventId_TargetSummaryId.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.buildFinished = BuildEventId_BuildFinishedId.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.buildToolLogs = BuildEventId_BuildToolLogsId.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.buildMetrics = BuildEventId_BuildMetricsId.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.workspace = BuildEventId_WorkspaceConfigId.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.buildMetadata = BuildEventId_BuildMetadataId.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.convenienceSymlinksIdentified = BuildEventId_ConvenienceSymlinksIdentifiedId.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.execRequest = BuildEventId_ExecRequestId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId {
    return {
      unknown: isSet(object.unknown) ? BuildEventId_UnknownBuildEventId.fromJSON(object.unknown) : undefined,
      progress: isSet(object.progress) ? BuildEventId_ProgressId.fromJSON(object.progress) : undefined,
      started: isSet(object.started) ? BuildEventId_BuildStartedId.fromJSON(object.started) : undefined,
      unstructuredCommandLine: isSet(object.unstructuredCommandLine)
        ? BuildEventId_UnstructuredCommandLineId.fromJSON(object.unstructuredCommandLine)
        : undefined,
      structuredCommandLine: isSet(object.structuredCommandLine)
        ? BuildEventId_StructuredCommandLineId.fromJSON(object.structuredCommandLine)
        : undefined,
      workspaceStatus: isSet(object.workspaceStatus)
        ? BuildEventId_WorkspaceStatusId.fromJSON(object.workspaceStatus)
        : undefined,
      optionsParsed: isSet(object.optionsParsed)
        ? BuildEventId_OptionsParsedId.fromJSON(object.optionsParsed)
        : undefined,
      fetch: isSet(object.fetch) ? BuildEventId_FetchId.fromJSON(object.fetch) : undefined,
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
      targetConfigured: isSet(object.targetConfigured)
        ? BuildEventId_TargetConfiguredId.fromJSON(object.targetConfigured)
        : undefined,
      pattern: isSet(object.pattern) ? BuildEventId_PatternExpandedId.fromJSON(object.pattern) : undefined,
      patternSkipped: isSet(object.patternSkipped)
        ? BuildEventId_PatternExpandedId.fromJSON(object.patternSkipped)
        : undefined,
      namedSet: isSet(object.namedSet) ? BuildEventId_NamedSetOfFilesId.fromJSON(object.namedSet) : undefined,
      targetCompleted: isSet(object.targetCompleted)
        ? BuildEventId_TargetCompletedId.fromJSON(object.targetCompleted)
        : undefined,
      actionCompleted: isSet(object.actionCompleted)
        ? BuildEventId_ActionCompletedId.fromJSON(object.actionCompleted)
        : undefined,
      unconfiguredLabel: isSet(object.unconfiguredLabel)
        ? BuildEventId_UnconfiguredLabelId.fromJSON(object.unconfiguredLabel)
        : undefined,
      configuredLabel: isSet(object.configuredLabel)
        ? BuildEventId_ConfiguredLabelId.fromJSON(object.configuredLabel)
        : undefined,
      testResult: isSet(object.testResult) ? BuildEventId_TestResultId.fromJSON(object.testResult) : undefined,
      testProgress: isSet(object.testProgress) ? BuildEventId_TestProgressId.fromJSON(object.testProgress) : undefined,
      testSummary: isSet(object.testSummary) ? BuildEventId_TestSummaryId.fromJSON(object.testSummary) : undefined,
      targetSummary: isSet(object.targetSummary)
        ? BuildEventId_TargetSummaryId.fromJSON(object.targetSummary)
        : undefined,
      buildFinished: isSet(object.buildFinished)
        ? BuildEventId_BuildFinishedId.fromJSON(object.buildFinished)
        : undefined,
      buildToolLogs: isSet(object.buildToolLogs)
        ? BuildEventId_BuildToolLogsId.fromJSON(object.buildToolLogs)
        : undefined,
      buildMetrics: isSet(object.buildMetrics) ? BuildEventId_BuildMetricsId.fromJSON(object.buildMetrics) : undefined,
      workspace: isSet(object.workspace) ? BuildEventId_WorkspaceConfigId.fromJSON(object.workspace) : undefined,
      buildMetadata: isSet(object.buildMetadata)
        ? BuildEventId_BuildMetadataId.fromJSON(object.buildMetadata)
        : undefined,
      convenienceSymlinksIdentified: isSet(object.convenienceSymlinksIdentified)
        ? BuildEventId_ConvenienceSymlinksIdentifiedId.fromJSON(object.convenienceSymlinksIdentified)
        : undefined,
      execRequest: isSet(object.execRequest) ? BuildEventId_ExecRequestId.fromJSON(object.execRequest) : undefined,
    };
  },

  toJSON(message: BuildEventId): unknown {
    const obj: any = {};
    if (message.unknown !== undefined) {
      obj.unknown = BuildEventId_UnknownBuildEventId.toJSON(message.unknown);
    }
    if (message.progress !== undefined) {
      obj.progress = BuildEventId_ProgressId.toJSON(message.progress);
    }
    if (message.started !== undefined) {
      obj.started = BuildEventId_BuildStartedId.toJSON(message.started);
    }
    if (message.unstructuredCommandLine !== undefined) {
      obj.unstructuredCommandLine = BuildEventId_UnstructuredCommandLineId.toJSON(message.unstructuredCommandLine);
    }
    if (message.structuredCommandLine !== undefined) {
      obj.structuredCommandLine = BuildEventId_StructuredCommandLineId.toJSON(message.structuredCommandLine);
    }
    if (message.workspaceStatus !== undefined) {
      obj.workspaceStatus = BuildEventId_WorkspaceStatusId.toJSON(message.workspaceStatus);
    }
    if (message.optionsParsed !== undefined) {
      obj.optionsParsed = BuildEventId_OptionsParsedId.toJSON(message.optionsParsed);
    }
    if (message.fetch !== undefined) {
      obj.fetch = BuildEventId_FetchId.toJSON(message.fetch);
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    if (message.targetConfigured !== undefined) {
      obj.targetConfigured = BuildEventId_TargetConfiguredId.toJSON(message.targetConfigured);
    }
    if (message.pattern !== undefined) {
      obj.pattern = BuildEventId_PatternExpandedId.toJSON(message.pattern);
    }
    if (message.patternSkipped !== undefined) {
      obj.patternSkipped = BuildEventId_PatternExpandedId.toJSON(message.patternSkipped);
    }
    if (message.namedSet !== undefined) {
      obj.namedSet = BuildEventId_NamedSetOfFilesId.toJSON(message.namedSet);
    }
    if (message.targetCompleted !== undefined) {
      obj.targetCompleted = BuildEventId_TargetCompletedId.toJSON(message.targetCompleted);
    }
    if (message.actionCompleted !== undefined) {
      obj.actionCompleted = BuildEventId_ActionCompletedId.toJSON(message.actionCompleted);
    }
    if (message.unconfiguredLabel !== undefined) {
      obj.unconfiguredLabel = BuildEventId_UnconfiguredLabelId.toJSON(message.unconfiguredLabel);
    }
    if (message.configuredLabel !== undefined) {
      obj.configuredLabel = BuildEventId_ConfiguredLabelId.toJSON(message.configuredLabel);
    }
    if (message.testResult !== undefined) {
      obj.testResult = BuildEventId_TestResultId.toJSON(message.testResult);
    }
    if (message.testProgress !== undefined) {
      obj.testProgress = BuildEventId_TestProgressId.toJSON(message.testProgress);
    }
    if (message.testSummary !== undefined) {
      obj.testSummary = BuildEventId_TestSummaryId.toJSON(message.testSummary);
    }
    if (message.targetSummary !== undefined) {
      obj.targetSummary = BuildEventId_TargetSummaryId.toJSON(message.targetSummary);
    }
    if (message.buildFinished !== undefined) {
      obj.buildFinished = BuildEventId_BuildFinishedId.toJSON(message.buildFinished);
    }
    if (message.buildToolLogs !== undefined) {
      obj.buildToolLogs = BuildEventId_BuildToolLogsId.toJSON(message.buildToolLogs);
    }
    if (message.buildMetrics !== undefined) {
      obj.buildMetrics = BuildEventId_BuildMetricsId.toJSON(message.buildMetrics);
    }
    if (message.workspace !== undefined) {
      obj.workspace = BuildEventId_WorkspaceConfigId.toJSON(message.workspace);
    }
    if (message.buildMetadata !== undefined) {
      obj.buildMetadata = BuildEventId_BuildMetadataId.toJSON(message.buildMetadata);
    }
    if (message.convenienceSymlinksIdentified !== undefined) {
      obj.convenienceSymlinksIdentified = BuildEventId_ConvenienceSymlinksIdentifiedId.toJSON(
        message.convenienceSymlinksIdentified,
      );
    }
    if (message.execRequest !== undefined) {
      obj.execRequest = BuildEventId_ExecRequestId.toJSON(message.execRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId>, I>>(base?: I): BuildEventId {
    return BuildEventId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId>, I>>(object: I): BuildEventId {
    const message = createBaseBuildEventId();
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? BuildEventId_UnknownBuildEventId.fromPartial(object.unknown)
      : undefined;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? BuildEventId_ProgressId.fromPartial(object.progress)
      : undefined;
    message.started = (object.started !== undefined && object.started !== null)
      ? BuildEventId_BuildStartedId.fromPartial(object.started)
      : undefined;
    message.unstructuredCommandLine =
      (object.unstructuredCommandLine !== undefined && object.unstructuredCommandLine !== null)
        ? BuildEventId_UnstructuredCommandLineId.fromPartial(object.unstructuredCommandLine)
        : undefined;
    message.structuredCommandLine =
      (object.structuredCommandLine !== undefined && object.structuredCommandLine !== null)
        ? BuildEventId_StructuredCommandLineId.fromPartial(object.structuredCommandLine)
        : undefined;
    message.workspaceStatus = (object.workspaceStatus !== undefined && object.workspaceStatus !== null)
      ? BuildEventId_WorkspaceStatusId.fromPartial(object.workspaceStatus)
      : undefined;
    message.optionsParsed = (object.optionsParsed !== undefined && object.optionsParsed !== null)
      ? BuildEventId_OptionsParsedId.fromPartial(object.optionsParsed)
      : undefined;
    message.fetch = (object.fetch !== undefined && object.fetch !== null)
      ? BuildEventId_FetchId.fromPartial(object.fetch)
      : undefined;
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    message.targetConfigured = (object.targetConfigured !== undefined && object.targetConfigured !== null)
      ? BuildEventId_TargetConfiguredId.fromPartial(object.targetConfigured)
      : undefined;
    message.pattern = (object.pattern !== undefined && object.pattern !== null)
      ? BuildEventId_PatternExpandedId.fromPartial(object.pattern)
      : undefined;
    message.patternSkipped = (object.patternSkipped !== undefined && object.patternSkipped !== null)
      ? BuildEventId_PatternExpandedId.fromPartial(object.patternSkipped)
      : undefined;
    message.namedSet = (object.namedSet !== undefined && object.namedSet !== null)
      ? BuildEventId_NamedSetOfFilesId.fromPartial(object.namedSet)
      : undefined;
    message.targetCompleted = (object.targetCompleted !== undefined && object.targetCompleted !== null)
      ? BuildEventId_TargetCompletedId.fromPartial(object.targetCompleted)
      : undefined;
    message.actionCompleted = (object.actionCompleted !== undefined && object.actionCompleted !== null)
      ? BuildEventId_ActionCompletedId.fromPartial(object.actionCompleted)
      : undefined;
    message.unconfiguredLabel = (object.unconfiguredLabel !== undefined && object.unconfiguredLabel !== null)
      ? BuildEventId_UnconfiguredLabelId.fromPartial(object.unconfiguredLabel)
      : undefined;
    message.configuredLabel = (object.configuredLabel !== undefined && object.configuredLabel !== null)
      ? BuildEventId_ConfiguredLabelId.fromPartial(object.configuredLabel)
      : undefined;
    message.testResult = (object.testResult !== undefined && object.testResult !== null)
      ? BuildEventId_TestResultId.fromPartial(object.testResult)
      : undefined;
    message.testProgress = (object.testProgress !== undefined && object.testProgress !== null)
      ? BuildEventId_TestProgressId.fromPartial(object.testProgress)
      : undefined;
    message.testSummary = (object.testSummary !== undefined && object.testSummary !== null)
      ? BuildEventId_TestSummaryId.fromPartial(object.testSummary)
      : undefined;
    message.targetSummary = (object.targetSummary !== undefined && object.targetSummary !== null)
      ? BuildEventId_TargetSummaryId.fromPartial(object.targetSummary)
      : undefined;
    message.buildFinished = (object.buildFinished !== undefined && object.buildFinished !== null)
      ? BuildEventId_BuildFinishedId.fromPartial(object.buildFinished)
      : undefined;
    message.buildToolLogs = (object.buildToolLogs !== undefined && object.buildToolLogs !== null)
      ? BuildEventId_BuildToolLogsId.fromPartial(object.buildToolLogs)
      : undefined;
    message.buildMetrics = (object.buildMetrics !== undefined && object.buildMetrics !== null)
      ? BuildEventId_BuildMetricsId.fromPartial(object.buildMetrics)
      : undefined;
    message.workspace = (object.workspace !== undefined && object.workspace !== null)
      ? BuildEventId_WorkspaceConfigId.fromPartial(object.workspace)
      : undefined;
    message.buildMetadata = (object.buildMetadata !== undefined && object.buildMetadata !== null)
      ? BuildEventId_BuildMetadataId.fromPartial(object.buildMetadata)
      : undefined;
    message.convenienceSymlinksIdentified =
      (object.convenienceSymlinksIdentified !== undefined && object.convenienceSymlinksIdentified !== null)
        ? BuildEventId_ConvenienceSymlinksIdentifiedId.fromPartial(object.convenienceSymlinksIdentified)
        : undefined;
    message.execRequest = (object.execRequest !== undefined && object.execRequest !== null)
      ? BuildEventId_ExecRequestId.fromPartial(object.execRequest)
      : undefined;
    return message;
  },
};

function createBaseBuildEventId_UnknownBuildEventId(): BuildEventId_UnknownBuildEventId {
  return { details: "" };
}

export const BuildEventId_UnknownBuildEventId: MessageFns<BuildEventId_UnknownBuildEventId> = {
  encode(message: BuildEventId_UnknownBuildEventId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.details !== "") {
      writer.uint32(10).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_UnknownBuildEventId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_UnknownBuildEventId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_UnknownBuildEventId {
    return { details: isSet(object.details) ? globalThis.String(object.details) : "" };
  },

  toJSON(message: BuildEventId_UnknownBuildEventId): unknown {
    const obj: any = {};
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_UnknownBuildEventId>, I>>(
    base?: I,
  ): BuildEventId_UnknownBuildEventId {
    return BuildEventId_UnknownBuildEventId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_UnknownBuildEventId>, I>>(
    object: I,
  ): BuildEventId_UnknownBuildEventId {
    const message = createBaseBuildEventId_UnknownBuildEventId();
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseBuildEventId_ProgressId(): BuildEventId_ProgressId {
  return { opaqueCount: 0 };
}

export const BuildEventId_ProgressId: MessageFns<BuildEventId_ProgressId> = {
  encode(message: BuildEventId_ProgressId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.opaqueCount !== 0) {
      writer.uint32(8).int32(message.opaqueCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_ProgressId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_ProgressId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.opaqueCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_ProgressId {
    return { opaqueCount: isSet(object.opaqueCount) ? globalThis.Number(object.opaqueCount) : 0 };
  },

  toJSON(message: BuildEventId_ProgressId): unknown {
    const obj: any = {};
    if (message.opaqueCount !== 0) {
      obj.opaqueCount = Math.round(message.opaqueCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_ProgressId>, I>>(base?: I): BuildEventId_ProgressId {
    return BuildEventId_ProgressId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_ProgressId>, I>>(object: I): BuildEventId_ProgressId {
    const message = createBaseBuildEventId_ProgressId();
    message.opaqueCount = object.opaqueCount ?? 0;
    return message;
  },
};

function createBaseBuildEventId_BuildStartedId(): BuildEventId_BuildStartedId {
  return {};
}

export const BuildEventId_BuildStartedId: MessageFns<BuildEventId_BuildStartedId> = {
  encode(_: BuildEventId_BuildStartedId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_BuildStartedId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_BuildStartedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_BuildStartedId {
    return {};
  },

  toJSON(_: BuildEventId_BuildStartedId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_BuildStartedId>, I>>(base?: I): BuildEventId_BuildStartedId {
    return BuildEventId_BuildStartedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_BuildStartedId>, I>>(_: I): BuildEventId_BuildStartedId {
    const message = createBaseBuildEventId_BuildStartedId();
    return message;
  },
};

function createBaseBuildEventId_UnstructuredCommandLineId(): BuildEventId_UnstructuredCommandLineId {
  return {};
}

export const BuildEventId_UnstructuredCommandLineId: MessageFns<BuildEventId_UnstructuredCommandLineId> = {
  encode(_: BuildEventId_UnstructuredCommandLineId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_UnstructuredCommandLineId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_UnstructuredCommandLineId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_UnstructuredCommandLineId {
    return {};
  },

  toJSON(_: BuildEventId_UnstructuredCommandLineId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_UnstructuredCommandLineId>, I>>(
    base?: I,
  ): BuildEventId_UnstructuredCommandLineId {
    return BuildEventId_UnstructuredCommandLineId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_UnstructuredCommandLineId>, I>>(
    _: I,
  ): BuildEventId_UnstructuredCommandLineId {
    const message = createBaseBuildEventId_UnstructuredCommandLineId();
    return message;
  },
};

function createBaseBuildEventId_StructuredCommandLineId(): BuildEventId_StructuredCommandLineId {
  return { commandLineLabel: "" };
}

export const BuildEventId_StructuredCommandLineId: MessageFns<BuildEventId_StructuredCommandLineId> = {
  encode(message: BuildEventId_StructuredCommandLineId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandLineLabel !== "") {
      writer.uint32(10).string(message.commandLineLabel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_StructuredCommandLineId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_StructuredCommandLineId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandLineLabel = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_StructuredCommandLineId {
    return { commandLineLabel: isSet(object.commandLineLabel) ? globalThis.String(object.commandLineLabel) : "" };
  },

  toJSON(message: BuildEventId_StructuredCommandLineId): unknown {
    const obj: any = {};
    if (message.commandLineLabel !== "") {
      obj.commandLineLabel = message.commandLineLabel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_StructuredCommandLineId>, I>>(
    base?: I,
  ): BuildEventId_StructuredCommandLineId {
    return BuildEventId_StructuredCommandLineId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_StructuredCommandLineId>, I>>(
    object: I,
  ): BuildEventId_StructuredCommandLineId {
    const message = createBaseBuildEventId_StructuredCommandLineId();
    message.commandLineLabel = object.commandLineLabel ?? "";
    return message;
  },
};

function createBaseBuildEventId_WorkspaceStatusId(): BuildEventId_WorkspaceStatusId {
  return {};
}

export const BuildEventId_WorkspaceStatusId: MessageFns<BuildEventId_WorkspaceStatusId> = {
  encode(_: BuildEventId_WorkspaceStatusId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_WorkspaceStatusId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_WorkspaceStatusId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_WorkspaceStatusId {
    return {};
  },

  toJSON(_: BuildEventId_WorkspaceStatusId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_WorkspaceStatusId>, I>>(base?: I): BuildEventId_WorkspaceStatusId {
    return BuildEventId_WorkspaceStatusId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_WorkspaceStatusId>, I>>(_: I): BuildEventId_WorkspaceStatusId {
    const message = createBaseBuildEventId_WorkspaceStatusId();
    return message;
  },
};

function createBaseBuildEventId_OptionsParsedId(): BuildEventId_OptionsParsedId {
  return {};
}

export const BuildEventId_OptionsParsedId: MessageFns<BuildEventId_OptionsParsedId> = {
  encode(_: BuildEventId_OptionsParsedId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_OptionsParsedId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_OptionsParsedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_OptionsParsedId {
    return {};
  },

  toJSON(_: BuildEventId_OptionsParsedId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_OptionsParsedId>, I>>(base?: I): BuildEventId_OptionsParsedId {
    return BuildEventId_OptionsParsedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_OptionsParsedId>, I>>(_: I): BuildEventId_OptionsParsedId {
    const message = createBaseBuildEventId_OptionsParsedId();
    return message;
  },
};

function createBaseBuildEventId_FetchId(): BuildEventId_FetchId {
  return { url: "", downloader: 0 };
}

export const BuildEventId_FetchId: MessageFns<BuildEventId_FetchId> = {
  encode(message: BuildEventId_FetchId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.downloader !== 0) {
      writer.uint32(16).int32(message.downloader);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_FetchId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_FetchId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.downloader = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_FetchId {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      downloader: isSet(object.downloader) ? buildEventId_FetchId_DownloaderFromJSON(object.downloader) : 0,
    };
  },

  toJSON(message: BuildEventId_FetchId): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.downloader !== 0) {
      obj.downloader = buildEventId_FetchId_DownloaderToJSON(message.downloader);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_FetchId>, I>>(base?: I): BuildEventId_FetchId {
    return BuildEventId_FetchId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_FetchId>, I>>(object: I): BuildEventId_FetchId {
    const message = createBaseBuildEventId_FetchId();
    message.url = object.url ?? "";
    message.downloader = object.downloader ?? 0;
    return message;
  },
};

function createBaseBuildEventId_PatternExpandedId(): BuildEventId_PatternExpandedId {
  return { pattern: [] };
}

export const BuildEventId_PatternExpandedId: MessageFns<BuildEventId_PatternExpandedId> = {
  encode(message: BuildEventId_PatternExpandedId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pattern) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_PatternExpandedId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_PatternExpandedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pattern.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_PatternExpandedId {
    return {
      pattern: globalThis.Array.isArray(object?.pattern) ? object.pattern.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BuildEventId_PatternExpandedId): unknown {
    const obj: any = {};
    if (message.pattern?.length) {
      obj.pattern = message.pattern;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_PatternExpandedId>, I>>(base?: I): BuildEventId_PatternExpandedId {
    return BuildEventId_PatternExpandedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_PatternExpandedId>, I>>(
    object: I,
  ): BuildEventId_PatternExpandedId {
    const message = createBaseBuildEventId_PatternExpandedId();
    message.pattern = object.pattern?.map((e) => e) || [];
    return message;
  },
};

function createBaseBuildEventId_WorkspaceConfigId(): BuildEventId_WorkspaceConfigId {
  return {};
}

export const BuildEventId_WorkspaceConfigId: MessageFns<BuildEventId_WorkspaceConfigId> = {
  encode(_: BuildEventId_WorkspaceConfigId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_WorkspaceConfigId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_WorkspaceConfigId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_WorkspaceConfigId {
    return {};
  },

  toJSON(_: BuildEventId_WorkspaceConfigId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_WorkspaceConfigId>, I>>(base?: I): BuildEventId_WorkspaceConfigId {
    return BuildEventId_WorkspaceConfigId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_WorkspaceConfigId>, I>>(_: I): BuildEventId_WorkspaceConfigId {
    const message = createBaseBuildEventId_WorkspaceConfigId();
    return message;
  },
};

function createBaseBuildEventId_BuildMetadataId(): BuildEventId_BuildMetadataId {
  return {};
}

export const BuildEventId_BuildMetadataId: MessageFns<BuildEventId_BuildMetadataId> = {
  encode(_: BuildEventId_BuildMetadataId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_BuildMetadataId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_BuildMetadataId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_BuildMetadataId {
    return {};
  },

  toJSON(_: BuildEventId_BuildMetadataId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_BuildMetadataId>, I>>(base?: I): BuildEventId_BuildMetadataId {
    return BuildEventId_BuildMetadataId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_BuildMetadataId>, I>>(_: I): BuildEventId_BuildMetadataId {
    const message = createBaseBuildEventId_BuildMetadataId();
    return message;
  },
};

function createBaseBuildEventId_TargetConfiguredId(): BuildEventId_TargetConfiguredId {
  return { label: "", aspect: "" };
}

export const BuildEventId_TargetConfiguredId: MessageFns<BuildEventId_TargetConfiguredId> = {
  encode(message: BuildEventId_TargetConfiguredId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.aspect !== "") {
      writer.uint32(18).string(message.aspect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_TargetConfiguredId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_TargetConfiguredId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aspect = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_TargetConfiguredId {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      aspect: isSet(object.aspect) ? globalThis.String(object.aspect) : "",
    };
  },

  toJSON(message: BuildEventId_TargetConfiguredId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.aspect !== "") {
      obj.aspect = message.aspect;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_TargetConfiguredId>, I>>(base?: I): BuildEventId_TargetConfiguredId {
    return BuildEventId_TargetConfiguredId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_TargetConfiguredId>, I>>(
    object: I,
  ): BuildEventId_TargetConfiguredId {
    const message = createBaseBuildEventId_TargetConfiguredId();
    message.label = object.label ?? "";
    message.aspect = object.aspect ?? "";
    return message;
  },
};

function createBaseBuildEventId_NamedSetOfFilesId(): BuildEventId_NamedSetOfFilesId {
  return { id: "" };
}

export const BuildEventId_NamedSetOfFilesId: MessageFns<BuildEventId_NamedSetOfFilesId> = {
  encode(message: BuildEventId_NamedSetOfFilesId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_NamedSetOfFilesId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_NamedSetOfFilesId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_NamedSetOfFilesId {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: BuildEventId_NamedSetOfFilesId): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_NamedSetOfFilesId>, I>>(base?: I): BuildEventId_NamedSetOfFilesId {
    return BuildEventId_NamedSetOfFilesId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_NamedSetOfFilesId>, I>>(
    object: I,
  ): BuildEventId_NamedSetOfFilesId {
    const message = createBaseBuildEventId_NamedSetOfFilesId();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseBuildEventId_ConfigurationId(): BuildEventId_ConfigurationId {
  return { id: "" };
}

export const BuildEventId_ConfigurationId: MessageFns<BuildEventId_ConfigurationId> = {
  encode(message: BuildEventId_ConfigurationId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_ConfigurationId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_ConfigurationId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_ConfigurationId {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: BuildEventId_ConfigurationId): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_ConfigurationId>, I>>(base?: I): BuildEventId_ConfigurationId {
    return BuildEventId_ConfigurationId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_ConfigurationId>, I>>(object: I): BuildEventId_ConfigurationId {
    const message = createBaseBuildEventId_ConfigurationId();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseBuildEventId_TargetCompletedId(): BuildEventId_TargetCompletedId {
  return { label: "", configuration: undefined, aspect: "" };
}

export const BuildEventId_TargetCompletedId: MessageFns<BuildEventId_TargetCompletedId> = {
  encode(message: BuildEventId_TargetCompletedId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(26).fork()).join();
    }
    if (message.aspect !== "") {
      writer.uint32(18).string(message.aspect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_TargetCompletedId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_TargetCompletedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aspect = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_TargetCompletedId {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
      aspect: isSet(object.aspect) ? globalThis.String(object.aspect) : "",
    };
  },

  toJSON(message: BuildEventId_TargetCompletedId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    if (message.aspect !== "") {
      obj.aspect = message.aspect;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_TargetCompletedId>, I>>(base?: I): BuildEventId_TargetCompletedId {
    return BuildEventId_TargetCompletedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_TargetCompletedId>, I>>(
    object: I,
  ): BuildEventId_TargetCompletedId {
    const message = createBaseBuildEventId_TargetCompletedId();
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    message.aspect = object.aspect ?? "";
    return message;
  },
};

function createBaseBuildEventId_ActionCompletedId(): BuildEventId_ActionCompletedId {
  return { primaryOutput: "", label: "", configuration: undefined };
}

export const BuildEventId_ActionCompletedId: MessageFns<BuildEventId_ActionCompletedId> = {
  encode(message: BuildEventId_ActionCompletedId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryOutput !== "") {
      writer.uint32(10).string(message.primaryOutput);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_ActionCompletedId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_ActionCompletedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.primaryOutput = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_ActionCompletedId {
    return {
      primaryOutput: isSet(object.primaryOutput) ? globalThis.String(object.primaryOutput) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
    };
  },

  toJSON(message: BuildEventId_ActionCompletedId): unknown {
    const obj: any = {};
    if (message.primaryOutput !== "") {
      obj.primaryOutput = message.primaryOutput;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_ActionCompletedId>, I>>(base?: I): BuildEventId_ActionCompletedId {
    return BuildEventId_ActionCompletedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_ActionCompletedId>, I>>(
    object: I,
  ): BuildEventId_ActionCompletedId {
    const message = createBaseBuildEventId_ActionCompletedId();
    message.primaryOutput = object.primaryOutput ?? "";
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    return message;
  },
};

function createBaseBuildEventId_UnconfiguredLabelId(): BuildEventId_UnconfiguredLabelId {
  return { label: "" };
}

export const BuildEventId_UnconfiguredLabelId: MessageFns<BuildEventId_UnconfiguredLabelId> = {
  encode(message: BuildEventId_UnconfiguredLabelId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_UnconfiguredLabelId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_UnconfiguredLabelId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_UnconfiguredLabelId {
    return { label: isSet(object.label) ? globalThis.String(object.label) : "" };
  },

  toJSON(message: BuildEventId_UnconfiguredLabelId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_UnconfiguredLabelId>, I>>(
    base?: I,
  ): BuildEventId_UnconfiguredLabelId {
    return BuildEventId_UnconfiguredLabelId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_UnconfiguredLabelId>, I>>(
    object: I,
  ): BuildEventId_UnconfiguredLabelId {
    const message = createBaseBuildEventId_UnconfiguredLabelId();
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseBuildEventId_ConfiguredLabelId(): BuildEventId_ConfiguredLabelId {
  return { label: "", configuration: undefined };
}

export const BuildEventId_ConfiguredLabelId: MessageFns<BuildEventId_ConfiguredLabelId> = {
  encode(message: BuildEventId_ConfiguredLabelId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_ConfiguredLabelId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_ConfiguredLabelId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_ConfiguredLabelId {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
    };
  },

  toJSON(message: BuildEventId_ConfiguredLabelId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_ConfiguredLabelId>, I>>(base?: I): BuildEventId_ConfiguredLabelId {
    return BuildEventId_ConfiguredLabelId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_ConfiguredLabelId>, I>>(
    object: I,
  ): BuildEventId_ConfiguredLabelId {
    const message = createBaseBuildEventId_ConfiguredLabelId();
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    return message;
  },
};

function createBaseBuildEventId_TestResultId(): BuildEventId_TestResultId {
  return { label: "", configuration: undefined, run: 0, shard: 0, attempt: 0 };
}

export const BuildEventId_TestResultId: MessageFns<BuildEventId_TestResultId> = {
  encode(message: BuildEventId_TestResultId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(42).fork()).join();
    }
    if (message.run !== 0) {
      writer.uint32(16).int32(message.run);
    }
    if (message.shard !== 0) {
      writer.uint32(24).int32(message.shard);
    }
    if (message.attempt !== 0) {
      writer.uint32(32).int32(message.attempt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_TestResultId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_TestResultId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.run = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.shard = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attempt = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_TestResultId {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
      run: isSet(object.run) ? globalThis.Number(object.run) : 0,
      shard: isSet(object.shard) ? globalThis.Number(object.shard) : 0,
      attempt: isSet(object.attempt) ? globalThis.Number(object.attempt) : 0,
    };
  },

  toJSON(message: BuildEventId_TestResultId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    if (message.run !== 0) {
      obj.run = Math.round(message.run);
    }
    if (message.shard !== 0) {
      obj.shard = Math.round(message.shard);
    }
    if (message.attempt !== 0) {
      obj.attempt = Math.round(message.attempt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_TestResultId>, I>>(base?: I): BuildEventId_TestResultId {
    return BuildEventId_TestResultId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_TestResultId>, I>>(object: I): BuildEventId_TestResultId {
    const message = createBaseBuildEventId_TestResultId();
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    message.run = object.run ?? 0;
    message.shard = object.shard ?? 0;
    message.attempt = object.attempt ?? 0;
    return message;
  },
};

function createBaseBuildEventId_TestProgressId(): BuildEventId_TestProgressId {
  return { label: "", configuration: undefined, run: 0, shard: 0, attempt: 0, opaqueCount: 0 };
}

export const BuildEventId_TestProgressId: MessageFns<BuildEventId_TestProgressId> = {
  encode(message: BuildEventId_TestProgressId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(18).fork()).join();
    }
    if (message.run !== 0) {
      writer.uint32(24).int32(message.run);
    }
    if (message.shard !== 0) {
      writer.uint32(32).int32(message.shard);
    }
    if (message.attempt !== 0) {
      writer.uint32(40).int32(message.attempt);
    }
    if (message.opaqueCount !== 0) {
      writer.uint32(48).int32(message.opaqueCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_TestProgressId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_TestProgressId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.run = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.shard = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.attempt = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.opaqueCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_TestProgressId {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
      run: isSet(object.run) ? globalThis.Number(object.run) : 0,
      shard: isSet(object.shard) ? globalThis.Number(object.shard) : 0,
      attempt: isSet(object.attempt) ? globalThis.Number(object.attempt) : 0,
      opaqueCount: isSet(object.opaqueCount) ? globalThis.Number(object.opaqueCount) : 0,
    };
  },

  toJSON(message: BuildEventId_TestProgressId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    if (message.run !== 0) {
      obj.run = Math.round(message.run);
    }
    if (message.shard !== 0) {
      obj.shard = Math.round(message.shard);
    }
    if (message.attempt !== 0) {
      obj.attempt = Math.round(message.attempt);
    }
    if (message.opaqueCount !== 0) {
      obj.opaqueCount = Math.round(message.opaqueCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_TestProgressId>, I>>(base?: I): BuildEventId_TestProgressId {
    return BuildEventId_TestProgressId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_TestProgressId>, I>>(object: I): BuildEventId_TestProgressId {
    const message = createBaseBuildEventId_TestProgressId();
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    message.run = object.run ?? 0;
    message.shard = object.shard ?? 0;
    message.attempt = object.attempt ?? 0;
    message.opaqueCount = object.opaqueCount ?? 0;
    return message;
  },
};

function createBaseBuildEventId_TestSummaryId(): BuildEventId_TestSummaryId {
  return { label: "", configuration: undefined };
}

export const BuildEventId_TestSummaryId: MessageFns<BuildEventId_TestSummaryId> = {
  encode(message: BuildEventId_TestSummaryId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_TestSummaryId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_TestSummaryId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_TestSummaryId {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
    };
  },

  toJSON(message: BuildEventId_TestSummaryId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_TestSummaryId>, I>>(base?: I): BuildEventId_TestSummaryId {
    return BuildEventId_TestSummaryId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_TestSummaryId>, I>>(object: I): BuildEventId_TestSummaryId {
    const message = createBaseBuildEventId_TestSummaryId();
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    return message;
  },
};

function createBaseBuildEventId_TargetSummaryId(): BuildEventId_TargetSummaryId {
  return { label: "", configuration: undefined };
}

export const BuildEventId_TargetSummaryId: MessageFns<BuildEventId_TargetSummaryId> = {
  encode(message: BuildEventId_TargetSummaryId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_TargetSummaryId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_TargetSummaryId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEventId_TargetSummaryId {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
    };
  },

  toJSON(message: BuildEventId_TargetSummaryId): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_TargetSummaryId>, I>>(base?: I): BuildEventId_TargetSummaryId {
    return BuildEventId_TargetSummaryId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_TargetSummaryId>, I>>(object: I): BuildEventId_TargetSummaryId {
    const message = createBaseBuildEventId_TargetSummaryId();
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    return message;
  },
};

function createBaseBuildEventId_BuildFinishedId(): BuildEventId_BuildFinishedId {
  return {};
}

export const BuildEventId_BuildFinishedId: MessageFns<BuildEventId_BuildFinishedId> = {
  encode(_: BuildEventId_BuildFinishedId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_BuildFinishedId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_BuildFinishedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_BuildFinishedId {
    return {};
  },

  toJSON(_: BuildEventId_BuildFinishedId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_BuildFinishedId>, I>>(base?: I): BuildEventId_BuildFinishedId {
    return BuildEventId_BuildFinishedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_BuildFinishedId>, I>>(_: I): BuildEventId_BuildFinishedId {
    const message = createBaseBuildEventId_BuildFinishedId();
    return message;
  },
};

function createBaseBuildEventId_BuildToolLogsId(): BuildEventId_BuildToolLogsId {
  return {};
}

export const BuildEventId_BuildToolLogsId: MessageFns<BuildEventId_BuildToolLogsId> = {
  encode(_: BuildEventId_BuildToolLogsId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_BuildToolLogsId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_BuildToolLogsId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_BuildToolLogsId {
    return {};
  },

  toJSON(_: BuildEventId_BuildToolLogsId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_BuildToolLogsId>, I>>(base?: I): BuildEventId_BuildToolLogsId {
    return BuildEventId_BuildToolLogsId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_BuildToolLogsId>, I>>(_: I): BuildEventId_BuildToolLogsId {
    const message = createBaseBuildEventId_BuildToolLogsId();
    return message;
  },
};

function createBaseBuildEventId_BuildMetricsId(): BuildEventId_BuildMetricsId {
  return {};
}

export const BuildEventId_BuildMetricsId: MessageFns<BuildEventId_BuildMetricsId> = {
  encode(_: BuildEventId_BuildMetricsId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_BuildMetricsId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_BuildMetricsId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_BuildMetricsId {
    return {};
  },

  toJSON(_: BuildEventId_BuildMetricsId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_BuildMetricsId>, I>>(base?: I): BuildEventId_BuildMetricsId {
    return BuildEventId_BuildMetricsId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_BuildMetricsId>, I>>(_: I): BuildEventId_BuildMetricsId {
    const message = createBaseBuildEventId_BuildMetricsId();
    return message;
  },
};

function createBaseBuildEventId_ConvenienceSymlinksIdentifiedId(): BuildEventId_ConvenienceSymlinksIdentifiedId {
  return {};
}

export const BuildEventId_ConvenienceSymlinksIdentifiedId: MessageFns<BuildEventId_ConvenienceSymlinksIdentifiedId> = {
  encode(_: BuildEventId_ConvenienceSymlinksIdentifiedId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_ConvenienceSymlinksIdentifiedId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_ConvenienceSymlinksIdentifiedId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_ConvenienceSymlinksIdentifiedId {
    return {};
  },

  toJSON(_: BuildEventId_ConvenienceSymlinksIdentifiedId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_ConvenienceSymlinksIdentifiedId>, I>>(
    base?: I,
  ): BuildEventId_ConvenienceSymlinksIdentifiedId {
    return BuildEventId_ConvenienceSymlinksIdentifiedId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_ConvenienceSymlinksIdentifiedId>, I>>(
    _: I,
  ): BuildEventId_ConvenienceSymlinksIdentifiedId {
    const message = createBaseBuildEventId_ConvenienceSymlinksIdentifiedId();
    return message;
  },
};

function createBaseBuildEventId_ExecRequestId(): BuildEventId_ExecRequestId {
  return {};
}

export const BuildEventId_ExecRequestId: MessageFns<BuildEventId_ExecRequestId> = {
  encode(_: BuildEventId_ExecRequestId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEventId_ExecRequestId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEventId_ExecRequestId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BuildEventId_ExecRequestId {
    return {};
  },

  toJSON(_: BuildEventId_ExecRequestId): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEventId_ExecRequestId>, I>>(base?: I): BuildEventId_ExecRequestId {
    return BuildEventId_ExecRequestId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEventId_ExecRequestId>, I>>(_: I): BuildEventId_ExecRequestId {
    const message = createBaseBuildEventId_ExecRequestId();
    return message;
  },
};

function createBaseProgress(): Progress {
  return { stdout: "", stderr: "" };
}

export const Progress: MessageFns<Progress> = {
  encode(message: Progress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stdout !== "") {
      writer.uint32(10).string(message.stdout);
    }
    if (message.stderr !== "") {
      writer.uint32(18).string(message.stderr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Progress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stdout = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stderr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Progress {
    return {
      stdout: isSet(object.stdout) ? globalThis.String(object.stdout) : "",
      stderr: isSet(object.stderr) ? globalThis.String(object.stderr) : "",
    };
  },

  toJSON(message: Progress): unknown {
    const obj: any = {};
    if (message.stdout !== "") {
      obj.stdout = message.stdout;
    }
    if (message.stderr !== "") {
      obj.stderr = message.stderr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Progress>, I>>(base?: I): Progress {
    return Progress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Progress>, I>>(object: I): Progress {
    const message = createBaseProgress();
    message.stdout = object.stdout ?? "";
    message.stderr = object.stderr ?? "";
    return message;
  },
};

function createBaseAborted(): Aborted {
  return { reason: 0, description: "" };
}

export const Aborted: MessageFns<Aborted> = {
  encode(message: Aborted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Aborted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAborted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Aborted {
    return {
      reason: isSet(object.reason) ? aborted_AbortReasonFromJSON(object.reason) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Aborted): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = aborted_AbortReasonToJSON(message.reason);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Aborted>, I>>(base?: I): Aborted {
    return Aborted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Aborted>, I>>(object: I): Aborted {
    const message = createBaseAborted();
    message.reason = object.reason ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseBuildStarted(): BuildStarted {
  return {
    uuid: "",
    startTimeMillis: "0",
    startTime: undefined,
    buildToolVersion: "",
    optionsDescription: "",
    command: "",
    workingDirectory: "",
    workspaceDirectory: "",
    serverPid: "0",
  };
}

export const BuildStarted: MessageFns<BuildStarted> = {
  encode(message: BuildStarted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.startTimeMillis !== "0") {
      writer.uint32(16).int64(message.startTimeMillis);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(74).fork()).join();
    }
    if (message.buildToolVersion !== "") {
      writer.uint32(26).string(message.buildToolVersion);
    }
    if (message.optionsDescription !== "") {
      writer.uint32(34).string(message.optionsDescription);
    }
    if (message.command !== "") {
      writer.uint32(42).string(message.command);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(50).string(message.workingDirectory);
    }
    if (message.workspaceDirectory !== "") {
      writer.uint32(58).string(message.workspaceDirectory);
    }
    if (message.serverPid !== "0") {
      writer.uint32(64).int64(message.serverPid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildStarted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startTimeMillis = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buildToolVersion = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.optionsDescription = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.workspaceDirectory = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.serverPid = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildStarted {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      startTimeMillis: isSet(object.startTimeMillis) ? globalThis.String(object.startTimeMillis) : "0",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      buildToolVersion: isSet(object.buildToolVersion) ? globalThis.String(object.buildToolVersion) : "",
      optionsDescription: isSet(object.optionsDescription) ? globalThis.String(object.optionsDescription) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      workingDirectory: isSet(object.workingDirectory) ? globalThis.String(object.workingDirectory) : "",
      workspaceDirectory: isSet(object.workspaceDirectory) ? globalThis.String(object.workspaceDirectory) : "",
      serverPid: isSet(object.serverPid) ? globalThis.String(object.serverPid) : "0",
    };
  },

  toJSON(message: BuildStarted): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.startTimeMillis !== "0") {
      obj.startTimeMillis = message.startTimeMillis;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.buildToolVersion !== "") {
      obj.buildToolVersion = message.buildToolVersion;
    }
    if (message.optionsDescription !== "") {
      obj.optionsDescription = message.optionsDescription;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    if (message.workspaceDirectory !== "") {
      obj.workspaceDirectory = message.workspaceDirectory;
    }
    if (message.serverPid !== "0") {
      obj.serverPid = message.serverPid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildStarted>, I>>(base?: I): BuildStarted {
    return BuildStarted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildStarted>, I>>(object: I): BuildStarted {
    const message = createBaseBuildStarted();
    message.uuid = object.uuid ?? "";
    message.startTimeMillis = object.startTimeMillis ?? "0";
    message.startTime = object.startTime ?? undefined;
    message.buildToolVersion = object.buildToolVersion ?? "";
    message.optionsDescription = object.optionsDescription ?? "";
    message.command = object.command ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    message.workspaceDirectory = object.workspaceDirectory ?? "";
    message.serverPid = object.serverPid ?? "0";
    return message;
  },
};

function createBaseWorkspaceConfig(): WorkspaceConfig {
  return { localExecRoot: "" };
}

export const WorkspaceConfig: MessageFns<WorkspaceConfig> = {
  encode(message: WorkspaceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localExecRoot !== "") {
      writer.uint32(10).string(message.localExecRoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.localExecRoot = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkspaceConfig {
    return { localExecRoot: isSet(object.localExecRoot) ? globalThis.String(object.localExecRoot) : "" };
  },

  toJSON(message: WorkspaceConfig): unknown {
    const obj: any = {};
    if (message.localExecRoot !== "") {
      obj.localExecRoot = message.localExecRoot;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceConfig>, I>>(base?: I): WorkspaceConfig {
    return WorkspaceConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceConfig>, I>>(object: I): WorkspaceConfig {
    const message = createBaseWorkspaceConfig();
    message.localExecRoot = object.localExecRoot ?? "";
    return message;
  },
};

function createBaseUnstructuredCommandLine(): UnstructuredCommandLine {
  return { args: [] };
}

export const UnstructuredCommandLine: MessageFns<UnstructuredCommandLine> = {
  encode(message: UnstructuredCommandLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.args) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnstructuredCommandLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnstructuredCommandLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnstructuredCommandLine {
    return { args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: UnstructuredCommandLine): unknown {
    const obj: any = {};
    if (message.args?.length) {
      obj.args = message.args;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnstructuredCommandLine>, I>>(base?: I): UnstructuredCommandLine {
    return UnstructuredCommandLine.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnstructuredCommandLine>, I>>(object: I): UnstructuredCommandLine {
    const message = createBaseUnstructuredCommandLine();
    message.args = object.args?.map((e) => e) || [];
    return message;
  },
};

function createBaseOptionsParsed(): OptionsParsed {
  return {
    startupOptions: [],
    explicitStartupOptions: [],
    cmdLine: [],
    explicitCmdLine: [],
    invocationPolicy: undefined,
    toolTag: "",
  };
}

export const OptionsParsed: MessageFns<OptionsParsed> = {
  encode(message: OptionsParsed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.startupOptions) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.explicitStartupOptions) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.cmdLine) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.explicitCmdLine) {
      writer.uint32(34).string(v!);
    }
    if (message.invocationPolicy !== undefined) {
      InvocationPolicy.encode(message.invocationPolicy, writer.uint32(42).fork()).join();
    }
    if (message.toolTag !== "") {
      writer.uint32(50).string(message.toolTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OptionsParsed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOptionsParsed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startupOptions.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.explicitStartupOptions.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cmdLine.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.explicitCmdLine.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.invocationPolicy = InvocationPolicy.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toolTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OptionsParsed {
    return {
      startupOptions: globalThis.Array.isArray(object?.startupOptions)
        ? object.startupOptions.map((e: any) => globalThis.String(e))
        : [],
      explicitStartupOptions: globalThis.Array.isArray(object?.explicitStartupOptions)
        ? object.explicitStartupOptions.map((e: any) => globalThis.String(e))
        : [],
      cmdLine: globalThis.Array.isArray(object?.cmdLine) ? object.cmdLine.map((e: any) => globalThis.String(e)) : [],
      explicitCmdLine: globalThis.Array.isArray(object?.explicitCmdLine)
        ? object.explicitCmdLine.map((e: any) => globalThis.String(e))
        : [],
      invocationPolicy: isSet(object.invocationPolicy) ? InvocationPolicy.fromJSON(object.invocationPolicy) : undefined,
      toolTag: isSet(object.toolTag) ? globalThis.String(object.toolTag) : "",
    };
  },

  toJSON(message: OptionsParsed): unknown {
    const obj: any = {};
    if (message.startupOptions?.length) {
      obj.startupOptions = message.startupOptions;
    }
    if (message.explicitStartupOptions?.length) {
      obj.explicitStartupOptions = message.explicitStartupOptions;
    }
    if (message.cmdLine?.length) {
      obj.cmdLine = message.cmdLine;
    }
    if (message.explicitCmdLine?.length) {
      obj.explicitCmdLine = message.explicitCmdLine;
    }
    if (message.invocationPolicy !== undefined) {
      obj.invocationPolicy = InvocationPolicy.toJSON(message.invocationPolicy);
    }
    if (message.toolTag !== "") {
      obj.toolTag = message.toolTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OptionsParsed>, I>>(base?: I): OptionsParsed {
    return OptionsParsed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OptionsParsed>, I>>(object: I): OptionsParsed {
    const message = createBaseOptionsParsed();
    message.startupOptions = object.startupOptions?.map((e) => e) || [];
    message.explicitStartupOptions = object.explicitStartupOptions?.map((e) => e) || [];
    message.cmdLine = object.cmdLine?.map((e) => e) || [];
    message.explicitCmdLine = object.explicitCmdLine?.map((e) => e) || [];
    message.invocationPolicy = (object.invocationPolicy !== undefined && object.invocationPolicy !== null)
      ? InvocationPolicy.fromPartial(object.invocationPolicy)
      : undefined;
    message.toolTag = object.toolTag ?? "";
    return message;
  },
};

function createBaseFetch(): Fetch {
  return { success: false };
}

export const Fetch: MessageFns<Fetch> = {
  encode(message: Fetch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fetch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fetch {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: Fetch): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fetch>, I>>(base?: I): Fetch {
    return Fetch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fetch>, I>>(object: I): Fetch {
    const message = createBaseFetch();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseWorkspaceStatus(): WorkspaceStatus {
  return { item: [] };
}

export const WorkspaceStatus: MessageFns<WorkspaceStatus> = {
  encode(message: WorkspaceStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.item) {
      WorkspaceStatus_Item.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.item.push(WorkspaceStatus_Item.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkspaceStatus {
    return {
      item: globalThis.Array.isArray(object?.item) ? object.item.map((e: any) => WorkspaceStatus_Item.fromJSON(e)) : [],
    };
  },

  toJSON(message: WorkspaceStatus): unknown {
    const obj: any = {};
    if (message.item?.length) {
      obj.item = message.item.map((e) => WorkspaceStatus_Item.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceStatus>, I>>(base?: I): WorkspaceStatus {
    return WorkspaceStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceStatus>, I>>(object: I): WorkspaceStatus {
    const message = createBaseWorkspaceStatus();
    message.item = object.item?.map((e) => WorkspaceStatus_Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkspaceStatus_Item(): WorkspaceStatus_Item {
  return { key: "", value: "" };
}

export const WorkspaceStatus_Item: MessageFns<WorkspaceStatus_Item> = {
  encode(message: WorkspaceStatus_Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceStatus_Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspaceStatus_Item();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkspaceStatus_Item {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorkspaceStatus_Item): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkspaceStatus_Item>, I>>(base?: I): WorkspaceStatus_Item {
    return WorkspaceStatus_Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkspaceStatus_Item>, I>>(object: I): WorkspaceStatus_Item {
    const message = createBaseWorkspaceStatus_Item();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBuildMetadata(): BuildMetadata {
  return { metadata: {} };
}

export const BuildMetadata: MessageFns<BuildMetadata> = {
  encode(message: BuildMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.metadata).forEach(([key, value]) => {
      BuildMetadata_MetadataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = BuildMetadata_MetadataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.metadata[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetadata {
    return {
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BuildMetadata): unknown {
    const obj: any = {};
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetadata>, I>>(base?: I): BuildMetadata {
    return BuildMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetadata>, I>>(object: I): BuildMetadata {
    const message = createBaseBuildMetadata();
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBuildMetadata_MetadataEntry(): BuildMetadata_MetadataEntry {
  return { key: "", value: "" };
}

export const BuildMetadata_MetadataEntry: MessageFns<BuildMetadata_MetadataEntry> = {
  encode(message: BuildMetadata_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetadata_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetadata_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetadata_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BuildMetadata_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetadata_MetadataEntry>, I>>(base?: I): BuildMetadata_MetadataEntry {
    return BuildMetadata_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetadata_MetadataEntry>, I>>(object: I): BuildMetadata_MetadataEntry {
    const message = createBaseBuildMetadata_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConfiguration(): Configuration {
  return { mnemonic: "", platformName: "", cpu: "", makeVariable: {}, isTool: false };
}

export const Configuration: MessageFns<Configuration> = {
  encode(message: Configuration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mnemonic !== "") {
      writer.uint32(10).string(message.mnemonic);
    }
    if (message.platformName !== "") {
      writer.uint32(18).string(message.platformName);
    }
    if (message.cpu !== "") {
      writer.uint32(26).string(message.cpu);
    }
    Object.entries(message.makeVariable).forEach(([key, value]) => {
      Configuration_MakeVariableEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.isTool !== false) {
      writer.uint32(40).bool(message.isTool);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Configuration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mnemonic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.platformName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cpu = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Configuration_MakeVariableEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.makeVariable[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isTool = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Configuration {
    return {
      mnemonic: isSet(object.mnemonic) ? globalThis.String(object.mnemonic) : "",
      platformName: isSet(object.platformName) ? globalThis.String(object.platformName) : "",
      cpu: isSet(object.cpu) ? globalThis.String(object.cpu) : "",
      makeVariable: isObject(object.makeVariable)
        ? Object.entries(object.makeVariable).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      isTool: isSet(object.isTool) ? globalThis.Boolean(object.isTool) : false,
    };
  },

  toJSON(message: Configuration): unknown {
    const obj: any = {};
    if (message.mnemonic !== "") {
      obj.mnemonic = message.mnemonic;
    }
    if (message.platformName !== "") {
      obj.platformName = message.platformName;
    }
    if (message.cpu !== "") {
      obj.cpu = message.cpu;
    }
    if (message.makeVariable) {
      const entries = Object.entries(message.makeVariable);
      if (entries.length > 0) {
        obj.makeVariable = {};
        entries.forEach(([k, v]) => {
          obj.makeVariable[k] = v;
        });
      }
    }
    if (message.isTool !== false) {
      obj.isTool = message.isTool;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Configuration>, I>>(base?: I): Configuration {
    return Configuration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Configuration>, I>>(object: I): Configuration {
    const message = createBaseConfiguration();
    message.mnemonic = object.mnemonic ?? "";
    message.platformName = object.platformName ?? "";
    message.cpu = object.cpu ?? "";
    message.makeVariable = Object.entries(object.makeVariable ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.isTool = object.isTool ?? false;
    return message;
  },
};

function createBaseConfiguration_MakeVariableEntry(): Configuration_MakeVariableEntry {
  return { key: "", value: "" };
}

export const Configuration_MakeVariableEntry: MessageFns<Configuration_MakeVariableEntry> = {
  encode(message: Configuration_MakeVariableEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Configuration_MakeVariableEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfiguration_MakeVariableEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Configuration_MakeVariableEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Configuration_MakeVariableEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Configuration_MakeVariableEntry>, I>>(base?: I): Configuration_MakeVariableEntry {
    return Configuration_MakeVariableEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Configuration_MakeVariableEntry>, I>>(
    object: I,
  ): Configuration_MakeVariableEntry {
    const message = createBaseConfiguration_MakeVariableEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePatternExpanded(): PatternExpanded {
  return { testSuiteExpansions: [] };
}

export const PatternExpanded: MessageFns<PatternExpanded> = {
  encode(message: PatternExpanded, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.testSuiteExpansions) {
      PatternExpanded_TestSuiteExpansion.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatternExpanded {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatternExpanded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.testSuiteExpansions.push(PatternExpanded_TestSuiteExpansion.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatternExpanded {
    return {
      testSuiteExpansions: globalThis.Array.isArray(object?.testSuiteExpansions)
        ? object.testSuiteExpansions.map((e: any) => PatternExpanded_TestSuiteExpansion.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PatternExpanded): unknown {
    const obj: any = {};
    if (message.testSuiteExpansions?.length) {
      obj.testSuiteExpansions = message.testSuiteExpansions.map((e) => PatternExpanded_TestSuiteExpansion.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatternExpanded>, I>>(base?: I): PatternExpanded {
    return PatternExpanded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatternExpanded>, I>>(object: I): PatternExpanded {
    const message = createBasePatternExpanded();
    message.testSuiteExpansions =
      object.testSuiteExpansions?.map((e) => PatternExpanded_TestSuiteExpansion.fromPartial(e)) || [];
    return message;
  },
};

function createBasePatternExpanded_TestSuiteExpansion(): PatternExpanded_TestSuiteExpansion {
  return { suiteLabel: "", testLabels: [] };
}

export const PatternExpanded_TestSuiteExpansion: MessageFns<PatternExpanded_TestSuiteExpansion> = {
  encode(message: PatternExpanded_TestSuiteExpansion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suiteLabel !== "") {
      writer.uint32(10).string(message.suiteLabel);
    }
    for (const v of message.testLabels) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatternExpanded_TestSuiteExpansion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatternExpanded_TestSuiteExpansion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.suiteLabel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testLabels.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatternExpanded_TestSuiteExpansion {
    return {
      suiteLabel: isSet(object.suiteLabel) ? globalThis.String(object.suiteLabel) : "",
      testLabels: globalThis.Array.isArray(object?.testLabels)
        ? object.testLabels.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PatternExpanded_TestSuiteExpansion): unknown {
    const obj: any = {};
    if (message.suiteLabel !== "") {
      obj.suiteLabel = message.suiteLabel;
    }
    if (message.testLabels?.length) {
      obj.testLabels = message.testLabels;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PatternExpanded_TestSuiteExpansion>, I>>(
    base?: I,
  ): PatternExpanded_TestSuiteExpansion {
    return PatternExpanded_TestSuiteExpansion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PatternExpanded_TestSuiteExpansion>, I>>(
    object: I,
  ): PatternExpanded_TestSuiteExpansion {
    const message = createBasePatternExpanded_TestSuiteExpansion();
    message.suiteLabel = object.suiteLabel ?? "";
    message.testLabels = object.testLabels?.map((e) => e) || [];
    return message;
  },
};

function createBaseTargetConfigured(): TargetConfigured {
  return { targetKind: "", testSize: 0, tag: [] };
}

export const TargetConfigured: MessageFns<TargetConfigured> = {
  encode(message: TargetConfigured, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetKind !== "") {
      writer.uint32(10).string(message.targetKind);
    }
    if (message.testSize !== 0) {
      writer.uint32(16).int32(message.testSize);
    }
    for (const v of message.tag) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetConfigured {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetConfigured();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetKind = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.testSize = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tag.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetConfigured {
    return {
      targetKind: isSet(object.targetKind) ? globalThis.String(object.targetKind) : "",
      testSize: isSet(object.testSize) ? testSizeFromJSON(object.testSize) : 0,
      tag: globalThis.Array.isArray(object?.tag) ? object.tag.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TargetConfigured): unknown {
    const obj: any = {};
    if (message.targetKind !== "") {
      obj.targetKind = message.targetKind;
    }
    if (message.testSize !== 0) {
      obj.testSize = testSizeToJSON(message.testSize);
    }
    if (message.tag?.length) {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TargetConfigured>, I>>(base?: I): TargetConfigured {
    return TargetConfigured.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TargetConfigured>, I>>(object: I): TargetConfigured {
    const message = createBaseTargetConfigured();
    message.targetKind = object.targetKind ?? "";
    message.testSize = object.testSize ?? 0;
    message.tag = object.tag?.map((e) => e) || [];
    return message;
  },
};

function createBaseFile(): File {
  return {
    pathPrefix: [],
    name: "",
    uri: undefined,
    contents: undefined,
    symlinkTargetPath: undefined,
    digest: "",
    length: "0",
  };
}

export const File: MessageFns<File> = {
  encode(message: File, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pathPrefix) {
      writer.uint32(34).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uri !== undefined) {
      writer.uint32(18).string(message.uri);
    }
    if (message.contents !== undefined) {
      writer.uint32(26).bytes(message.contents);
    }
    if (message.symlinkTargetPath !== undefined) {
      writer.uint32(58).string(message.symlinkTargetPath);
    }
    if (message.digest !== "") {
      writer.uint32(42).string(message.digest);
    }
    if (message.length !== "0") {
      writer.uint32(48).int64(message.length);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): File {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pathPrefix.push(reader.string());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contents = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.symlinkTargetPath = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.digest = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.length = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): File {
    return {
      pathPrefix: globalThis.Array.isArray(object?.pathPrefix)
        ? object.pathPrefix.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      contents: isSet(object.contents) ? bytesFromBase64(object.contents) : undefined,
      symlinkTargetPath: isSet(object.symlinkTargetPath) ? globalThis.String(object.symlinkTargetPath) : undefined,
      digest: isSet(object.digest) ? globalThis.String(object.digest) : "",
      length: isSet(object.length) ? globalThis.String(object.length) : "0",
    };
  },

  toJSON(message: File): unknown {
    const obj: any = {};
    if (message.pathPrefix?.length) {
      obj.pathPrefix = message.pathPrefix;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.contents !== undefined) {
      obj.contents = base64FromBytes(message.contents);
    }
    if (message.symlinkTargetPath !== undefined) {
      obj.symlinkTargetPath = message.symlinkTargetPath;
    }
    if (message.digest !== "") {
      obj.digest = message.digest;
    }
    if (message.length !== "0") {
      obj.length = message.length;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<File>, I>>(base?: I): File {
    return File.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<File>, I>>(object: I): File {
    const message = createBaseFile();
    message.pathPrefix = object.pathPrefix?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.uri = object.uri ?? undefined;
    message.contents = object.contents ?? undefined;
    message.symlinkTargetPath = object.symlinkTargetPath ?? undefined;
    message.digest = object.digest ?? "";
    message.length = object.length ?? "0";
    return message;
  },
};

function createBaseNamedSetOfFiles(): NamedSetOfFiles {
  return { files: [], fileSets: [] };
}

export const NamedSetOfFiles: MessageFns<NamedSetOfFiles> = {
  encode(message: NamedSetOfFiles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      File.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.fileSets) {
      BuildEventId_NamedSetOfFilesId.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedSetOfFiles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedSetOfFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileSets.push(BuildEventId_NamedSetOfFilesId.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NamedSetOfFiles {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      fileSets: globalThis.Array.isArray(object?.fileSets)
        ? object.fileSets.map((e: any) => BuildEventId_NamedSetOfFilesId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NamedSetOfFiles): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.fileSets?.length) {
      obj.fileSets = message.fileSets.map((e) => BuildEventId_NamedSetOfFilesId.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NamedSetOfFiles>, I>>(base?: I): NamedSetOfFiles {
    return NamedSetOfFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NamedSetOfFiles>, I>>(object: I): NamedSetOfFiles {
    const message = createBaseNamedSetOfFiles();
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.fileSets = object.fileSets?.map((e) => BuildEventId_NamedSetOfFilesId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActionExecuted(): ActionExecuted {
  return {
    success: false,
    type: "",
    exitCode: 0,
    stdout: undefined,
    stderr: undefined,
    label: "",
    configuration: undefined,
    primaryOutput: undefined,
    commandLine: [],
    failureDetail: undefined,
    startTime: undefined,
    endTime: undefined,
    strategyDetails: [],
  };
}

export const ActionExecuted: MessageFns<ActionExecuted> = {
  encode(message: ActionExecuted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.type !== "") {
      writer.uint32(66).string(message.type);
    }
    if (message.exitCode !== 0) {
      writer.uint32(16).int32(message.exitCode);
    }
    if (message.stdout !== undefined) {
      File.encode(message.stdout, writer.uint32(26).fork()).join();
    }
    if (message.stderr !== undefined) {
      File.encode(message.stderr, writer.uint32(34).fork()).join();
    }
    if (message.label !== "") {
      writer.uint32(42).string(message.label);
    }
    if (message.configuration !== undefined) {
      BuildEventId_ConfigurationId.encode(message.configuration, writer.uint32(58).fork()).join();
    }
    if (message.primaryOutput !== undefined) {
      File.encode(message.primaryOutput, writer.uint32(50).fork()).join();
    }
    for (const v of message.commandLine) {
      writer.uint32(74).string(v!);
    }
    if (message.failureDetail !== undefined) {
      FailureDetail.encode(message.failureDetail, writer.uint32(90).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(98).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(106).fork()).join();
    }
    for (const v of message.strategyDetails) {
      Any.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionExecuted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionExecuted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stdout = File.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stderr = File.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.configuration = BuildEventId_ConfigurationId.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.primaryOutput = File.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.commandLine.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.failureDetail = FailureDetail.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.strategyDetails.push(Any.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionExecuted {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      stdout: isSet(object.stdout) ? File.fromJSON(object.stdout) : undefined,
      stderr: isSet(object.stderr) ? File.fromJSON(object.stderr) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      configuration: isSet(object.configuration)
        ? BuildEventId_ConfigurationId.fromJSON(object.configuration)
        : undefined,
      primaryOutput: isSet(object.primaryOutput) ? File.fromJSON(object.primaryOutput) : undefined,
      commandLine: globalThis.Array.isArray(object?.commandLine)
        ? object.commandLine.map((e: any) => globalThis.String(e))
        : [],
      failureDetail: isSet(object.failureDetail) ? FailureDetail.fromJSON(object.failureDetail) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      strategyDetails: globalThis.Array.isArray(object?.strategyDetails)
        ? object.strategyDetails.map((e: any) => Any.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ActionExecuted): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.stdout !== undefined) {
      obj.stdout = File.toJSON(message.stdout);
    }
    if (message.stderr !== undefined) {
      obj.stderr = File.toJSON(message.stderr);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.configuration !== undefined) {
      obj.configuration = BuildEventId_ConfigurationId.toJSON(message.configuration);
    }
    if (message.primaryOutput !== undefined) {
      obj.primaryOutput = File.toJSON(message.primaryOutput);
    }
    if (message.commandLine?.length) {
      obj.commandLine = message.commandLine;
    }
    if (message.failureDetail !== undefined) {
      obj.failureDetail = FailureDetail.toJSON(message.failureDetail);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.strategyDetails?.length) {
      obj.strategyDetails = message.strategyDetails.map((e) => Any.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionExecuted>, I>>(base?: I): ActionExecuted {
    return ActionExecuted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionExecuted>, I>>(object: I): ActionExecuted {
    const message = createBaseActionExecuted();
    message.success = object.success ?? false;
    message.type = object.type ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.stdout = (object.stdout !== undefined && object.stdout !== null)
      ? File.fromPartial(object.stdout)
      : undefined;
    message.stderr = (object.stderr !== undefined && object.stderr !== null)
      ? File.fromPartial(object.stderr)
      : undefined;
    message.label = object.label ?? "";
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? BuildEventId_ConfigurationId.fromPartial(object.configuration)
      : undefined;
    message.primaryOutput = (object.primaryOutput !== undefined && object.primaryOutput !== null)
      ? File.fromPartial(object.primaryOutput)
      : undefined;
    message.commandLine = object.commandLine?.map((e) => e) || [];
    message.failureDetail = (object.failureDetail !== undefined && object.failureDetail !== null)
      ? FailureDetail.fromPartial(object.failureDetail)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.strategyDetails = object.strategyDetails?.map((e) => Any.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOutputGroup(): OutputGroup {
  return { name: "", fileSets: [], incomplete: false, inlineFiles: [] };
}

export const OutputGroup: MessageFns<OutputGroup> = {
  encode(message: OutputGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.fileSets) {
      BuildEventId_NamedSetOfFilesId.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.incomplete !== false) {
      writer.uint32(32).bool(message.incomplete);
    }
    for (const v of message.inlineFiles) {
      File.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileSets.push(BuildEventId_NamedSetOfFilesId.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.incomplete = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inlineFiles.push(File.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fileSets: globalThis.Array.isArray(object?.fileSets)
        ? object.fileSets.map((e: any) => BuildEventId_NamedSetOfFilesId.fromJSON(e))
        : [],
      incomplete: isSet(object.incomplete) ? globalThis.Boolean(object.incomplete) : false,
      inlineFiles: globalThis.Array.isArray(object?.inlineFiles)
        ? object.inlineFiles.map((e: any) => File.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OutputGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fileSets?.length) {
      obj.fileSets = message.fileSets.map((e) => BuildEventId_NamedSetOfFilesId.toJSON(e));
    }
    if (message.incomplete !== false) {
      obj.incomplete = message.incomplete;
    }
    if (message.inlineFiles?.length) {
      obj.inlineFiles = message.inlineFiles.map((e) => File.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputGroup>, I>>(base?: I): OutputGroup {
    return OutputGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputGroup>, I>>(object: I): OutputGroup {
    const message = createBaseOutputGroup();
    message.name = object.name ?? "";
    message.fileSets = object.fileSets?.map((e) => BuildEventId_NamedSetOfFilesId.fromPartial(e)) || [];
    message.incomplete = object.incomplete ?? false;
    message.inlineFiles = object.inlineFiles?.map((e) => File.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTargetComplete(): TargetComplete {
  return {
    success: false,
    targetKind: "",
    testSize: 0,
    outputGroup: [],
    importantOutput: [],
    directoryOutput: [],
    tag: [],
    testTimeoutSeconds: "0",
    testTimeout: undefined,
    failureDetail: undefined,
  };
}

export const TargetComplete: MessageFns<TargetComplete> = {
  encode(message: TargetComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.targetKind !== "") {
      writer.uint32(42).string(message.targetKind);
    }
    if (message.testSize !== 0) {
      writer.uint32(48).int32(message.testSize);
    }
    for (const v of message.outputGroup) {
      OutputGroup.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.importantOutput) {
      File.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.directoryOutput) {
      File.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.tag) {
      writer.uint32(26).string(v!);
    }
    if (message.testTimeoutSeconds !== "0") {
      writer.uint32(56).int64(message.testTimeoutSeconds);
    }
    if (message.testTimeout !== undefined) {
      Duration.encode(message.testTimeout, writer.uint32(82).fork()).join();
    }
    if (message.failureDetail !== undefined) {
      FailureDetail.encode(message.failureDetail, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targetKind = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.testSize = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputGroup.push(OutputGroup.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.importantOutput.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.directoryOutput.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tag.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.testTimeoutSeconds = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.testTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.failureDetail = FailureDetail.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetComplete {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      targetKind: isSet(object.targetKind) ? globalThis.String(object.targetKind) : "",
      testSize: isSet(object.testSize) ? testSizeFromJSON(object.testSize) : 0,
      outputGroup: globalThis.Array.isArray(object?.outputGroup)
        ? object.outputGroup.map((e: any) => OutputGroup.fromJSON(e))
        : [],
      importantOutput: globalThis.Array.isArray(object?.importantOutput)
        ? object.importantOutput.map((e: any) => File.fromJSON(e))
        : [],
      directoryOutput: globalThis.Array.isArray(object?.directoryOutput)
        ? object.directoryOutput.map((e: any) => File.fromJSON(e))
        : [],
      tag: globalThis.Array.isArray(object?.tag) ? object.tag.map((e: any) => globalThis.String(e)) : [],
      testTimeoutSeconds: isSet(object.testTimeoutSeconds) ? globalThis.String(object.testTimeoutSeconds) : "0",
      testTimeout: isSet(object.testTimeout) ? Duration.fromJSON(object.testTimeout) : undefined,
      failureDetail: isSet(object.failureDetail) ? FailureDetail.fromJSON(object.failureDetail) : undefined,
    };
  },

  toJSON(message: TargetComplete): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.targetKind !== "") {
      obj.targetKind = message.targetKind;
    }
    if (message.testSize !== 0) {
      obj.testSize = testSizeToJSON(message.testSize);
    }
    if (message.outputGroup?.length) {
      obj.outputGroup = message.outputGroup.map((e) => OutputGroup.toJSON(e));
    }
    if (message.importantOutput?.length) {
      obj.importantOutput = message.importantOutput.map((e) => File.toJSON(e));
    }
    if (message.directoryOutput?.length) {
      obj.directoryOutput = message.directoryOutput.map((e) => File.toJSON(e));
    }
    if (message.tag?.length) {
      obj.tag = message.tag;
    }
    if (message.testTimeoutSeconds !== "0") {
      obj.testTimeoutSeconds = message.testTimeoutSeconds;
    }
    if (message.testTimeout !== undefined) {
      obj.testTimeout = Duration.toJSON(message.testTimeout);
    }
    if (message.failureDetail !== undefined) {
      obj.failureDetail = FailureDetail.toJSON(message.failureDetail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TargetComplete>, I>>(base?: I): TargetComplete {
    return TargetComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TargetComplete>, I>>(object: I): TargetComplete {
    const message = createBaseTargetComplete();
    message.success = object.success ?? false;
    message.targetKind = object.targetKind ?? "";
    message.testSize = object.testSize ?? 0;
    message.outputGroup = object.outputGroup?.map((e) => OutputGroup.fromPartial(e)) || [];
    message.importantOutput = object.importantOutput?.map((e) => File.fromPartial(e)) || [];
    message.directoryOutput = object.directoryOutput?.map((e) => File.fromPartial(e)) || [];
    message.tag = object.tag?.map((e) => e) || [];
    message.testTimeoutSeconds = object.testTimeoutSeconds ?? "0";
    message.testTimeout = (object.testTimeout !== undefined && object.testTimeout !== null)
      ? Duration.fromPartial(object.testTimeout)
      : undefined;
    message.failureDetail = (object.failureDetail !== undefined && object.failureDetail !== null)
      ? FailureDetail.fromPartial(object.failureDetail)
      : undefined;
    return message;
  },
};

function createBaseTestResult(): TestResult {
  return {
    status: 0,
    statusDetails: "",
    cachedLocally: false,
    testAttemptStartMillisEpoch: "0",
    testAttemptStart: undefined,
    testAttemptDurationMillis: "0",
    testAttemptDuration: undefined,
    testActionOutput: [],
    warning: [],
    executionInfo: undefined,
  };
}

export const TestResult: MessageFns<TestResult> = {
  encode(message: TestResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.statusDetails !== "") {
      writer.uint32(74).string(message.statusDetails);
    }
    if (message.cachedLocally !== false) {
      writer.uint32(32).bool(message.cachedLocally);
    }
    if (message.testAttemptStartMillisEpoch !== "0") {
      writer.uint32(48).int64(message.testAttemptStartMillisEpoch);
    }
    if (message.testAttemptStart !== undefined) {
      Timestamp.encode(toTimestamp(message.testAttemptStart), writer.uint32(82).fork()).join();
    }
    if (message.testAttemptDurationMillis !== "0") {
      writer.uint32(24).int64(message.testAttemptDurationMillis);
    }
    if (message.testAttemptDuration !== undefined) {
      Duration.encode(message.testAttemptDuration, writer.uint32(90).fork()).join();
    }
    for (const v of message.testActionOutput) {
      File.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.warning) {
      writer.uint32(58).string(v!);
    }
    if (message.executionInfo !== undefined) {
      TestResult_ExecutionInfo.encode(message.executionInfo, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.statusDetails = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cachedLocally = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.testAttemptStartMillisEpoch = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.testAttemptStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.testAttemptDurationMillis = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.testAttemptDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.testActionOutput.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.warning.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.executionInfo = TestResult_ExecutionInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestResult {
    return {
      status: isSet(object.status) ? testStatusFromJSON(object.status) : 0,
      statusDetails: isSet(object.statusDetails) ? globalThis.String(object.statusDetails) : "",
      cachedLocally: isSet(object.cachedLocally) ? globalThis.Boolean(object.cachedLocally) : false,
      testAttemptStartMillisEpoch: isSet(object.testAttemptStartMillisEpoch)
        ? globalThis.String(object.testAttemptStartMillisEpoch)
        : "0",
      testAttemptStart: isSet(object.testAttemptStart) ? fromJsonTimestamp(object.testAttemptStart) : undefined,
      testAttemptDurationMillis: isSet(object.testAttemptDurationMillis)
        ? globalThis.String(object.testAttemptDurationMillis)
        : "0",
      testAttemptDuration: isSet(object.testAttemptDuration)
        ? Duration.fromJSON(object.testAttemptDuration)
        : undefined,
      testActionOutput: globalThis.Array.isArray(object?.testActionOutput)
        ? object.testActionOutput.map((e: any) => File.fromJSON(e))
        : [],
      warning: globalThis.Array.isArray(object?.warning) ? object.warning.map((e: any) => globalThis.String(e)) : [],
      executionInfo: isSet(object.executionInfo) ? TestResult_ExecutionInfo.fromJSON(object.executionInfo) : undefined,
    };
  },

  toJSON(message: TestResult): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = testStatusToJSON(message.status);
    }
    if (message.statusDetails !== "") {
      obj.statusDetails = message.statusDetails;
    }
    if (message.cachedLocally !== false) {
      obj.cachedLocally = message.cachedLocally;
    }
    if (message.testAttemptStartMillisEpoch !== "0") {
      obj.testAttemptStartMillisEpoch = message.testAttemptStartMillisEpoch;
    }
    if (message.testAttemptStart !== undefined) {
      obj.testAttemptStart = message.testAttemptStart.toISOString();
    }
    if (message.testAttemptDurationMillis !== "0") {
      obj.testAttemptDurationMillis = message.testAttemptDurationMillis;
    }
    if (message.testAttemptDuration !== undefined) {
      obj.testAttemptDuration = Duration.toJSON(message.testAttemptDuration);
    }
    if (message.testActionOutput?.length) {
      obj.testActionOutput = message.testActionOutput.map((e) => File.toJSON(e));
    }
    if (message.warning?.length) {
      obj.warning = message.warning;
    }
    if (message.executionInfo !== undefined) {
      obj.executionInfo = TestResult_ExecutionInfo.toJSON(message.executionInfo);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestResult>, I>>(base?: I): TestResult {
    return TestResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestResult>, I>>(object: I): TestResult {
    const message = createBaseTestResult();
    message.status = object.status ?? 0;
    message.statusDetails = object.statusDetails ?? "";
    message.cachedLocally = object.cachedLocally ?? false;
    message.testAttemptStartMillisEpoch = object.testAttemptStartMillisEpoch ?? "0";
    message.testAttemptStart = object.testAttemptStart ?? undefined;
    message.testAttemptDurationMillis = object.testAttemptDurationMillis ?? "0";
    message.testAttemptDuration = (object.testAttemptDuration !== undefined && object.testAttemptDuration !== null)
      ? Duration.fromPartial(object.testAttemptDuration)
      : undefined;
    message.testActionOutput = object.testActionOutput?.map((e) => File.fromPartial(e)) || [];
    message.warning = object.warning?.map((e) => e) || [];
    message.executionInfo = (object.executionInfo !== undefined && object.executionInfo !== null)
      ? TestResult_ExecutionInfo.fromPartial(object.executionInfo)
      : undefined;
    return message;
  },
};

function createBaseTestResult_ExecutionInfo(): TestResult_ExecutionInfo {
  return {
    timeoutSeconds: 0,
    strategy: "",
    cachedRemotely: false,
    exitCode: 0,
    hostname: "",
    timingBreakdown: undefined,
    resourceUsage: [],
  };
}

export const TestResult_ExecutionInfo: MessageFns<TestResult_ExecutionInfo> = {
  encode(message: TestResult_ExecutionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeoutSeconds !== 0) {
      writer.uint32(8).int32(message.timeoutSeconds);
    }
    if (message.strategy !== "") {
      writer.uint32(18).string(message.strategy);
    }
    if (message.cachedRemotely !== false) {
      writer.uint32(48).bool(message.cachedRemotely);
    }
    if (message.exitCode !== 0) {
      writer.uint32(56).int32(message.exitCode);
    }
    if (message.hostname !== "") {
      writer.uint32(26).string(message.hostname);
    }
    if (message.timingBreakdown !== undefined) {
      TestResult_ExecutionInfo_TimingBreakdown.encode(message.timingBreakdown, writer.uint32(34).fork()).join();
    }
    for (const v of message.resourceUsage) {
      TestResult_ExecutionInfo_ResourceUsage.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestResult_ExecutionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult_ExecutionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeoutSeconds = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.strategy = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cachedRemotely = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timingBreakdown = TestResult_ExecutionInfo_TimingBreakdown.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resourceUsage.push(TestResult_ExecutionInfo_ResourceUsage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestResult_ExecutionInfo {
    return {
      timeoutSeconds: isSet(object.timeoutSeconds) ? globalThis.Number(object.timeoutSeconds) : 0,
      strategy: isSet(object.strategy) ? globalThis.String(object.strategy) : "",
      cachedRemotely: isSet(object.cachedRemotely) ? globalThis.Boolean(object.cachedRemotely) : false,
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      timingBreakdown: isSet(object.timingBreakdown)
        ? TestResult_ExecutionInfo_TimingBreakdown.fromJSON(object.timingBreakdown)
        : undefined,
      resourceUsage: globalThis.Array.isArray(object?.resourceUsage)
        ? object.resourceUsage.map((e: any) => TestResult_ExecutionInfo_ResourceUsage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TestResult_ExecutionInfo): unknown {
    const obj: any = {};
    if (message.timeoutSeconds !== 0) {
      obj.timeoutSeconds = Math.round(message.timeoutSeconds);
    }
    if (message.strategy !== "") {
      obj.strategy = message.strategy;
    }
    if (message.cachedRemotely !== false) {
      obj.cachedRemotely = message.cachedRemotely;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.timingBreakdown !== undefined) {
      obj.timingBreakdown = TestResult_ExecutionInfo_TimingBreakdown.toJSON(message.timingBreakdown);
    }
    if (message.resourceUsage?.length) {
      obj.resourceUsage = message.resourceUsage.map((e) => TestResult_ExecutionInfo_ResourceUsage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestResult_ExecutionInfo>, I>>(base?: I): TestResult_ExecutionInfo {
    return TestResult_ExecutionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestResult_ExecutionInfo>, I>>(object: I): TestResult_ExecutionInfo {
    const message = createBaseTestResult_ExecutionInfo();
    message.timeoutSeconds = object.timeoutSeconds ?? 0;
    message.strategy = object.strategy ?? "";
    message.cachedRemotely = object.cachedRemotely ?? false;
    message.exitCode = object.exitCode ?? 0;
    message.hostname = object.hostname ?? "";
    message.timingBreakdown = (object.timingBreakdown !== undefined && object.timingBreakdown !== null)
      ? TestResult_ExecutionInfo_TimingBreakdown.fromPartial(object.timingBreakdown)
      : undefined;
    message.resourceUsage = object.resourceUsage?.map((e) => TestResult_ExecutionInfo_ResourceUsage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseTestResult_ExecutionInfo_TimingBreakdown(): TestResult_ExecutionInfo_TimingBreakdown {
  return { child: [], name: "", timeMillis: "0", time: undefined };
}

export const TestResult_ExecutionInfo_TimingBreakdown: MessageFns<TestResult_ExecutionInfo_TimingBreakdown> = {
  encode(message: TestResult_ExecutionInfo_TimingBreakdown, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.child) {
      TestResult_ExecutionInfo_TimingBreakdown.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.timeMillis !== "0") {
      writer.uint32(24).int64(message.timeMillis);
    }
    if (message.time !== undefined) {
      Duration.encode(message.time, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestResult_ExecutionInfo_TimingBreakdown {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult_ExecutionInfo_TimingBreakdown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.child.push(TestResult_ExecutionInfo_TimingBreakdown.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timeMillis = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.time = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestResult_ExecutionInfo_TimingBreakdown {
    return {
      child: globalThis.Array.isArray(object?.child)
        ? object.child.map((e: any) => TestResult_ExecutionInfo_TimingBreakdown.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      timeMillis: isSet(object.timeMillis) ? globalThis.String(object.timeMillis) : "0",
      time: isSet(object.time) ? Duration.fromJSON(object.time) : undefined,
    };
  },

  toJSON(message: TestResult_ExecutionInfo_TimingBreakdown): unknown {
    const obj: any = {};
    if (message.child?.length) {
      obj.child = message.child.map((e) => TestResult_ExecutionInfo_TimingBreakdown.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.timeMillis !== "0") {
      obj.timeMillis = message.timeMillis;
    }
    if (message.time !== undefined) {
      obj.time = Duration.toJSON(message.time);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestResult_ExecutionInfo_TimingBreakdown>, I>>(
    base?: I,
  ): TestResult_ExecutionInfo_TimingBreakdown {
    return TestResult_ExecutionInfo_TimingBreakdown.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestResult_ExecutionInfo_TimingBreakdown>, I>>(
    object: I,
  ): TestResult_ExecutionInfo_TimingBreakdown {
    const message = createBaseTestResult_ExecutionInfo_TimingBreakdown();
    message.child = object.child?.map((e) => TestResult_ExecutionInfo_TimingBreakdown.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.timeMillis = object.timeMillis ?? "0";
    message.time = (object.time !== undefined && object.time !== null) ? Duration.fromPartial(object.time) : undefined;
    return message;
  },
};

function createBaseTestResult_ExecutionInfo_ResourceUsage(): TestResult_ExecutionInfo_ResourceUsage {
  return { name: "", value: "0" };
}

export const TestResult_ExecutionInfo_ResourceUsage: MessageFns<TestResult_ExecutionInfo_ResourceUsage> = {
  encode(message: TestResult_ExecutionInfo_ResourceUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "0") {
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestResult_ExecutionInfo_ResourceUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestResult_ExecutionInfo_ResourceUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestResult_ExecutionInfo_ResourceUsage {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "0",
    };
  },

  toJSON(message: TestResult_ExecutionInfo_ResourceUsage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "0") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestResult_ExecutionInfo_ResourceUsage>, I>>(
    base?: I,
  ): TestResult_ExecutionInfo_ResourceUsage {
    return TestResult_ExecutionInfo_ResourceUsage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestResult_ExecutionInfo_ResourceUsage>, I>>(
    object: I,
  ): TestResult_ExecutionInfo_ResourceUsage {
    const message = createBaseTestResult_ExecutionInfo_ResourceUsage();
    message.name = object.name ?? "";
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseTestProgress(): TestProgress {
  return { uri: "" };
}

export const TestProgress: MessageFns<TestProgress> = {
  encode(message: TestProgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestProgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestProgress {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: TestProgress): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestProgress>, I>>(base?: I): TestProgress {
    return TestProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestProgress>, I>>(object: I): TestProgress {
    const message = createBaseTestProgress();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseTestSummary(): TestSummary {
  return {
    overallStatus: 0,
    totalRunCount: 0,
    runCount: 0,
    attemptCount: 0,
    shardCount: 0,
    passed: [],
    failed: [],
    totalNumCached: 0,
    firstStartTimeMillis: "0",
    firstStartTime: undefined,
    lastStopTimeMillis: "0",
    lastStopTime: undefined,
    totalRunDurationMillis: "0",
    totalRunDuration: undefined,
  };
}

export const TestSummary: MessageFns<TestSummary> = {
  encode(message: TestSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overallStatus !== 0) {
      writer.uint32(40).int32(message.overallStatus);
    }
    if (message.totalRunCount !== 0) {
      writer.uint32(8).int32(message.totalRunCount);
    }
    if (message.runCount !== 0) {
      writer.uint32(80).int32(message.runCount);
    }
    if (message.attemptCount !== 0) {
      writer.uint32(120).int32(message.attemptCount);
    }
    if (message.shardCount !== 0) {
      writer.uint32(88).int32(message.shardCount);
    }
    for (const v of message.passed) {
      File.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.failed) {
      File.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.totalNumCached !== 0) {
      writer.uint32(48).int32(message.totalNumCached);
    }
    if (message.firstStartTimeMillis !== "0") {
      writer.uint32(56).int64(message.firstStartTimeMillis);
    }
    if (message.firstStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.firstStartTime), writer.uint32(106).fork()).join();
    }
    if (message.lastStopTimeMillis !== "0") {
      writer.uint32(64).int64(message.lastStopTimeMillis);
    }
    if (message.lastStopTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastStopTime), writer.uint32(114).fork()).join();
    }
    if (message.totalRunDurationMillis !== "0") {
      writer.uint32(72).int64(message.totalRunDurationMillis);
    }
    if (message.totalRunDuration !== undefined) {
      Duration.encode(message.totalRunDuration, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TestSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTestSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.overallStatus = reader.int32() as any;
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalRunCount = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.runCount = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.attemptCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.shardCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.passed.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.failed.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalNumCached = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.firstStartTimeMillis = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.firstStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.lastStopTimeMillis = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.lastStopTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.totalRunDurationMillis = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.totalRunDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TestSummary {
    return {
      overallStatus: isSet(object.overallStatus) ? testStatusFromJSON(object.overallStatus) : 0,
      totalRunCount: isSet(object.totalRunCount) ? globalThis.Number(object.totalRunCount) : 0,
      runCount: isSet(object.runCount) ? globalThis.Number(object.runCount) : 0,
      attemptCount: isSet(object.attemptCount) ? globalThis.Number(object.attemptCount) : 0,
      shardCount: isSet(object.shardCount) ? globalThis.Number(object.shardCount) : 0,
      passed: globalThis.Array.isArray(object?.passed) ? object.passed.map((e: any) => File.fromJSON(e)) : [],
      failed: globalThis.Array.isArray(object?.failed) ? object.failed.map((e: any) => File.fromJSON(e)) : [],
      totalNumCached: isSet(object.totalNumCached) ? globalThis.Number(object.totalNumCached) : 0,
      firstStartTimeMillis: isSet(object.firstStartTimeMillis) ? globalThis.String(object.firstStartTimeMillis) : "0",
      firstStartTime: isSet(object.firstStartTime) ? fromJsonTimestamp(object.firstStartTime) : undefined,
      lastStopTimeMillis: isSet(object.lastStopTimeMillis) ? globalThis.String(object.lastStopTimeMillis) : "0",
      lastStopTime: isSet(object.lastStopTime) ? fromJsonTimestamp(object.lastStopTime) : undefined,
      totalRunDurationMillis: isSet(object.totalRunDurationMillis)
        ? globalThis.String(object.totalRunDurationMillis)
        : "0",
      totalRunDuration: isSet(object.totalRunDuration) ? Duration.fromJSON(object.totalRunDuration) : undefined,
    };
  },

  toJSON(message: TestSummary): unknown {
    const obj: any = {};
    if (message.overallStatus !== 0) {
      obj.overallStatus = testStatusToJSON(message.overallStatus);
    }
    if (message.totalRunCount !== 0) {
      obj.totalRunCount = Math.round(message.totalRunCount);
    }
    if (message.runCount !== 0) {
      obj.runCount = Math.round(message.runCount);
    }
    if (message.attemptCount !== 0) {
      obj.attemptCount = Math.round(message.attemptCount);
    }
    if (message.shardCount !== 0) {
      obj.shardCount = Math.round(message.shardCount);
    }
    if (message.passed?.length) {
      obj.passed = message.passed.map((e) => File.toJSON(e));
    }
    if (message.failed?.length) {
      obj.failed = message.failed.map((e) => File.toJSON(e));
    }
    if (message.totalNumCached !== 0) {
      obj.totalNumCached = Math.round(message.totalNumCached);
    }
    if (message.firstStartTimeMillis !== "0") {
      obj.firstStartTimeMillis = message.firstStartTimeMillis;
    }
    if (message.firstStartTime !== undefined) {
      obj.firstStartTime = message.firstStartTime.toISOString();
    }
    if (message.lastStopTimeMillis !== "0") {
      obj.lastStopTimeMillis = message.lastStopTimeMillis;
    }
    if (message.lastStopTime !== undefined) {
      obj.lastStopTime = message.lastStopTime.toISOString();
    }
    if (message.totalRunDurationMillis !== "0") {
      obj.totalRunDurationMillis = message.totalRunDurationMillis;
    }
    if (message.totalRunDuration !== undefined) {
      obj.totalRunDuration = Duration.toJSON(message.totalRunDuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TestSummary>, I>>(base?: I): TestSummary {
    return TestSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TestSummary>, I>>(object: I): TestSummary {
    const message = createBaseTestSummary();
    message.overallStatus = object.overallStatus ?? 0;
    message.totalRunCount = object.totalRunCount ?? 0;
    message.runCount = object.runCount ?? 0;
    message.attemptCount = object.attemptCount ?? 0;
    message.shardCount = object.shardCount ?? 0;
    message.passed = object.passed?.map((e) => File.fromPartial(e)) || [];
    message.failed = object.failed?.map((e) => File.fromPartial(e)) || [];
    message.totalNumCached = object.totalNumCached ?? 0;
    message.firstStartTimeMillis = object.firstStartTimeMillis ?? "0";
    message.firstStartTime = object.firstStartTime ?? undefined;
    message.lastStopTimeMillis = object.lastStopTimeMillis ?? "0";
    message.lastStopTime = object.lastStopTime ?? undefined;
    message.totalRunDurationMillis = object.totalRunDurationMillis ?? "0";
    message.totalRunDuration = (object.totalRunDuration !== undefined && object.totalRunDuration !== null)
      ? Duration.fromPartial(object.totalRunDuration)
      : undefined;
    return message;
  },
};

function createBaseTargetSummary(): TargetSummary {
  return { overallBuildSuccess: false, overallTestStatus: 0 };
}

export const TargetSummary: MessageFns<TargetSummary> = {
  encode(message: TargetSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overallBuildSuccess !== false) {
      writer.uint32(8).bool(message.overallBuildSuccess);
    }
    if (message.overallTestStatus !== 0) {
      writer.uint32(16).int32(message.overallTestStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overallBuildSuccess = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.overallTestStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetSummary {
    return {
      overallBuildSuccess: isSet(object.overallBuildSuccess) ? globalThis.Boolean(object.overallBuildSuccess) : false,
      overallTestStatus: isSet(object.overallTestStatus) ? testStatusFromJSON(object.overallTestStatus) : 0,
    };
  },

  toJSON(message: TargetSummary): unknown {
    const obj: any = {};
    if (message.overallBuildSuccess !== false) {
      obj.overallBuildSuccess = message.overallBuildSuccess;
    }
    if (message.overallTestStatus !== 0) {
      obj.overallTestStatus = testStatusToJSON(message.overallTestStatus);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TargetSummary>, I>>(base?: I): TargetSummary {
    return TargetSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TargetSummary>, I>>(object: I): TargetSummary {
    const message = createBaseTargetSummary();
    message.overallBuildSuccess = object.overallBuildSuccess ?? false;
    message.overallTestStatus = object.overallTestStatus ?? 0;
    return message;
  },
};

function createBaseBuildFinished(): BuildFinished {
  return {
    overallSuccess: false,
    exitCode: undefined,
    finishTimeMillis: "0",
    finishTime: undefined,
    anomalyReport: undefined,
    failureDetail: undefined,
  };
}

export const BuildFinished: MessageFns<BuildFinished> = {
  encode(message: BuildFinished, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.overallSuccess !== false) {
      writer.uint32(8).bool(message.overallSuccess);
    }
    if (message.exitCode !== undefined) {
      BuildFinished_ExitCode.encode(message.exitCode, writer.uint32(26).fork()).join();
    }
    if (message.finishTimeMillis !== "0") {
      writer.uint32(16).int64(message.finishTimeMillis);
    }
    if (message.finishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.finishTime), writer.uint32(42).fork()).join();
    }
    if (message.anomalyReport !== undefined) {
      BuildFinished_AnomalyReport.encode(message.anomalyReport, writer.uint32(34).fork()).join();
    }
    if (message.failureDetail !== undefined) {
      FailureDetail.encode(message.failureDetail, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildFinished {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildFinished();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.overallSuccess = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exitCode = BuildFinished_ExitCode.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finishTimeMillis = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.finishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.anomalyReport = BuildFinished_AnomalyReport.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.failureDetail = FailureDetail.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildFinished {
    return {
      overallSuccess: isSet(object.overallSuccess) ? globalThis.Boolean(object.overallSuccess) : false,
      exitCode: isSet(object.exitCode) ? BuildFinished_ExitCode.fromJSON(object.exitCode) : undefined,
      finishTimeMillis: isSet(object.finishTimeMillis) ? globalThis.String(object.finishTimeMillis) : "0",
      finishTime: isSet(object.finishTime) ? fromJsonTimestamp(object.finishTime) : undefined,
      anomalyReport: isSet(object.anomalyReport)
        ? BuildFinished_AnomalyReport.fromJSON(object.anomalyReport)
        : undefined,
      failureDetail: isSet(object.failureDetail) ? FailureDetail.fromJSON(object.failureDetail) : undefined,
    };
  },

  toJSON(message: BuildFinished): unknown {
    const obj: any = {};
    if (message.overallSuccess !== false) {
      obj.overallSuccess = message.overallSuccess;
    }
    if (message.exitCode !== undefined) {
      obj.exitCode = BuildFinished_ExitCode.toJSON(message.exitCode);
    }
    if (message.finishTimeMillis !== "0") {
      obj.finishTimeMillis = message.finishTimeMillis;
    }
    if (message.finishTime !== undefined) {
      obj.finishTime = message.finishTime.toISOString();
    }
    if (message.anomalyReport !== undefined) {
      obj.anomalyReport = BuildFinished_AnomalyReport.toJSON(message.anomalyReport);
    }
    if (message.failureDetail !== undefined) {
      obj.failureDetail = FailureDetail.toJSON(message.failureDetail);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildFinished>, I>>(base?: I): BuildFinished {
    return BuildFinished.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildFinished>, I>>(object: I): BuildFinished {
    const message = createBaseBuildFinished();
    message.overallSuccess = object.overallSuccess ?? false;
    message.exitCode = (object.exitCode !== undefined && object.exitCode !== null)
      ? BuildFinished_ExitCode.fromPartial(object.exitCode)
      : undefined;
    message.finishTimeMillis = object.finishTimeMillis ?? "0";
    message.finishTime = object.finishTime ?? undefined;
    message.anomalyReport = (object.anomalyReport !== undefined && object.anomalyReport !== null)
      ? BuildFinished_AnomalyReport.fromPartial(object.anomalyReport)
      : undefined;
    message.failureDetail = (object.failureDetail !== undefined && object.failureDetail !== null)
      ? FailureDetail.fromPartial(object.failureDetail)
      : undefined;
    return message;
  },
};

function createBaseBuildFinished_ExitCode(): BuildFinished_ExitCode {
  return { name: "", code: 0 };
}

export const BuildFinished_ExitCode: MessageFns<BuildFinished_ExitCode> = {
  encode(message: BuildFinished_ExitCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.code !== 0) {
      writer.uint32(16).int32(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildFinished_ExitCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildFinished_ExitCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildFinished_ExitCode {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
    };
  },

  toJSON(message: BuildFinished_ExitCode): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildFinished_ExitCode>, I>>(base?: I): BuildFinished_ExitCode {
    return BuildFinished_ExitCode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildFinished_ExitCode>, I>>(object: I): BuildFinished_ExitCode {
    const message = createBaseBuildFinished_ExitCode();
    message.name = object.name ?? "";
    message.code = object.code ?? 0;
    return message;
  },
};

function createBaseBuildFinished_AnomalyReport(): BuildFinished_AnomalyReport {
  return { wasSuspended: false };
}

export const BuildFinished_AnomalyReport: MessageFns<BuildFinished_AnomalyReport> = {
  encode(message: BuildFinished_AnomalyReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wasSuspended !== false) {
      writer.uint32(8).bool(message.wasSuspended);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildFinished_AnomalyReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildFinished_AnomalyReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.wasSuspended = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildFinished_AnomalyReport {
    return { wasSuspended: isSet(object.wasSuspended) ? globalThis.Boolean(object.wasSuspended) : false };
  },

  toJSON(message: BuildFinished_AnomalyReport): unknown {
    const obj: any = {};
    if (message.wasSuspended !== false) {
      obj.wasSuspended = message.wasSuspended;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildFinished_AnomalyReport>, I>>(base?: I): BuildFinished_AnomalyReport {
    return BuildFinished_AnomalyReport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildFinished_AnomalyReport>, I>>(object: I): BuildFinished_AnomalyReport {
    const message = createBaseBuildFinished_AnomalyReport();
    message.wasSuspended = object.wasSuspended ?? false;
    return message;
  },
};

function createBaseBuildMetrics(): BuildMetrics {
  return {
    actionSummary: undefined,
    memoryMetrics: undefined,
    targetMetrics: undefined,
    packageMetrics: undefined,
    timingMetrics: undefined,
    cumulativeMetrics: undefined,
    artifactMetrics: undefined,
    buildGraphMetrics: undefined,
    workerMetrics: [],
    networkMetrics: undefined,
    workerPoolMetrics: undefined,
    dynamicExecutionMetrics: undefined,
    remoteAnalysisCacheStatistics: undefined,
  };
}

export const BuildMetrics: MessageFns<BuildMetrics> = {
  encode(message: BuildMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionSummary !== undefined) {
      BuildMetrics_ActionSummary.encode(message.actionSummary, writer.uint32(10).fork()).join();
    }
    if (message.memoryMetrics !== undefined) {
      BuildMetrics_MemoryMetrics.encode(message.memoryMetrics, writer.uint32(18).fork()).join();
    }
    if (message.targetMetrics !== undefined) {
      BuildMetrics_TargetMetrics.encode(message.targetMetrics, writer.uint32(26).fork()).join();
    }
    if (message.packageMetrics !== undefined) {
      BuildMetrics_PackageMetrics.encode(message.packageMetrics, writer.uint32(34).fork()).join();
    }
    if (message.timingMetrics !== undefined) {
      BuildMetrics_TimingMetrics.encode(message.timingMetrics, writer.uint32(42).fork()).join();
    }
    if (message.cumulativeMetrics !== undefined) {
      BuildMetrics_CumulativeMetrics.encode(message.cumulativeMetrics, writer.uint32(50).fork()).join();
    }
    if (message.artifactMetrics !== undefined) {
      BuildMetrics_ArtifactMetrics.encode(message.artifactMetrics, writer.uint32(58).fork()).join();
    }
    if (message.buildGraphMetrics !== undefined) {
      BuildMetrics_BuildGraphMetrics.encode(message.buildGraphMetrics, writer.uint32(66).fork()).join();
    }
    for (const v of message.workerMetrics) {
      BuildMetrics_WorkerMetrics.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.networkMetrics !== undefined) {
      BuildMetrics_NetworkMetrics.encode(message.networkMetrics, writer.uint32(82).fork()).join();
    }
    if (message.workerPoolMetrics !== undefined) {
      BuildMetrics_WorkerPoolMetrics.encode(message.workerPoolMetrics, writer.uint32(90).fork()).join();
    }
    if (message.dynamicExecutionMetrics !== undefined) {
      BuildMetrics_DynamicExecutionMetrics.encode(message.dynamicExecutionMetrics, writer.uint32(98).fork()).join();
    }
    if (message.remoteAnalysisCacheStatistics !== undefined) {
      BuildMetrics_RemoteAnalysisCacheStatistics.encode(
        message.remoteAnalysisCacheStatistics,
        writer.uint32(106).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actionSummary = BuildMetrics_ActionSummary.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memoryMetrics = BuildMetrics_MemoryMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetMetrics = BuildMetrics_TargetMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.packageMetrics = BuildMetrics_PackageMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.timingMetrics = BuildMetrics_TimingMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cumulativeMetrics = BuildMetrics_CumulativeMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.artifactMetrics = BuildMetrics_ArtifactMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.buildGraphMetrics = BuildMetrics_BuildGraphMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.workerMetrics.push(BuildMetrics_WorkerMetrics.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.networkMetrics = BuildMetrics_NetworkMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.workerPoolMetrics = BuildMetrics_WorkerPoolMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.dynamicExecutionMetrics = BuildMetrics_DynamicExecutionMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.remoteAnalysisCacheStatistics = BuildMetrics_RemoteAnalysisCacheStatistics.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics {
    return {
      actionSummary: isSet(object.actionSummary)
        ? BuildMetrics_ActionSummary.fromJSON(object.actionSummary)
        : undefined,
      memoryMetrics: isSet(object.memoryMetrics)
        ? BuildMetrics_MemoryMetrics.fromJSON(object.memoryMetrics)
        : undefined,
      targetMetrics: isSet(object.targetMetrics)
        ? BuildMetrics_TargetMetrics.fromJSON(object.targetMetrics)
        : undefined,
      packageMetrics: isSet(object.packageMetrics)
        ? BuildMetrics_PackageMetrics.fromJSON(object.packageMetrics)
        : undefined,
      timingMetrics: isSet(object.timingMetrics)
        ? BuildMetrics_TimingMetrics.fromJSON(object.timingMetrics)
        : undefined,
      cumulativeMetrics: isSet(object.cumulativeMetrics)
        ? BuildMetrics_CumulativeMetrics.fromJSON(object.cumulativeMetrics)
        : undefined,
      artifactMetrics: isSet(object.artifactMetrics)
        ? BuildMetrics_ArtifactMetrics.fromJSON(object.artifactMetrics)
        : undefined,
      buildGraphMetrics: isSet(object.buildGraphMetrics)
        ? BuildMetrics_BuildGraphMetrics.fromJSON(object.buildGraphMetrics)
        : undefined,
      workerMetrics: globalThis.Array.isArray(object?.workerMetrics)
        ? object.workerMetrics.map((e: any) => BuildMetrics_WorkerMetrics.fromJSON(e))
        : [],
      networkMetrics: isSet(object.networkMetrics)
        ? BuildMetrics_NetworkMetrics.fromJSON(object.networkMetrics)
        : undefined,
      workerPoolMetrics: isSet(object.workerPoolMetrics)
        ? BuildMetrics_WorkerPoolMetrics.fromJSON(object.workerPoolMetrics)
        : undefined,
      dynamicExecutionMetrics: isSet(object.dynamicExecutionMetrics)
        ? BuildMetrics_DynamicExecutionMetrics.fromJSON(object.dynamicExecutionMetrics)
        : undefined,
      remoteAnalysisCacheStatistics: isSet(object.remoteAnalysisCacheStatistics)
        ? BuildMetrics_RemoteAnalysisCacheStatistics.fromJSON(object.remoteAnalysisCacheStatistics)
        : undefined,
    };
  },

  toJSON(message: BuildMetrics): unknown {
    const obj: any = {};
    if (message.actionSummary !== undefined) {
      obj.actionSummary = BuildMetrics_ActionSummary.toJSON(message.actionSummary);
    }
    if (message.memoryMetrics !== undefined) {
      obj.memoryMetrics = BuildMetrics_MemoryMetrics.toJSON(message.memoryMetrics);
    }
    if (message.targetMetrics !== undefined) {
      obj.targetMetrics = BuildMetrics_TargetMetrics.toJSON(message.targetMetrics);
    }
    if (message.packageMetrics !== undefined) {
      obj.packageMetrics = BuildMetrics_PackageMetrics.toJSON(message.packageMetrics);
    }
    if (message.timingMetrics !== undefined) {
      obj.timingMetrics = BuildMetrics_TimingMetrics.toJSON(message.timingMetrics);
    }
    if (message.cumulativeMetrics !== undefined) {
      obj.cumulativeMetrics = BuildMetrics_CumulativeMetrics.toJSON(message.cumulativeMetrics);
    }
    if (message.artifactMetrics !== undefined) {
      obj.artifactMetrics = BuildMetrics_ArtifactMetrics.toJSON(message.artifactMetrics);
    }
    if (message.buildGraphMetrics !== undefined) {
      obj.buildGraphMetrics = BuildMetrics_BuildGraphMetrics.toJSON(message.buildGraphMetrics);
    }
    if (message.workerMetrics?.length) {
      obj.workerMetrics = message.workerMetrics.map((e) => BuildMetrics_WorkerMetrics.toJSON(e));
    }
    if (message.networkMetrics !== undefined) {
      obj.networkMetrics = BuildMetrics_NetworkMetrics.toJSON(message.networkMetrics);
    }
    if (message.workerPoolMetrics !== undefined) {
      obj.workerPoolMetrics = BuildMetrics_WorkerPoolMetrics.toJSON(message.workerPoolMetrics);
    }
    if (message.dynamicExecutionMetrics !== undefined) {
      obj.dynamicExecutionMetrics = BuildMetrics_DynamicExecutionMetrics.toJSON(message.dynamicExecutionMetrics);
    }
    if (message.remoteAnalysisCacheStatistics !== undefined) {
      obj.remoteAnalysisCacheStatistics = BuildMetrics_RemoteAnalysisCacheStatistics.toJSON(
        message.remoteAnalysisCacheStatistics,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics>, I>>(base?: I): BuildMetrics {
    return BuildMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics>, I>>(object: I): BuildMetrics {
    const message = createBaseBuildMetrics();
    message.actionSummary = (object.actionSummary !== undefined && object.actionSummary !== null)
      ? BuildMetrics_ActionSummary.fromPartial(object.actionSummary)
      : undefined;
    message.memoryMetrics = (object.memoryMetrics !== undefined && object.memoryMetrics !== null)
      ? BuildMetrics_MemoryMetrics.fromPartial(object.memoryMetrics)
      : undefined;
    message.targetMetrics = (object.targetMetrics !== undefined && object.targetMetrics !== null)
      ? BuildMetrics_TargetMetrics.fromPartial(object.targetMetrics)
      : undefined;
    message.packageMetrics = (object.packageMetrics !== undefined && object.packageMetrics !== null)
      ? BuildMetrics_PackageMetrics.fromPartial(object.packageMetrics)
      : undefined;
    message.timingMetrics = (object.timingMetrics !== undefined && object.timingMetrics !== null)
      ? BuildMetrics_TimingMetrics.fromPartial(object.timingMetrics)
      : undefined;
    message.cumulativeMetrics = (object.cumulativeMetrics !== undefined && object.cumulativeMetrics !== null)
      ? BuildMetrics_CumulativeMetrics.fromPartial(object.cumulativeMetrics)
      : undefined;
    message.artifactMetrics = (object.artifactMetrics !== undefined && object.artifactMetrics !== null)
      ? BuildMetrics_ArtifactMetrics.fromPartial(object.artifactMetrics)
      : undefined;
    message.buildGraphMetrics = (object.buildGraphMetrics !== undefined && object.buildGraphMetrics !== null)
      ? BuildMetrics_BuildGraphMetrics.fromPartial(object.buildGraphMetrics)
      : undefined;
    message.workerMetrics = object.workerMetrics?.map((e) => BuildMetrics_WorkerMetrics.fromPartial(e)) || [];
    message.networkMetrics = (object.networkMetrics !== undefined && object.networkMetrics !== null)
      ? BuildMetrics_NetworkMetrics.fromPartial(object.networkMetrics)
      : undefined;
    message.workerPoolMetrics = (object.workerPoolMetrics !== undefined && object.workerPoolMetrics !== null)
      ? BuildMetrics_WorkerPoolMetrics.fromPartial(object.workerPoolMetrics)
      : undefined;
    message.dynamicExecutionMetrics =
      (object.dynamicExecutionMetrics !== undefined && object.dynamicExecutionMetrics !== null)
        ? BuildMetrics_DynamicExecutionMetrics.fromPartial(object.dynamicExecutionMetrics)
        : undefined;
    message.remoteAnalysisCacheStatistics =
      (object.remoteAnalysisCacheStatistics !== undefined && object.remoteAnalysisCacheStatistics !== null)
        ? BuildMetrics_RemoteAnalysisCacheStatistics.fromPartial(object.remoteAnalysisCacheStatistics)
        : undefined;
    return message;
  },
};

function createBaseBuildMetrics_ActionSummary(): BuildMetrics_ActionSummary {
  return {
    actionsCreated: "0",
    actionsCreatedNotIncludingAspects: "0",
    actionsExecuted: "0",
    actionData: [],
    remoteCacheHits: "0",
    runnerCount: [],
    actionCacheStatistics: undefined,
  };
}

export const BuildMetrics_ActionSummary: MessageFns<BuildMetrics_ActionSummary> = {
  encode(message: BuildMetrics_ActionSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionsCreated !== "0") {
      writer.uint32(8).int64(message.actionsCreated);
    }
    if (message.actionsCreatedNotIncludingAspects !== "0") {
      writer.uint32(24).int64(message.actionsCreatedNotIncludingAspects);
    }
    if (message.actionsExecuted !== "0") {
      writer.uint32(16).int64(message.actionsExecuted);
    }
    for (const v of message.actionData) {
      BuildMetrics_ActionSummary_ActionData.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.remoteCacheHits !== "0") {
      writer.uint32(40).int64(message.remoteCacheHits);
    }
    for (const v of message.runnerCount) {
      BuildMetrics_ActionSummary_RunnerCount.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.actionCacheStatistics !== undefined) {
      ActionCacheStatistics.encode(message.actionCacheStatistics, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_ActionSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_ActionSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionsCreated = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.actionsCreatedNotIncludingAspects = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actionsExecuted = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actionData.push(BuildMetrics_ActionSummary_ActionData.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.remoteCacheHits = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.runnerCount.push(BuildMetrics_ActionSummary_RunnerCount.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.actionCacheStatistics = ActionCacheStatistics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_ActionSummary {
    return {
      actionsCreated: isSet(object.actionsCreated) ? globalThis.String(object.actionsCreated) : "0",
      actionsCreatedNotIncludingAspects: isSet(object.actionsCreatedNotIncludingAspects)
        ? globalThis.String(object.actionsCreatedNotIncludingAspects)
        : "0",
      actionsExecuted: isSet(object.actionsExecuted) ? globalThis.String(object.actionsExecuted) : "0",
      actionData: globalThis.Array.isArray(object?.actionData)
        ? object.actionData.map((e: any) => BuildMetrics_ActionSummary_ActionData.fromJSON(e))
        : [],
      remoteCacheHits: isSet(object.remoteCacheHits) ? globalThis.String(object.remoteCacheHits) : "0",
      runnerCount: globalThis.Array.isArray(object?.runnerCount)
        ? object.runnerCount.map((e: any) => BuildMetrics_ActionSummary_RunnerCount.fromJSON(e))
        : [],
      actionCacheStatistics: isSet(object.actionCacheStatistics)
        ? ActionCacheStatistics.fromJSON(object.actionCacheStatistics)
        : undefined,
    };
  },

  toJSON(message: BuildMetrics_ActionSummary): unknown {
    const obj: any = {};
    if (message.actionsCreated !== "0") {
      obj.actionsCreated = message.actionsCreated;
    }
    if (message.actionsCreatedNotIncludingAspects !== "0") {
      obj.actionsCreatedNotIncludingAspects = message.actionsCreatedNotIncludingAspects;
    }
    if (message.actionsExecuted !== "0") {
      obj.actionsExecuted = message.actionsExecuted;
    }
    if (message.actionData?.length) {
      obj.actionData = message.actionData.map((e) => BuildMetrics_ActionSummary_ActionData.toJSON(e));
    }
    if (message.remoteCacheHits !== "0") {
      obj.remoteCacheHits = message.remoteCacheHits;
    }
    if (message.runnerCount?.length) {
      obj.runnerCount = message.runnerCount.map((e) => BuildMetrics_ActionSummary_RunnerCount.toJSON(e));
    }
    if (message.actionCacheStatistics !== undefined) {
      obj.actionCacheStatistics = ActionCacheStatistics.toJSON(message.actionCacheStatistics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_ActionSummary>, I>>(base?: I): BuildMetrics_ActionSummary {
    return BuildMetrics_ActionSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_ActionSummary>, I>>(object: I): BuildMetrics_ActionSummary {
    const message = createBaseBuildMetrics_ActionSummary();
    message.actionsCreated = object.actionsCreated ?? "0";
    message.actionsCreatedNotIncludingAspects = object.actionsCreatedNotIncludingAspects ?? "0";
    message.actionsExecuted = object.actionsExecuted ?? "0";
    message.actionData = object.actionData?.map((e) => BuildMetrics_ActionSummary_ActionData.fromPartial(e)) || [];
    message.remoteCacheHits = object.remoteCacheHits ?? "0";
    message.runnerCount = object.runnerCount?.map((e) => BuildMetrics_ActionSummary_RunnerCount.fromPartial(e)) || [];
    message.actionCacheStatistics =
      (object.actionCacheStatistics !== undefined && object.actionCacheStatistics !== null)
        ? ActionCacheStatistics.fromPartial(object.actionCacheStatistics)
        : undefined;
    return message;
  },
};

function createBaseBuildMetrics_ActionSummary_ActionData(): BuildMetrics_ActionSummary_ActionData {
  return {
    mnemonic: "",
    actionsExecuted: "0",
    firstStartedMs: "0",
    lastEndedMs: "0",
    systemTime: undefined,
    userTime: undefined,
    actionsCreated: "0",
  };
}

export const BuildMetrics_ActionSummary_ActionData: MessageFns<BuildMetrics_ActionSummary_ActionData> = {
  encode(message: BuildMetrics_ActionSummary_ActionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mnemonic !== "") {
      writer.uint32(10).string(message.mnemonic);
    }
    if (message.actionsExecuted !== "0") {
      writer.uint32(16).int64(message.actionsExecuted);
    }
    if (message.firstStartedMs !== "0") {
      writer.uint32(24).int64(message.firstStartedMs);
    }
    if (message.lastEndedMs !== "0") {
      writer.uint32(32).int64(message.lastEndedMs);
    }
    if (message.systemTime !== undefined) {
      Duration.encode(message.systemTime, writer.uint32(42).fork()).join();
    }
    if (message.userTime !== undefined) {
      Duration.encode(message.userTime, writer.uint32(50).fork()).join();
    }
    if (message.actionsCreated !== "0") {
      writer.uint32(56).int64(message.actionsCreated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_ActionSummary_ActionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_ActionSummary_ActionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mnemonic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actionsExecuted = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.firstStartedMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastEndedMs = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.systemTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userTime = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.actionsCreated = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_ActionSummary_ActionData {
    return {
      mnemonic: isSet(object.mnemonic) ? globalThis.String(object.mnemonic) : "",
      actionsExecuted: isSet(object.actionsExecuted) ? globalThis.String(object.actionsExecuted) : "0",
      firstStartedMs: isSet(object.firstStartedMs) ? globalThis.String(object.firstStartedMs) : "0",
      lastEndedMs: isSet(object.lastEndedMs) ? globalThis.String(object.lastEndedMs) : "0",
      systemTime: isSet(object.systemTime) ? Duration.fromJSON(object.systemTime) : undefined,
      userTime: isSet(object.userTime) ? Duration.fromJSON(object.userTime) : undefined,
      actionsCreated: isSet(object.actionsCreated) ? globalThis.String(object.actionsCreated) : "0",
    };
  },

  toJSON(message: BuildMetrics_ActionSummary_ActionData): unknown {
    const obj: any = {};
    if (message.mnemonic !== "") {
      obj.mnemonic = message.mnemonic;
    }
    if (message.actionsExecuted !== "0") {
      obj.actionsExecuted = message.actionsExecuted;
    }
    if (message.firstStartedMs !== "0") {
      obj.firstStartedMs = message.firstStartedMs;
    }
    if (message.lastEndedMs !== "0") {
      obj.lastEndedMs = message.lastEndedMs;
    }
    if (message.systemTime !== undefined) {
      obj.systemTime = Duration.toJSON(message.systemTime);
    }
    if (message.userTime !== undefined) {
      obj.userTime = Duration.toJSON(message.userTime);
    }
    if (message.actionsCreated !== "0") {
      obj.actionsCreated = message.actionsCreated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_ActionSummary_ActionData>, I>>(
    base?: I,
  ): BuildMetrics_ActionSummary_ActionData {
    return BuildMetrics_ActionSummary_ActionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_ActionSummary_ActionData>, I>>(
    object: I,
  ): BuildMetrics_ActionSummary_ActionData {
    const message = createBaseBuildMetrics_ActionSummary_ActionData();
    message.mnemonic = object.mnemonic ?? "";
    message.actionsExecuted = object.actionsExecuted ?? "0";
    message.firstStartedMs = object.firstStartedMs ?? "0";
    message.lastEndedMs = object.lastEndedMs ?? "0";
    message.systemTime = (object.systemTime !== undefined && object.systemTime !== null)
      ? Duration.fromPartial(object.systemTime)
      : undefined;
    message.userTime = (object.userTime !== undefined && object.userTime !== null)
      ? Duration.fromPartial(object.userTime)
      : undefined;
    message.actionsCreated = object.actionsCreated ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_ActionSummary_RunnerCount(): BuildMetrics_ActionSummary_RunnerCount {
  return { name: "", count: 0, execKind: "" };
}

export const BuildMetrics_ActionSummary_RunnerCount: MessageFns<BuildMetrics_ActionSummary_RunnerCount> = {
  encode(message: BuildMetrics_ActionSummary_RunnerCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.execKind !== "") {
      writer.uint32(26).string(message.execKind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_ActionSummary_RunnerCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_ActionSummary_RunnerCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.execKind = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_ActionSummary_RunnerCount {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      execKind: isSet(object.execKind) ? globalThis.String(object.execKind) : "",
    };
  },

  toJSON(message: BuildMetrics_ActionSummary_RunnerCount): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.execKind !== "") {
      obj.execKind = message.execKind;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_ActionSummary_RunnerCount>, I>>(
    base?: I,
  ): BuildMetrics_ActionSummary_RunnerCount {
    return BuildMetrics_ActionSummary_RunnerCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_ActionSummary_RunnerCount>, I>>(
    object: I,
  ): BuildMetrics_ActionSummary_RunnerCount {
    const message = createBaseBuildMetrics_ActionSummary_RunnerCount();
    message.name = object.name ?? "";
    message.count = object.count ?? 0;
    message.execKind = object.execKind ?? "";
    return message;
  },
};

function createBaseBuildMetrics_MemoryMetrics(): BuildMetrics_MemoryMetrics {
  return {
    usedHeapSizePostBuild: "0",
    peakPostGcHeapSize: "0",
    peakPostGcTenuredSpaceHeapSize: "0",
    garbageMetrics: [],
  };
}

export const BuildMetrics_MemoryMetrics: MessageFns<BuildMetrics_MemoryMetrics> = {
  encode(message: BuildMetrics_MemoryMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.usedHeapSizePostBuild !== "0") {
      writer.uint32(8).int64(message.usedHeapSizePostBuild);
    }
    if (message.peakPostGcHeapSize !== "0") {
      writer.uint32(16).int64(message.peakPostGcHeapSize);
    }
    if (message.peakPostGcTenuredSpaceHeapSize !== "0") {
      writer.uint32(32).int64(message.peakPostGcTenuredSpaceHeapSize);
    }
    for (const v of message.garbageMetrics) {
      BuildMetrics_MemoryMetrics_GarbageMetrics.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_MemoryMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_MemoryMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.usedHeapSizePostBuild = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.peakPostGcHeapSize = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.peakPostGcTenuredSpaceHeapSize = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.garbageMetrics.push(BuildMetrics_MemoryMetrics_GarbageMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_MemoryMetrics {
    return {
      usedHeapSizePostBuild: isSet(object.usedHeapSizePostBuild)
        ? globalThis.String(object.usedHeapSizePostBuild)
        : "0",
      peakPostGcHeapSize: isSet(object.peakPostGcHeapSize) ? globalThis.String(object.peakPostGcHeapSize) : "0",
      peakPostGcTenuredSpaceHeapSize: isSet(object.peakPostGcTenuredSpaceHeapSize)
        ? globalThis.String(object.peakPostGcTenuredSpaceHeapSize)
        : "0",
      garbageMetrics: globalThis.Array.isArray(object?.garbageMetrics)
        ? object.garbageMetrics.map((e: any) => BuildMetrics_MemoryMetrics_GarbageMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildMetrics_MemoryMetrics): unknown {
    const obj: any = {};
    if (message.usedHeapSizePostBuild !== "0") {
      obj.usedHeapSizePostBuild = message.usedHeapSizePostBuild;
    }
    if (message.peakPostGcHeapSize !== "0") {
      obj.peakPostGcHeapSize = message.peakPostGcHeapSize;
    }
    if (message.peakPostGcTenuredSpaceHeapSize !== "0") {
      obj.peakPostGcTenuredSpaceHeapSize = message.peakPostGcTenuredSpaceHeapSize;
    }
    if (message.garbageMetrics?.length) {
      obj.garbageMetrics = message.garbageMetrics.map((e) => BuildMetrics_MemoryMetrics_GarbageMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_MemoryMetrics>, I>>(base?: I): BuildMetrics_MemoryMetrics {
    return BuildMetrics_MemoryMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_MemoryMetrics>, I>>(object: I): BuildMetrics_MemoryMetrics {
    const message = createBaseBuildMetrics_MemoryMetrics();
    message.usedHeapSizePostBuild = object.usedHeapSizePostBuild ?? "0";
    message.peakPostGcHeapSize = object.peakPostGcHeapSize ?? "0";
    message.peakPostGcTenuredSpaceHeapSize = object.peakPostGcTenuredSpaceHeapSize ?? "0";
    message.garbageMetrics =
      object.garbageMetrics?.map((e) => BuildMetrics_MemoryMetrics_GarbageMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuildMetrics_MemoryMetrics_GarbageMetrics(): BuildMetrics_MemoryMetrics_GarbageMetrics {
  return { type: "", garbageCollected: "0" };
}

export const BuildMetrics_MemoryMetrics_GarbageMetrics: MessageFns<BuildMetrics_MemoryMetrics_GarbageMetrics> = {
  encode(message: BuildMetrics_MemoryMetrics_GarbageMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.garbageCollected !== "0") {
      writer.uint32(16).int64(message.garbageCollected);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_MemoryMetrics_GarbageMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_MemoryMetrics_GarbageMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.garbageCollected = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_MemoryMetrics_GarbageMetrics {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      garbageCollected: isSet(object.garbageCollected) ? globalThis.String(object.garbageCollected) : "0",
    };
  },

  toJSON(message: BuildMetrics_MemoryMetrics_GarbageMetrics): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.garbageCollected !== "0") {
      obj.garbageCollected = message.garbageCollected;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_MemoryMetrics_GarbageMetrics>, I>>(
    base?: I,
  ): BuildMetrics_MemoryMetrics_GarbageMetrics {
    return BuildMetrics_MemoryMetrics_GarbageMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_MemoryMetrics_GarbageMetrics>, I>>(
    object: I,
  ): BuildMetrics_MemoryMetrics_GarbageMetrics {
    const message = createBaseBuildMetrics_MemoryMetrics_GarbageMetrics();
    message.type = object.type ?? "";
    message.garbageCollected = object.garbageCollected ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_TargetMetrics(): BuildMetrics_TargetMetrics {
  return { targetsLoaded: "0", targetsConfigured: "0", targetsConfiguredNotIncludingAspects: "0" };
}

export const BuildMetrics_TargetMetrics: MessageFns<BuildMetrics_TargetMetrics> = {
  encode(message: BuildMetrics_TargetMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetsLoaded !== "0") {
      writer.uint32(8).int64(message.targetsLoaded);
    }
    if (message.targetsConfigured !== "0") {
      writer.uint32(16).int64(message.targetsConfigured);
    }
    if (message.targetsConfiguredNotIncludingAspects !== "0") {
      writer.uint32(24).int64(message.targetsConfiguredNotIncludingAspects);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_TargetMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_TargetMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.targetsLoaded = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.targetsConfigured = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetsConfiguredNotIncludingAspects = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_TargetMetrics {
    return {
      targetsLoaded: isSet(object.targetsLoaded) ? globalThis.String(object.targetsLoaded) : "0",
      targetsConfigured: isSet(object.targetsConfigured) ? globalThis.String(object.targetsConfigured) : "0",
      targetsConfiguredNotIncludingAspects: isSet(object.targetsConfiguredNotIncludingAspects)
        ? globalThis.String(object.targetsConfiguredNotIncludingAspects)
        : "0",
    };
  },

  toJSON(message: BuildMetrics_TargetMetrics): unknown {
    const obj: any = {};
    if (message.targetsLoaded !== "0") {
      obj.targetsLoaded = message.targetsLoaded;
    }
    if (message.targetsConfigured !== "0") {
      obj.targetsConfigured = message.targetsConfigured;
    }
    if (message.targetsConfiguredNotIncludingAspects !== "0") {
      obj.targetsConfiguredNotIncludingAspects = message.targetsConfiguredNotIncludingAspects;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_TargetMetrics>, I>>(base?: I): BuildMetrics_TargetMetrics {
    return BuildMetrics_TargetMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_TargetMetrics>, I>>(object: I): BuildMetrics_TargetMetrics {
    const message = createBaseBuildMetrics_TargetMetrics();
    message.targetsLoaded = object.targetsLoaded ?? "0";
    message.targetsConfigured = object.targetsConfigured ?? "0";
    message.targetsConfiguredNotIncludingAspects = object.targetsConfiguredNotIncludingAspects ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_PackageMetrics(): BuildMetrics_PackageMetrics {
  return { packagesLoaded: "0", packageLoadMetrics: [] };
}

export const BuildMetrics_PackageMetrics: MessageFns<BuildMetrics_PackageMetrics> = {
  encode(message: BuildMetrics_PackageMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packagesLoaded !== "0") {
      writer.uint32(8).int64(message.packagesLoaded);
    }
    for (const v of message.packageLoadMetrics) {
      PackageLoadMetrics.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_PackageMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_PackageMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.packagesLoaded = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.packageLoadMetrics.push(PackageLoadMetrics.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_PackageMetrics {
    return {
      packagesLoaded: isSet(object.packagesLoaded) ? globalThis.String(object.packagesLoaded) : "0",
      packageLoadMetrics: globalThis.Array.isArray(object?.packageLoadMetrics)
        ? object.packageLoadMetrics.map((e: any) => PackageLoadMetrics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildMetrics_PackageMetrics): unknown {
    const obj: any = {};
    if (message.packagesLoaded !== "0") {
      obj.packagesLoaded = message.packagesLoaded;
    }
    if (message.packageLoadMetrics?.length) {
      obj.packageLoadMetrics = message.packageLoadMetrics.map((e) => PackageLoadMetrics.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_PackageMetrics>, I>>(base?: I): BuildMetrics_PackageMetrics {
    return BuildMetrics_PackageMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_PackageMetrics>, I>>(object: I): BuildMetrics_PackageMetrics {
    const message = createBaseBuildMetrics_PackageMetrics();
    message.packagesLoaded = object.packagesLoaded ?? "0";
    message.packageLoadMetrics = object.packageLoadMetrics?.map((e) => PackageLoadMetrics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuildMetrics_TimingMetrics(): BuildMetrics_TimingMetrics {
  return {
    cpuTimeInMs: "0",
    wallTimeInMs: "0",
    analysisPhaseTimeInMs: "0",
    executionPhaseTimeInMs: "0",
    actionsExecutionStartInMs: "0",
  };
}

export const BuildMetrics_TimingMetrics: MessageFns<BuildMetrics_TimingMetrics> = {
  encode(message: BuildMetrics_TimingMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuTimeInMs !== "0") {
      writer.uint32(8).int64(message.cpuTimeInMs);
    }
    if (message.wallTimeInMs !== "0") {
      writer.uint32(16).int64(message.wallTimeInMs);
    }
    if (message.analysisPhaseTimeInMs !== "0") {
      writer.uint32(24).int64(message.analysisPhaseTimeInMs);
    }
    if (message.executionPhaseTimeInMs !== "0") {
      writer.uint32(32).int64(message.executionPhaseTimeInMs);
    }
    if (message.actionsExecutionStartInMs !== "0") {
      writer.uint32(40).int64(message.actionsExecutionStartInMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_TimingMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_TimingMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cpuTimeInMs = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.wallTimeInMs = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.analysisPhaseTimeInMs = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.executionPhaseTimeInMs = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.actionsExecutionStartInMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_TimingMetrics {
    return {
      cpuTimeInMs: isSet(object.cpuTimeInMs) ? globalThis.String(object.cpuTimeInMs) : "0",
      wallTimeInMs: isSet(object.wallTimeInMs) ? globalThis.String(object.wallTimeInMs) : "0",
      analysisPhaseTimeInMs: isSet(object.analysisPhaseTimeInMs)
        ? globalThis.String(object.analysisPhaseTimeInMs)
        : "0",
      executionPhaseTimeInMs: isSet(object.executionPhaseTimeInMs)
        ? globalThis.String(object.executionPhaseTimeInMs)
        : "0",
      actionsExecutionStartInMs: isSet(object.actionsExecutionStartInMs)
        ? globalThis.String(object.actionsExecutionStartInMs)
        : "0",
    };
  },

  toJSON(message: BuildMetrics_TimingMetrics): unknown {
    const obj: any = {};
    if (message.cpuTimeInMs !== "0") {
      obj.cpuTimeInMs = message.cpuTimeInMs;
    }
    if (message.wallTimeInMs !== "0") {
      obj.wallTimeInMs = message.wallTimeInMs;
    }
    if (message.analysisPhaseTimeInMs !== "0") {
      obj.analysisPhaseTimeInMs = message.analysisPhaseTimeInMs;
    }
    if (message.executionPhaseTimeInMs !== "0") {
      obj.executionPhaseTimeInMs = message.executionPhaseTimeInMs;
    }
    if (message.actionsExecutionStartInMs !== "0") {
      obj.actionsExecutionStartInMs = message.actionsExecutionStartInMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_TimingMetrics>, I>>(base?: I): BuildMetrics_TimingMetrics {
    return BuildMetrics_TimingMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_TimingMetrics>, I>>(object: I): BuildMetrics_TimingMetrics {
    const message = createBaseBuildMetrics_TimingMetrics();
    message.cpuTimeInMs = object.cpuTimeInMs ?? "0";
    message.wallTimeInMs = object.wallTimeInMs ?? "0";
    message.analysisPhaseTimeInMs = object.analysisPhaseTimeInMs ?? "0";
    message.executionPhaseTimeInMs = object.executionPhaseTimeInMs ?? "0";
    message.actionsExecutionStartInMs = object.actionsExecutionStartInMs ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_CumulativeMetrics(): BuildMetrics_CumulativeMetrics {
  return { numAnalyses: 0, numBuilds: 0 };
}

export const BuildMetrics_CumulativeMetrics: MessageFns<BuildMetrics_CumulativeMetrics> = {
  encode(message: BuildMetrics_CumulativeMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numAnalyses !== 0) {
      writer.uint32(88).int32(message.numAnalyses);
    }
    if (message.numBuilds !== 0) {
      writer.uint32(96).int32(message.numBuilds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_CumulativeMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_CumulativeMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.numAnalyses = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.numBuilds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_CumulativeMetrics {
    return {
      numAnalyses: isSet(object.numAnalyses) ? globalThis.Number(object.numAnalyses) : 0,
      numBuilds: isSet(object.numBuilds) ? globalThis.Number(object.numBuilds) : 0,
    };
  },

  toJSON(message: BuildMetrics_CumulativeMetrics): unknown {
    const obj: any = {};
    if (message.numAnalyses !== 0) {
      obj.numAnalyses = Math.round(message.numAnalyses);
    }
    if (message.numBuilds !== 0) {
      obj.numBuilds = Math.round(message.numBuilds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_CumulativeMetrics>, I>>(base?: I): BuildMetrics_CumulativeMetrics {
    return BuildMetrics_CumulativeMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_CumulativeMetrics>, I>>(
    object: I,
  ): BuildMetrics_CumulativeMetrics {
    const message = createBaseBuildMetrics_CumulativeMetrics();
    message.numAnalyses = object.numAnalyses ?? 0;
    message.numBuilds = object.numBuilds ?? 0;
    return message;
  },
};

function createBaseBuildMetrics_ArtifactMetrics(): BuildMetrics_ArtifactMetrics {
  return {
    sourceArtifactsRead: undefined,
    outputArtifactsSeen: undefined,
    outputArtifactsFromActionCache: undefined,
    topLevelArtifacts: undefined,
  };
}

export const BuildMetrics_ArtifactMetrics: MessageFns<BuildMetrics_ArtifactMetrics> = {
  encode(message: BuildMetrics_ArtifactMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceArtifactsRead !== undefined) {
      BuildMetrics_ArtifactMetrics_FilesMetric.encode(message.sourceArtifactsRead, writer.uint32(18).fork()).join();
    }
    if (message.outputArtifactsSeen !== undefined) {
      BuildMetrics_ArtifactMetrics_FilesMetric.encode(message.outputArtifactsSeen, writer.uint32(26).fork()).join();
    }
    if (message.outputArtifactsFromActionCache !== undefined) {
      BuildMetrics_ArtifactMetrics_FilesMetric.encode(message.outputArtifactsFromActionCache, writer.uint32(34).fork())
        .join();
    }
    if (message.topLevelArtifacts !== undefined) {
      BuildMetrics_ArtifactMetrics_FilesMetric.encode(message.topLevelArtifacts, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_ArtifactMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_ArtifactMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceArtifactsRead = BuildMetrics_ArtifactMetrics_FilesMetric.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outputArtifactsSeen = BuildMetrics_ArtifactMetrics_FilesMetric.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputArtifactsFromActionCache = BuildMetrics_ArtifactMetrics_FilesMetric.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.topLevelArtifacts = BuildMetrics_ArtifactMetrics_FilesMetric.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_ArtifactMetrics {
    return {
      sourceArtifactsRead: isSet(object.sourceArtifactsRead)
        ? BuildMetrics_ArtifactMetrics_FilesMetric.fromJSON(object.sourceArtifactsRead)
        : undefined,
      outputArtifactsSeen: isSet(object.outputArtifactsSeen)
        ? BuildMetrics_ArtifactMetrics_FilesMetric.fromJSON(object.outputArtifactsSeen)
        : undefined,
      outputArtifactsFromActionCache: isSet(object.outputArtifactsFromActionCache)
        ? BuildMetrics_ArtifactMetrics_FilesMetric.fromJSON(object.outputArtifactsFromActionCache)
        : undefined,
      topLevelArtifacts: isSet(object.topLevelArtifacts)
        ? BuildMetrics_ArtifactMetrics_FilesMetric.fromJSON(object.topLevelArtifacts)
        : undefined,
    };
  },

  toJSON(message: BuildMetrics_ArtifactMetrics): unknown {
    const obj: any = {};
    if (message.sourceArtifactsRead !== undefined) {
      obj.sourceArtifactsRead = BuildMetrics_ArtifactMetrics_FilesMetric.toJSON(message.sourceArtifactsRead);
    }
    if (message.outputArtifactsSeen !== undefined) {
      obj.outputArtifactsSeen = BuildMetrics_ArtifactMetrics_FilesMetric.toJSON(message.outputArtifactsSeen);
    }
    if (message.outputArtifactsFromActionCache !== undefined) {
      obj.outputArtifactsFromActionCache = BuildMetrics_ArtifactMetrics_FilesMetric.toJSON(
        message.outputArtifactsFromActionCache,
      );
    }
    if (message.topLevelArtifacts !== undefined) {
      obj.topLevelArtifacts = BuildMetrics_ArtifactMetrics_FilesMetric.toJSON(message.topLevelArtifacts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_ArtifactMetrics>, I>>(base?: I): BuildMetrics_ArtifactMetrics {
    return BuildMetrics_ArtifactMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_ArtifactMetrics>, I>>(object: I): BuildMetrics_ArtifactMetrics {
    const message = createBaseBuildMetrics_ArtifactMetrics();
    message.sourceArtifactsRead = (object.sourceArtifactsRead !== undefined && object.sourceArtifactsRead !== null)
      ? BuildMetrics_ArtifactMetrics_FilesMetric.fromPartial(object.sourceArtifactsRead)
      : undefined;
    message.outputArtifactsSeen = (object.outputArtifactsSeen !== undefined && object.outputArtifactsSeen !== null)
      ? BuildMetrics_ArtifactMetrics_FilesMetric.fromPartial(object.outputArtifactsSeen)
      : undefined;
    message.outputArtifactsFromActionCache =
      (object.outputArtifactsFromActionCache !== undefined && object.outputArtifactsFromActionCache !== null)
        ? BuildMetrics_ArtifactMetrics_FilesMetric.fromPartial(object.outputArtifactsFromActionCache)
        : undefined;
    message.topLevelArtifacts = (object.topLevelArtifacts !== undefined && object.topLevelArtifacts !== null)
      ? BuildMetrics_ArtifactMetrics_FilesMetric.fromPartial(object.topLevelArtifacts)
      : undefined;
    return message;
  },
};

function createBaseBuildMetrics_ArtifactMetrics_FilesMetric(): BuildMetrics_ArtifactMetrics_FilesMetric {
  return { sizeInBytes: "0", count: 0 };
}

export const BuildMetrics_ArtifactMetrics_FilesMetric: MessageFns<BuildMetrics_ArtifactMetrics_FilesMetric> = {
  encode(message: BuildMetrics_ArtifactMetrics_FilesMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeInBytes !== "0") {
      writer.uint32(8).int64(message.sizeInBytes);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_ArtifactMetrics_FilesMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_ArtifactMetrics_FilesMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sizeInBytes = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_ArtifactMetrics_FilesMetric {
    return {
      sizeInBytes: isSet(object.sizeInBytes) ? globalThis.String(object.sizeInBytes) : "0",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: BuildMetrics_ArtifactMetrics_FilesMetric): unknown {
    const obj: any = {};
    if (message.sizeInBytes !== "0") {
      obj.sizeInBytes = message.sizeInBytes;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_ArtifactMetrics_FilesMetric>, I>>(
    base?: I,
  ): BuildMetrics_ArtifactMetrics_FilesMetric {
    return BuildMetrics_ArtifactMetrics_FilesMetric.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_ArtifactMetrics_FilesMetric>, I>>(
    object: I,
  ): BuildMetrics_ArtifactMetrics_FilesMetric {
    const message = createBaseBuildMetrics_ArtifactMetrics_FilesMetric();
    message.sizeInBytes = object.sizeInBytes ?? "0";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseBuildMetrics_EvaluationStat(): BuildMetrics_EvaluationStat {
  return { skyfunctionName: "", count: "0" };
}

export const BuildMetrics_EvaluationStat: MessageFns<BuildMetrics_EvaluationStat> = {
  encode(message: BuildMetrics_EvaluationStat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skyfunctionName !== "") {
      writer.uint32(10).string(message.skyfunctionName);
    }
    if (message.count !== "0") {
      writer.uint32(16).int64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_EvaluationStat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_EvaluationStat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skyfunctionName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_EvaluationStat {
    return {
      skyfunctionName: isSet(object.skyfunctionName) ? globalThis.String(object.skyfunctionName) : "",
      count: isSet(object.count) ? globalThis.String(object.count) : "0",
    };
  },

  toJSON(message: BuildMetrics_EvaluationStat): unknown {
    const obj: any = {};
    if (message.skyfunctionName !== "") {
      obj.skyfunctionName = message.skyfunctionName;
    }
    if (message.count !== "0") {
      obj.count = message.count;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_EvaluationStat>, I>>(base?: I): BuildMetrics_EvaluationStat {
    return BuildMetrics_EvaluationStat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_EvaluationStat>, I>>(object: I): BuildMetrics_EvaluationStat {
    const message = createBaseBuildMetrics_EvaluationStat();
    message.skyfunctionName = object.skyfunctionName ?? "";
    message.count = object.count ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_BuildGraphMetrics(): BuildMetrics_BuildGraphMetrics {
  return {
    actionLookupValueCount: 0,
    actionLookupValueCountNotIncludingAspects: 0,
    actionCount: 0,
    actionCountNotIncludingAspects: 0,
    inputFileConfiguredTargetCount: 0,
    outputFileConfiguredTargetCount: 0,
    otherConfiguredTargetCount: 0,
    outputArtifactCount: 0,
    postInvocationSkyframeNodeCount: 0,
    dirtiedValues: [],
    changedValues: [],
    builtValues: [],
    cleanedValues: [],
    evaluatedValues: [],
    ruleClass: [],
    aspect: [],
  };
}

export const BuildMetrics_BuildGraphMetrics: MessageFns<BuildMetrics_BuildGraphMetrics> = {
  encode(message: BuildMetrics_BuildGraphMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionLookupValueCount !== 0) {
      writer.uint32(8).int32(message.actionLookupValueCount);
    }
    if (message.actionLookupValueCountNotIncludingAspects !== 0) {
      writer.uint32(40).int32(message.actionLookupValueCountNotIncludingAspects);
    }
    if (message.actionCount !== 0) {
      writer.uint32(16).int32(message.actionCount);
    }
    if (message.actionCountNotIncludingAspects !== 0) {
      writer.uint32(48).int32(message.actionCountNotIncludingAspects);
    }
    if (message.inputFileConfiguredTargetCount !== 0) {
      writer.uint32(56).int32(message.inputFileConfiguredTargetCount);
    }
    if (message.outputFileConfiguredTargetCount !== 0) {
      writer.uint32(64).int32(message.outputFileConfiguredTargetCount);
    }
    if (message.otherConfiguredTargetCount !== 0) {
      writer.uint32(72).int32(message.otherConfiguredTargetCount);
    }
    if (message.outputArtifactCount !== 0) {
      writer.uint32(24).int32(message.outputArtifactCount);
    }
    if (message.postInvocationSkyframeNodeCount !== 0) {
      writer.uint32(32).int32(message.postInvocationSkyframeNodeCount);
    }
    for (const v of message.dirtiedValues) {
      BuildMetrics_EvaluationStat.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.changedValues) {
      BuildMetrics_EvaluationStat.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.builtValues) {
      BuildMetrics_EvaluationStat.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.cleanedValues) {
      BuildMetrics_EvaluationStat.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.evaluatedValues) {
      BuildMetrics_EvaluationStat.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.ruleClass) {
      BuildMetrics_BuildGraphMetrics_RuleClassCount.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.aspect) {
      BuildMetrics_BuildGraphMetrics_AspectCount.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_BuildGraphMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_BuildGraphMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionLookupValueCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.actionLookupValueCountNotIncludingAspects = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actionCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actionCountNotIncludingAspects = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.inputFileConfiguredTargetCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.outputFileConfiguredTargetCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.otherConfiguredTargetCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.outputArtifactCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.postInvocationSkyframeNodeCount = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dirtiedValues.push(BuildMetrics_EvaluationStat.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.changedValues.push(BuildMetrics_EvaluationStat.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.builtValues.push(BuildMetrics_EvaluationStat.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.cleanedValues.push(BuildMetrics_EvaluationStat.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.evaluatedValues.push(BuildMetrics_EvaluationStat.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.ruleClass.push(BuildMetrics_BuildGraphMetrics_RuleClassCount.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.aspect.push(BuildMetrics_BuildGraphMetrics_AspectCount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_BuildGraphMetrics {
    return {
      actionLookupValueCount: isSet(object.actionLookupValueCount)
        ? globalThis.Number(object.actionLookupValueCount)
        : 0,
      actionLookupValueCountNotIncludingAspects: isSet(object.actionLookupValueCountNotIncludingAspects)
        ? globalThis.Number(object.actionLookupValueCountNotIncludingAspects)
        : 0,
      actionCount: isSet(object.actionCount) ? globalThis.Number(object.actionCount) : 0,
      actionCountNotIncludingAspects: isSet(object.actionCountNotIncludingAspects)
        ? globalThis.Number(object.actionCountNotIncludingAspects)
        : 0,
      inputFileConfiguredTargetCount: isSet(object.inputFileConfiguredTargetCount)
        ? globalThis.Number(object.inputFileConfiguredTargetCount)
        : 0,
      outputFileConfiguredTargetCount: isSet(object.outputFileConfiguredTargetCount)
        ? globalThis.Number(object.outputFileConfiguredTargetCount)
        : 0,
      otherConfiguredTargetCount: isSet(object.otherConfiguredTargetCount)
        ? globalThis.Number(object.otherConfiguredTargetCount)
        : 0,
      outputArtifactCount: isSet(object.outputArtifactCount) ? globalThis.Number(object.outputArtifactCount) : 0,
      postInvocationSkyframeNodeCount: isSet(object.postInvocationSkyframeNodeCount)
        ? globalThis.Number(object.postInvocationSkyframeNodeCount)
        : 0,
      dirtiedValues: globalThis.Array.isArray(object?.dirtiedValues)
        ? object.dirtiedValues.map((e: any) => BuildMetrics_EvaluationStat.fromJSON(e))
        : [],
      changedValues: globalThis.Array.isArray(object?.changedValues)
        ? object.changedValues.map((e: any) => BuildMetrics_EvaluationStat.fromJSON(e))
        : [],
      builtValues: globalThis.Array.isArray(object?.builtValues)
        ? object.builtValues.map((e: any) => BuildMetrics_EvaluationStat.fromJSON(e))
        : [],
      cleanedValues: globalThis.Array.isArray(object?.cleanedValues)
        ? object.cleanedValues.map((e: any) => BuildMetrics_EvaluationStat.fromJSON(e))
        : [],
      evaluatedValues: globalThis.Array.isArray(object?.evaluatedValues)
        ? object.evaluatedValues.map((e: any) => BuildMetrics_EvaluationStat.fromJSON(e))
        : [],
      ruleClass: globalThis.Array.isArray(object?.ruleClass)
        ? object.ruleClass.map((e: any) => BuildMetrics_BuildGraphMetrics_RuleClassCount.fromJSON(e))
        : [],
      aspect: globalThis.Array.isArray(object?.aspect)
        ? object.aspect.map((e: any) => BuildMetrics_BuildGraphMetrics_AspectCount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildMetrics_BuildGraphMetrics): unknown {
    const obj: any = {};
    if (message.actionLookupValueCount !== 0) {
      obj.actionLookupValueCount = Math.round(message.actionLookupValueCount);
    }
    if (message.actionLookupValueCountNotIncludingAspects !== 0) {
      obj.actionLookupValueCountNotIncludingAspects = Math.round(message.actionLookupValueCountNotIncludingAspects);
    }
    if (message.actionCount !== 0) {
      obj.actionCount = Math.round(message.actionCount);
    }
    if (message.actionCountNotIncludingAspects !== 0) {
      obj.actionCountNotIncludingAspects = Math.round(message.actionCountNotIncludingAspects);
    }
    if (message.inputFileConfiguredTargetCount !== 0) {
      obj.inputFileConfiguredTargetCount = Math.round(message.inputFileConfiguredTargetCount);
    }
    if (message.outputFileConfiguredTargetCount !== 0) {
      obj.outputFileConfiguredTargetCount = Math.round(message.outputFileConfiguredTargetCount);
    }
    if (message.otherConfiguredTargetCount !== 0) {
      obj.otherConfiguredTargetCount = Math.round(message.otherConfiguredTargetCount);
    }
    if (message.outputArtifactCount !== 0) {
      obj.outputArtifactCount = Math.round(message.outputArtifactCount);
    }
    if (message.postInvocationSkyframeNodeCount !== 0) {
      obj.postInvocationSkyframeNodeCount = Math.round(message.postInvocationSkyframeNodeCount);
    }
    if (message.dirtiedValues?.length) {
      obj.dirtiedValues = message.dirtiedValues.map((e) => BuildMetrics_EvaluationStat.toJSON(e));
    }
    if (message.changedValues?.length) {
      obj.changedValues = message.changedValues.map((e) => BuildMetrics_EvaluationStat.toJSON(e));
    }
    if (message.builtValues?.length) {
      obj.builtValues = message.builtValues.map((e) => BuildMetrics_EvaluationStat.toJSON(e));
    }
    if (message.cleanedValues?.length) {
      obj.cleanedValues = message.cleanedValues.map((e) => BuildMetrics_EvaluationStat.toJSON(e));
    }
    if (message.evaluatedValues?.length) {
      obj.evaluatedValues = message.evaluatedValues.map((e) => BuildMetrics_EvaluationStat.toJSON(e));
    }
    if (message.ruleClass?.length) {
      obj.ruleClass = message.ruleClass.map((e) => BuildMetrics_BuildGraphMetrics_RuleClassCount.toJSON(e));
    }
    if (message.aspect?.length) {
      obj.aspect = message.aspect.map((e) => BuildMetrics_BuildGraphMetrics_AspectCount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_BuildGraphMetrics>, I>>(base?: I): BuildMetrics_BuildGraphMetrics {
    return BuildMetrics_BuildGraphMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_BuildGraphMetrics>, I>>(
    object: I,
  ): BuildMetrics_BuildGraphMetrics {
    const message = createBaseBuildMetrics_BuildGraphMetrics();
    message.actionLookupValueCount = object.actionLookupValueCount ?? 0;
    message.actionLookupValueCountNotIncludingAspects = object.actionLookupValueCountNotIncludingAspects ?? 0;
    message.actionCount = object.actionCount ?? 0;
    message.actionCountNotIncludingAspects = object.actionCountNotIncludingAspects ?? 0;
    message.inputFileConfiguredTargetCount = object.inputFileConfiguredTargetCount ?? 0;
    message.outputFileConfiguredTargetCount = object.outputFileConfiguredTargetCount ?? 0;
    message.otherConfiguredTargetCount = object.otherConfiguredTargetCount ?? 0;
    message.outputArtifactCount = object.outputArtifactCount ?? 0;
    message.postInvocationSkyframeNodeCount = object.postInvocationSkyframeNodeCount ?? 0;
    message.dirtiedValues = object.dirtiedValues?.map((e) => BuildMetrics_EvaluationStat.fromPartial(e)) || [];
    message.changedValues = object.changedValues?.map((e) => BuildMetrics_EvaluationStat.fromPartial(e)) || [];
    message.builtValues = object.builtValues?.map((e) => BuildMetrics_EvaluationStat.fromPartial(e)) || [];
    message.cleanedValues = object.cleanedValues?.map((e) => BuildMetrics_EvaluationStat.fromPartial(e)) || [];
    message.evaluatedValues = object.evaluatedValues?.map((e) => BuildMetrics_EvaluationStat.fromPartial(e)) || [];
    message.ruleClass = object.ruleClass?.map((e) => BuildMetrics_BuildGraphMetrics_RuleClassCount.fromPartial(e)) ||
      [];
    message.aspect = object.aspect?.map((e) => BuildMetrics_BuildGraphMetrics_AspectCount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuildMetrics_BuildGraphMetrics_RuleClassCount(): BuildMetrics_BuildGraphMetrics_RuleClassCount {
  return { key: "", ruleClass: "", count: "0", actionCount: "0" };
}

export const BuildMetrics_BuildGraphMetrics_RuleClassCount: MessageFns<BuildMetrics_BuildGraphMetrics_RuleClassCount> =
  {
    encode(
      message: BuildMetrics_BuildGraphMetrics_RuleClassCount,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.ruleClass !== "") {
        writer.uint32(18).string(message.ruleClass);
      }
      if (message.count !== "0") {
        writer.uint32(24).uint64(message.count);
      }
      if (message.actionCount !== "0") {
        writer.uint32(32).uint64(message.actionCount);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_BuildGraphMetrics_RuleClassCount {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseBuildMetrics_BuildGraphMetrics_RuleClassCount();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.ruleClass = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.count = reader.uint64().toString();
            continue;
          }
          case 4: {
            if (tag !== 32) {
              break;
            }

            message.actionCount = reader.uint64().toString();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): BuildMetrics_BuildGraphMetrics_RuleClassCount {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        ruleClass: isSet(object.ruleClass) ? globalThis.String(object.ruleClass) : "",
        count: isSet(object.count) ? globalThis.String(object.count) : "0",
        actionCount: isSet(object.actionCount) ? globalThis.String(object.actionCount) : "0",
      };
    },

    toJSON(message: BuildMetrics_BuildGraphMetrics_RuleClassCount): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.ruleClass !== "") {
        obj.ruleClass = message.ruleClass;
      }
      if (message.count !== "0") {
        obj.count = message.count;
      }
      if (message.actionCount !== "0") {
        obj.actionCount = message.actionCount;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<BuildMetrics_BuildGraphMetrics_RuleClassCount>, I>>(
      base?: I,
    ): BuildMetrics_BuildGraphMetrics_RuleClassCount {
      return BuildMetrics_BuildGraphMetrics_RuleClassCount.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<BuildMetrics_BuildGraphMetrics_RuleClassCount>, I>>(
      object: I,
    ): BuildMetrics_BuildGraphMetrics_RuleClassCount {
      const message = createBaseBuildMetrics_BuildGraphMetrics_RuleClassCount();
      message.key = object.key ?? "";
      message.ruleClass = object.ruleClass ?? "";
      message.count = object.count ?? "0";
      message.actionCount = object.actionCount ?? "0";
      return message;
    },
  };

function createBaseBuildMetrics_BuildGraphMetrics_AspectCount(): BuildMetrics_BuildGraphMetrics_AspectCount {
  return { key: "", aspectName: "", count: "0", actionCount: "0" };
}

export const BuildMetrics_BuildGraphMetrics_AspectCount: MessageFns<BuildMetrics_BuildGraphMetrics_AspectCount> = {
  encode(message: BuildMetrics_BuildGraphMetrics_AspectCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.aspectName !== "") {
      writer.uint32(18).string(message.aspectName);
    }
    if (message.count !== "0") {
      writer.uint32(24).uint64(message.count);
    }
    if (message.actionCount !== "0") {
      writer.uint32(32).uint64(message.actionCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_BuildGraphMetrics_AspectCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_BuildGraphMetrics_AspectCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aspectName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.actionCount = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_BuildGraphMetrics_AspectCount {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      aspectName: isSet(object.aspectName) ? globalThis.String(object.aspectName) : "",
      count: isSet(object.count) ? globalThis.String(object.count) : "0",
      actionCount: isSet(object.actionCount) ? globalThis.String(object.actionCount) : "0",
    };
  },

  toJSON(message: BuildMetrics_BuildGraphMetrics_AspectCount): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.aspectName !== "") {
      obj.aspectName = message.aspectName;
    }
    if (message.count !== "0") {
      obj.count = message.count;
    }
    if (message.actionCount !== "0") {
      obj.actionCount = message.actionCount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_BuildGraphMetrics_AspectCount>, I>>(
    base?: I,
  ): BuildMetrics_BuildGraphMetrics_AspectCount {
    return BuildMetrics_BuildGraphMetrics_AspectCount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_BuildGraphMetrics_AspectCount>, I>>(
    object: I,
  ): BuildMetrics_BuildGraphMetrics_AspectCount {
    const message = createBaseBuildMetrics_BuildGraphMetrics_AspectCount();
    message.key = object.key ?? "";
    message.aspectName = object.aspectName ?? "";
    message.count = object.count ?? "0";
    message.actionCount = object.actionCount ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_WorkerMetrics(): BuildMetrics_WorkerMetrics {
  return {
    workerId: 0,
    workerIds: [],
    processId: 0,
    mnemonic: "",
    isMultiplex: false,
    isSandbox: false,
    isMeasurable: false,
    workerKeyHash: "0",
    workerStatus: 0,
    code: undefined,
    actionsExecuted: "0",
    priorActionsExecuted: "0",
    workerStats: [],
  };
}

export const BuildMetrics_WorkerMetrics: MessageFns<BuildMetrics_WorkerMetrics> = {
  encode(message: BuildMetrics_WorkerMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== 0) {
      writer.uint32(8).int32(message.workerId);
    }
    writer.uint32(66).fork();
    for (const v of message.workerIds) {
      writer.uint32(v);
    }
    writer.join();
    if (message.processId !== 0) {
      writer.uint32(16).uint32(message.processId);
    }
    if (message.mnemonic !== "") {
      writer.uint32(26).string(message.mnemonic);
    }
    if (message.isMultiplex !== false) {
      writer.uint32(32).bool(message.isMultiplex);
    }
    if (message.isSandbox !== false) {
      writer.uint32(40).bool(message.isSandbox);
    }
    if (message.isMeasurable !== false) {
      writer.uint32(48).bool(message.isMeasurable);
    }
    if (message.workerKeyHash !== "0") {
      writer.uint32(72).int64(message.workerKeyHash);
    }
    if (message.workerStatus !== 0) {
      writer.uint32(80).int32(message.workerStatus);
    }
    if (message.code !== undefined) {
      writer.uint32(96).int32(message.code);
    }
    if (message.actionsExecuted !== "0") {
      writer.uint32(88).int64(message.actionsExecuted);
    }
    if (message.priorActionsExecuted !== "0") {
      writer.uint32(104).int64(message.priorActionsExecuted);
    }
    for (const v of message.workerStats) {
      BuildMetrics_WorkerMetrics_WorkerStats.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_WorkerMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_WorkerMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.workerId = reader.int32();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.workerIds.push(reader.uint32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.workerIds.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.processId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mnemonic = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isMultiplex = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isSandbox = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isMeasurable = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.workerKeyHash = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.workerStatus = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.actionsExecuted = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.priorActionsExecuted = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.workerStats.push(BuildMetrics_WorkerMetrics_WorkerStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_WorkerMetrics {
    return {
      workerId: isSet(object.workerId) ? globalThis.Number(object.workerId) : 0,
      workerIds: globalThis.Array.isArray(object?.workerIds)
        ? object.workerIds.map((e: any) => globalThis.Number(e))
        : [],
      processId: isSet(object.processId) ? globalThis.Number(object.processId) : 0,
      mnemonic: isSet(object.mnemonic) ? globalThis.String(object.mnemonic) : "",
      isMultiplex: isSet(object.isMultiplex) ? globalThis.Boolean(object.isMultiplex) : false,
      isSandbox: isSet(object.isSandbox) ? globalThis.Boolean(object.isSandbox) : false,
      isMeasurable: isSet(object.isMeasurable) ? globalThis.Boolean(object.isMeasurable) : false,
      workerKeyHash: isSet(object.workerKeyHash) ? globalThis.String(object.workerKeyHash) : "0",
      workerStatus: isSet(object.workerStatus)
        ? buildMetrics_WorkerMetrics_WorkerStatusFromJSON(object.workerStatus)
        : 0,
      code: isSet(object.code) ? worker_CodeFromJSON(object.code) : undefined,
      actionsExecuted: isSet(object.actionsExecuted) ? globalThis.String(object.actionsExecuted) : "0",
      priorActionsExecuted: isSet(object.priorActionsExecuted) ? globalThis.String(object.priorActionsExecuted) : "0",
      workerStats: globalThis.Array.isArray(object?.workerStats)
        ? object.workerStats.map((e: any) => BuildMetrics_WorkerMetrics_WorkerStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildMetrics_WorkerMetrics): unknown {
    const obj: any = {};
    if (message.workerId !== 0) {
      obj.workerId = Math.round(message.workerId);
    }
    if (message.workerIds?.length) {
      obj.workerIds = message.workerIds.map((e) => Math.round(e));
    }
    if (message.processId !== 0) {
      obj.processId = Math.round(message.processId);
    }
    if (message.mnemonic !== "") {
      obj.mnemonic = message.mnemonic;
    }
    if (message.isMultiplex !== false) {
      obj.isMultiplex = message.isMultiplex;
    }
    if (message.isSandbox !== false) {
      obj.isSandbox = message.isSandbox;
    }
    if (message.isMeasurable !== false) {
      obj.isMeasurable = message.isMeasurable;
    }
    if (message.workerKeyHash !== "0") {
      obj.workerKeyHash = message.workerKeyHash;
    }
    if (message.workerStatus !== 0) {
      obj.workerStatus = buildMetrics_WorkerMetrics_WorkerStatusToJSON(message.workerStatus);
    }
    if (message.code !== undefined) {
      obj.code = worker_CodeToJSON(message.code);
    }
    if (message.actionsExecuted !== "0") {
      obj.actionsExecuted = message.actionsExecuted;
    }
    if (message.priorActionsExecuted !== "0") {
      obj.priorActionsExecuted = message.priorActionsExecuted;
    }
    if (message.workerStats?.length) {
      obj.workerStats = message.workerStats.map((e) => BuildMetrics_WorkerMetrics_WorkerStats.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_WorkerMetrics>, I>>(base?: I): BuildMetrics_WorkerMetrics {
    return BuildMetrics_WorkerMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_WorkerMetrics>, I>>(object: I): BuildMetrics_WorkerMetrics {
    const message = createBaseBuildMetrics_WorkerMetrics();
    message.workerId = object.workerId ?? 0;
    message.workerIds = object.workerIds?.map((e) => e) || [];
    message.processId = object.processId ?? 0;
    message.mnemonic = object.mnemonic ?? "";
    message.isMultiplex = object.isMultiplex ?? false;
    message.isSandbox = object.isSandbox ?? false;
    message.isMeasurable = object.isMeasurable ?? false;
    message.workerKeyHash = object.workerKeyHash ?? "0";
    message.workerStatus = object.workerStatus ?? 0;
    message.code = object.code ?? undefined;
    message.actionsExecuted = object.actionsExecuted ?? "0";
    message.priorActionsExecuted = object.priorActionsExecuted ?? "0";
    message.workerStats = object.workerStats?.map((e) => BuildMetrics_WorkerMetrics_WorkerStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuildMetrics_WorkerMetrics_WorkerStats(): BuildMetrics_WorkerMetrics_WorkerStats {
  return { collectTimeInMs: "0", workerMemoryInKb: 0, priorWorkerMemoryInKb: 0, lastActionStartTimeInMs: "0" };
}

export const BuildMetrics_WorkerMetrics_WorkerStats: MessageFns<BuildMetrics_WorkerMetrics_WorkerStats> = {
  encode(message: BuildMetrics_WorkerMetrics_WorkerStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collectTimeInMs !== "0") {
      writer.uint32(8).int64(message.collectTimeInMs);
    }
    if (message.workerMemoryInKb !== 0) {
      writer.uint32(16).int32(message.workerMemoryInKb);
    }
    if (message.priorWorkerMemoryInKb !== 0) {
      writer.uint32(32).int32(message.priorWorkerMemoryInKb);
    }
    if (message.lastActionStartTimeInMs !== "0") {
      writer.uint32(24).int64(message.lastActionStartTimeInMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_WorkerMetrics_WorkerStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_WorkerMetrics_WorkerStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.collectTimeInMs = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.workerMemoryInKb = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.priorWorkerMemoryInKb = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lastActionStartTimeInMs = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_WorkerMetrics_WorkerStats {
    return {
      collectTimeInMs: isSet(object.collectTimeInMs) ? globalThis.String(object.collectTimeInMs) : "0",
      workerMemoryInKb: isSet(object.workerMemoryInKb) ? globalThis.Number(object.workerMemoryInKb) : 0,
      priorWorkerMemoryInKb: isSet(object.priorWorkerMemoryInKb) ? globalThis.Number(object.priorWorkerMemoryInKb) : 0,
      lastActionStartTimeInMs: isSet(object.lastActionStartTimeInMs)
        ? globalThis.String(object.lastActionStartTimeInMs)
        : "0",
    };
  },

  toJSON(message: BuildMetrics_WorkerMetrics_WorkerStats): unknown {
    const obj: any = {};
    if (message.collectTimeInMs !== "0") {
      obj.collectTimeInMs = message.collectTimeInMs;
    }
    if (message.workerMemoryInKb !== 0) {
      obj.workerMemoryInKb = Math.round(message.workerMemoryInKb);
    }
    if (message.priorWorkerMemoryInKb !== 0) {
      obj.priorWorkerMemoryInKb = Math.round(message.priorWorkerMemoryInKb);
    }
    if (message.lastActionStartTimeInMs !== "0") {
      obj.lastActionStartTimeInMs = message.lastActionStartTimeInMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_WorkerMetrics_WorkerStats>, I>>(
    base?: I,
  ): BuildMetrics_WorkerMetrics_WorkerStats {
    return BuildMetrics_WorkerMetrics_WorkerStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_WorkerMetrics_WorkerStats>, I>>(
    object: I,
  ): BuildMetrics_WorkerMetrics_WorkerStats {
    const message = createBaseBuildMetrics_WorkerMetrics_WorkerStats();
    message.collectTimeInMs = object.collectTimeInMs ?? "0";
    message.workerMemoryInKb = object.workerMemoryInKb ?? 0;
    message.priorWorkerMemoryInKb = object.priorWorkerMemoryInKb ?? 0;
    message.lastActionStartTimeInMs = object.lastActionStartTimeInMs ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_NetworkMetrics(): BuildMetrics_NetworkMetrics {
  return { systemNetworkStats: undefined };
}

export const BuildMetrics_NetworkMetrics: MessageFns<BuildMetrics_NetworkMetrics> = {
  encode(message: BuildMetrics_NetworkMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.systemNetworkStats !== undefined) {
      BuildMetrics_NetworkMetrics_SystemNetworkStats.encode(message.systemNetworkStats, writer.uint32(10).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_NetworkMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_NetworkMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.systemNetworkStats = BuildMetrics_NetworkMetrics_SystemNetworkStats.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_NetworkMetrics {
    return {
      systemNetworkStats: isSet(object.systemNetworkStats)
        ? BuildMetrics_NetworkMetrics_SystemNetworkStats.fromJSON(object.systemNetworkStats)
        : undefined,
    };
  },

  toJSON(message: BuildMetrics_NetworkMetrics): unknown {
    const obj: any = {};
    if (message.systemNetworkStats !== undefined) {
      obj.systemNetworkStats = BuildMetrics_NetworkMetrics_SystemNetworkStats.toJSON(message.systemNetworkStats);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_NetworkMetrics>, I>>(base?: I): BuildMetrics_NetworkMetrics {
    return BuildMetrics_NetworkMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_NetworkMetrics>, I>>(object: I): BuildMetrics_NetworkMetrics {
    const message = createBaseBuildMetrics_NetworkMetrics();
    message.systemNetworkStats = (object.systemNetworkStats !== undefined && object.systemNetworkStats !== null)
      ? BuildMetrics_NetworkMetrics_SystemNetworkStats.fromPartial(object.systemNetworkStats)
      : undefined;
    return message;
  },
};

function createBaseBuildMetrics_NetworkMetrics_SystemNetworkStats(): BuildMetrics_NetworkMetrics_SystemNetworkStats {
  return {
    bytesSent: "0",
    bytesRecv: "0",
    packetsSent: "0",
    packetsRecv: "0",
    peakBytesSentPerSec: "0",
    peakBytesRecvPerSec: "0",
    peakPacketsSentPerSec: "0",
    peakPacketsRecvPerSec: "0",
  };
}

export const BuildMetrics_NetworkMetrics_SystemNetworkStats: MessageFns<
  BuildMetrics_NetworkMetrics_SystemNetworkStats
> = {
  encode(
    message: BuildMetrics_NetworkMetrics_SystemNetworkStats,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.bytesSent !== "0") {
      writer.uint32(8).uint64(message.bytesSent);
    }
    if (message.bytesRecv !== "0") {
      writer.uint32(16).uint64(message.bytesRecv);
    }
    if (message.packetsSent !== "0") {
      writer.uint32(24).uint64(message.packetsSent);
    }
    if (message.packetsRecv !== "0") {
      writer.uint32(32).uint64(message.packetsRecv);
    }
    if (message.peakBytesSentPerSec !== "0") {
      writer.uint32(40).uint64(message.peakBytesSentPerSec);
    }
    if (message.peakBytesRecvPerSec !== "0") {
      writer.uint32(48).uint64(message.peakBytesRecvPerSec);
    }
    if (message.peakPacketsSentPerSec !== "0") {
      writer.uint32(56).uint64(message.peakPacketsSentPerSec);
    }
    if (message.peakPacketsRecvPerSec !== "0") {
      writer.uint32(64).uint64(message.peakPacketsRecvPerSec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_NetworkMetrics_SystemNetworkStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_NetworkMetrics_SystemNetworkStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bytesSent = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.bytesRecv = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.packetsSent = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.packetsRecv = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.peakBytesSentPerSec = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.peakBytesRecvPerSec = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.peakPacketsSentPerSec = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.peakPacketsRecvPerSec = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_NetworkMetrics_SystemNetworkStats {
    return {
      bytesSent: isSet(object.bytesSent) ? globalThis.String(object.bytesSent) : "0",
      bytesRecv: isSet(object.bytesRecv) ? globalThis.String(object.bytesRecv) : "0",
      packetsSent: isSet(object.packetsSent) ? globalThis.String(object.packetsSent) : "0",
      packetsRecv: isSet(object.packetsRecv) ? globalThis.String(object.packetsRecv) : "0",
      peakBytesSentPerSec: isSet(object.peakBytesSentPerSec) ? globalThis.String(object.peakBytesSentPerSec) : "0",
      peakBytesRecvPerSec: isSet(object.peakBytesRecvPerSec) ? globalThis.String(object.peakBytesRecvPerSec) : "0",
      peakPacketsSentPerSec: isSet(object.peakPacketsSentPerSec)
        ? globalThis.String(object.peakPacketsSentPerSec)
        : "0",
      peakPacketsRecvPerSec: isSet(object.peakPacketsRecvPerSec)
        ? globalThis.String(object.peakPacketsRecvPerSec)
        : "0",
    };
  },

  toJSON(message: BuildMetrics_NetworkMetrics_SystemNetworkStats): unknown {
    const obj: any = {};
    if (message.bytesSent !== "0") {
      obj.bytesSent = message.bytesSent;
    }
    if (message.bytesRecv !== "0") {
      obj.bytesRecv = message.bytesRecv;
    }
    if (message.packetsSent !== "0") {
      obj.packetsSent = message.packetsSent;
    }
    if (message.packetsRecv !== "0") {
      obj.packetsRecv = message.packetsRecv;
    }
    if (message.peakBytesSentPerSec !== "0") {
      obj.peakBytesSentPerSec = message.peakBytesSentPerSec;
    }
    if (message.peakBytesRecvPerSec !== "0") {
      obj.peakBytesRecvPerSec = message.peakBytesRecvPerSec;
    }
    if (message.peakPacketsSentPerSec !== "0") {
      obj.peakPacketsSentPerSec = message.peakPacketsSentPerSec;
    }
    if (message.peakPacketsRecvPerSec !== "0") {
      obj.peakPacketsRecvPerSec = message.peakPacketsRecvPerSec;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_NetworkMetrics_SystemNetworkStats>, I>>(
    base?: I,
  ): BuildMetrics_NetworkMetrics_SystemNetworkStats {
    return BuildMetrics_NetworkMetrics_SystemNetworkStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_NetworkMetrics_SystemNetworkStats>, I>>(
    object: I,
  ): BuildMetrics_NetworkMetrics_SystemNetworkStats {
    const message = createBaseBuildMetrics_NetworkMetrics_SystemNetworkStats();
    message.bytesSent = object.bytesSent ?? "0";
    message.bytesRecv = object.bytesRecv ?? "0";
    message.packetsSent = object.packetsSent ?? "0";
    message.packetsRecv = object.packetsRecv ?? "0";
    message.peakBytesSentPerSec = object.peakBytesSentPerSec ?? "0";
    message.peakBytesRecvPerSec = object.peakBytesRecvPerSec ?? "0";
    message.peakPacketsSentPerSec = object.peakPacketsSentPerSec ?? "0";
    message.peakPacketsRecvPerSec = object.peakPacketsRecvPerSec ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_WorkerPoolMetrics(): BuildMetrics_WorkerPoolMetrics {
  return { workerPoolStats: [] };
}

export const BuildMetrics_WorkerPoolMetrics: MessageFns<BuildMetrics_WorkerPoolMetrics> = {
  encode(message: BuildMetrics_WorkerPoolMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workerPoolStats) {
      BuildMetrics_WorkerPoolMetrics_WorkerPoolStats.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_WorkerPoolMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_WorkerPoolMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerPoolStats.push(BuildMetrics_WorkerPoolMetrics_WorkerPoolStats.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_WorkerPoolMetrics {
    return {
      workerPoolStats: globalThis.Array.isArray(object?.workerPoolStats)
        ? object.workerPoolStats.map((e: any) => BuildMetrics_WorkerPoolMetrics_WorkerPoolStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildMetrics_WorkerPoolMetrics): unknown {
    const obj: any = {};
    if (message.workerPoolStats?.length) {
      obj.workerPoolStats = message.workerPoolStats.map((e) =>
        BuildMetrics_WorkerPoolMetrics_WorkerPoolStats.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_WorkerPoolMetrics>, I>>(base?: I): BuildMetrics_WorkerPoolMetrics {
    return BuildMetrics_WorkerPoolMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_WorkerPoolMetrics>, I>>(
    object: I,
  ): BuildMetrics_WorkerPoolMetrics {
    const message = createBaseBuildMetrics_WorkerPoolMetrics();
    message.workerPoolStats =
      object.workerPoolStats?.map((e) => BuildMetrics_WorkerPoolMetrics_WorkerPoolStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuildMetrics_WorkerPoolMetrics_WorkerPoolStats(): BuildMetrics_WorkerPoolMetrics_WorkerPoolStats {
  return {
    hash: 0,
    mnemonic: "",
    createdCount: "0",
    destroyedCount: "0",
    evictedCount: "0",
    userExecExceptionDestroyedCount: "0",
    ioExceptionDestroyedCount: "0",
    interruptedExceptionDestroyedCount: "0",
    unknownDestroyedCount: "0",
    aliveCount: "0",
  };
}

export const BuildMetrics_WorkerPoolMetrics_WorkerPoolStats: MessageFns<
  BuildMetrics_WorkerPoolMetrics_WorkerPoolStats
> = {
  encode(
    message: BuildMetrics_WorkerPoolMetrics_WorkerPoolStats,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.hash !== 0) {
      writer.uint32(8).int32(message.hash);
    }
    if (message.mnemonic !== "") {
      writer.uint32(18).string(message.mnemonic);
    }
    if (message.createdCount !== "0") {
      writer.uint32(24).int64(message.createdCount);
    }
    if (message.destroyedCount !== "0") {
      writer.uint32(32).int64(message.destroyedCount);
    }
    if (message.evictedCount !== "0") {
      writer.uint32(40).int64(message.evictedCount);
    }
    if (message.userExecExceptionDestroyedCount !== "0") {
      writer.uint32(48).int64(message.userExecExceptionDestroyedCount);
    }
    if (message.ioExceptionDestroyedCount !== "0") {
      writer.uint32(56).int64(message.ioExceptionDestroyedCount);
    }
    if (message.interruptedExceptionDestroyedCount !== "0") {
      writer.uint32(64).int64(message.interruptedExceptionDestroyedCount);
    }
    if (message.unknownDestroyedCount !== "0") {
      writer.uint32(72).int64(message.unknownDestroyedCount);
    }
    if (message.aliveCount !== "0") {
      writer.uint32(80).int64(message.aliveCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_WorkerPoolMetrics_WorkerPoolStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_WorkerPoolMetrics_WorkerPoolStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hash = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mnemonic = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createdCount = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.destroyedCount = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.evictedCount = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.userExecExceptionDestroyedCount = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.ioExceptionDestroyedCount = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.interruptedExceptionDestroyedCount = reader.int64().toString();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.unknownDestroyedCount = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.aliveCount = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_WorkerPoolMetrics_WorkerPoolStats {
    return {
      hash: isSet(object.hash) ? globalThis.Number(object.hash) : 0,
      mnemonic: isSet(object.mnemonic) ? globalThis.String(object.mnemonic) : "",
      createdCount: isSet(object.createdCount) ? globalThis.String(object.createdCount) : "0",
      destroyedCount: isSet(object.destroyedCount) ? globalThis.String(object.destroyedCount) : "0",
      evictedCount: isSet(object.evictedCount) ? globalThis.String(object.evictedCount) : "0",
      userExecExceptionDestroyedCount: isSet(object.userExecExceptionDestroyedCount)
        ? globalThis.String(object.userExecExceptionDestroyedCount)
        : "0",
      ioExceptionDestroyedCount: isSet(object.ioExceptionDestroyedCount)
        ? globalThis.String(object.ioExceptionDestroyedCount)
        : "0",
      interruptedExceptionDestroyedCount: isSet(object.interruptedExceptionDestroyedCount)
        ? globalThis.String(object.interruptedExceptionDestroyedCount)
        : "0",
      unknownDestroyedCount: isSet(object.unknownDestroyedCount)
        ? globalThis.String(object.unknownDestroyedCount)
        : "0",
      aliveCount: isSet(object.aliveCount) ? globalThis.String(object.aliveCount) : "0",
    };
  },

  toJSON(message: BuildMetrics_WorkerPoolMetrics_WorkerPoolStats): unknown {
    const obj: any = {};
    if (message.hash !== 0) {
      obj.hash = Math.round(message.hash);
    }
    if (message.mnemonic !== "") {
      obj.mnemonic = message.mnemonic;
    }
    if (message.createdCount !== "0") {
      obj.createdCount = message.createdCount;
    }
    if (message.destroyedCount !== "0") {
      obj.destroyedCount = message.destroyedCount;
    }
    if (message.evictedCount !== "0") {
      obj.evictedCount = message.evictedCount;
    }
    if (message.userExecExceptionDestroyedCount !== "0") {
      obj.userExecExceptionDestroyedCount = message.userExecExceptionDestroyedCount;
    }
    if (message.ioExceptionDestroyedCount !== "0") {
      obj.ioExceptionDestroyedCount = message.ioExceptionDestroyedCount;
    }
    if (message.interruptedExceptionDestroyedCount !== "0") {
      obj.interruptedExceptionDestroyedCount = message.interruptedExceptionDestroyedCount;
    }
    if (message.unknownDestroyedCount !== "0") {
      obj.unknownDestroyedCount = message.unknownDestroyedCount;
    }
    if (message.aliveCount !== "0") {
      obj.aliveCount = message.aliveCount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_WorkerPoolMetrics_WorkerPoolStats>, I>>(
    base?: I,
  ): BuildMetrics_WorkerPoolMetrics_WorkerPoolStats {
    return BuildMetrics_WorkerPoolMetrics_WorkerPoolStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_WorkerPoolMetrics_WorkerPoolStats>, I>>(
    object: I,
  ): BuildMetrics_WorkerPoolMetrics_WorkerPoolStats {
    const message = createBaseBuildMetrics_WorkerPoolMetrics_WorkerPoolStats();
    message.hash = object.hash ?? 0;
    message.mnemonic = object.mnemonic ?? "";
    message.createdCount = object.createdCount ?? "0";
    message.destroyedCount = object.destroyedCount ?? "0";
    message.evictedCount = object.evictedCount ?? "0";
    message.userExecExceptionDestroyedCount = object.userExecExceptionDestroyedCount ?? "0";
    message.ioExceptionDestroyedCount = object.ioExceptionDestroyedCount ?? "0";
    message.interruptedExceptionDestroyedCount = object.interruptedExceptionDestroyedCount ?? "0";
    message.unknownDestroyedCount = object.unknownDestroyedCount ?? "0";
    message.aliveCount = object.aliveCount ?? "0";
    return message;
  },
};

function createBaseBuildMetrics_DynamicExecutionMetrics(): BuildMetrics_DynamicExecutionMetrics {
  return { raceStatistics: [] };
}

export const BuildMetrics_DynamicExecutionMetrics: MessageFns<BuildMetrics_DynamicExecutionMetrics> = {
  encode(message: BuildMetrics_DynamicExecutionMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.raceStatistics) {
      BuildMetrics_DynamicExecutionMetrics_RaceStatistics.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_DynamicExecutionMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_DynamicExecutionMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.raceStatistics.push(
            BuildMetrics_DynamicExecutionMetrics_RaceStatistics.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_DynamicExecutionMetrics {
    return {
      raceStatistics: globalThis.Array.isArray(object?.raceStatistics)
        ? object.raceStatistics.map((e: any) => BuildMetrics_DynamicExecutionMetrics_RaceStatistics.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BuildMetrics_DynamicExecutionMetrics): unknown {
    const obj: any = {};
    if (message.raceStatistics?.length) {
      obj.raceStatistics = message.raceStatistics.map((e) =>
        BuildMetrics_DynamicExecutionMetrics_RaceStatistics.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_DynamicExecutionMetrics>, I>>(
    base?: I,
  ): BuildMetrics_DynamicExecutionMetrics {
    return BuildMetrics_DynamicExecutionMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_DynamicExecutionMetrics>, I>>(
    object: I,
  ): BuildMetrics_DynamicExecutionMetrics {
    const message = createBaseBuildMetrics_DynamicExecutionMetrics();
    message.raceStatistics =
      object.raceStatistics?.map((e) => BuildMetrics_DynamicExecutionMetrics_RaceStatistics.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBuildMetrics_DynamicExecutionMetrics_RaceStatistics(): BuildMetrics_DynamicExecutionMetrics_RaceStatistics {
  return { mnemonic: "", localRunner: "", remoteRunner: "", localWins: 0, remoteWins: 0 };
}

export const BuildMetrics_DynamicExecutionMetrics_RaceStatistics: MessageFns<
  BuildMetrics_DynamicExecutionMetrics_RaceStatistics
> = {
  encode(
    message: BuildMetrics_DynamicExecutionMetrics_RaceStatistics,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mnemonic !== "") {
      writer.uint32(10).string(message.mnemonic);
    }
    if (message.localRunner !== "") {
      writer.uint32(18).string(message.localRunner);
    }
    if (message.remoteRunner !== "") {
      writer.uint32(26).string(message.remoteRunner);
    }
    if (message.localWins !== 0) {
      writer.uint32(32).int32(message.localWins);
    }
    if (message.remoteWins !== 0) {
      writer.uint32(40).int32(message.remoteWins);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_DynamicExecutionMetrics_RaceStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_DynamicExecutionMetrics_RaceStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mnemonic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.localRunner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remoteRunner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.localWins = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.remoteWins = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_DynamicExecutionMetrics_RaceStatistics {
    return {
      mnemonic: isSet(object.mnemonic) ? globalThis.String(object.mnemonic) : "",
      localRunner: isSet(object.localRunner) ? globalThis.String(object.localRunner) : "",
      remoteRunner: isSet(object.remoteRunner) ? globalThis.String(object.remoteRunner) : "",
      localWins: isSet(object.localWins) ? globalThis.Number(object.localWins) : 0,
      remoteWins: isSet(object.remoteWins) ? globalThis.Number(object.remoteWins) : 0,
    };
  },

  toJSON(message: BuildMetrics_DynamicExecutionMetrics_RaceStatistics): unknown {
    const obj: any = {};
    if (message.mnemonic !== "") {
      obj.mnemonic = message.mnemonic;
    }
    if (message.localRunner !== "") {
      obj.localRunner = message.localRunner;
    }
    if (message.remoteRunner !== "") {
      obj.remoteRunner = message.remoteRunner;
    }
    if (message.localWins !== 0) {
      obj.localWins = Math.round(message.localWins);
    }
    if (message.remoteWins !== 0) {
      obj.remoteWins = Math.round(message.remoteWins);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_DynamicExecutionMetrics_RaceStatistics>, I>>(
    base?: I,
  ): BuildMetrics_DynamicExecutionMetrics_RaceStatistics {
    return BuildMetrics_DynamicExecutionMetrics_RaceStatistics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_DynamicExecutionMetrics_RaceStatistics>, I>>(
    object: I,
  ): BuildMetrics_DynamicExecutionMetrics_RaceStatistics {
    const message = createBaseBuildMetrics_DynamicExecutionMetrics_RaceStatistics();
    message.mnemonic = object.mnemonic ?? "";
    message.localRunner = object.localRunner ?? "";
    message.remoteRunner = object.remoteRunner ?? "";
    message.localWins = object.localWins ?? 0;
    message.remoteWins = object.remoteWins ?? 0;
    return message;
  },
};

function createBaseBuildMetrics_RemoteAnalysisCacheStatistics(): BuildMetrics_RemoteAnalysisCacheStatistics {
  return {
    cacheHits: "0",
    cacheMisses: "0",
    valueStoreValueBytesReceived: "0",
    valueStoreValueBytesSent: "0",
    valueStoreKeyBytesSent: "0",
    valueStoreWriteOps: "0",
    valueStoreReadOpsSuccessful: "0",
    valueStoreReadOpsNotFound: "0",
    valueStoreReadBatches: "0",
    valueStoreWriteBatches: "0",
    analysisCacheBytesReceived: "0",
    analysisCacheKeyBytesSent: "0",
    analysisCacheOps: "0",
    analysisCacheBatches: "0",
  };
}

export const BuildMetrics_RemoteAnalysisCacheStatistics: MessageFns<BuildMetrics_RemoteAnalysisCacheStatistics> = {
  encode(message: BuildMetrics_RemoteAnalysisCacheStatistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cacheHits !== "0") {
      writer.uint32(8).int64(message.cacheHits);
    }
    if (message.cacheMisses !== "0") {
      writer.uint32(16).int64(message.cacheMisses);
    }
    if (message.valueStoreValueBytesReceived !== "0") {
      writer.uint32(24).int64(message.valueStoreValueBytesReceived);
    }
    if (message.valueStoreValueBytesSent !== "0") {
      writer.uint32(32).int64(message.valueStoreValueBytesSent);
    }
    if (message.valueStoreKeyBytesSent !== "0") {
      writer.uint32(40).int64(message.valueStoreKeyBytesSent);
    }
    if (message.valueStoreWriteOps !== "0") {
      writer.uint32(48).int64(message.valueStoreWriteOps);
    }
    if (message.valueStoreReadOpsSuccessful !== "0") {
      writer.uint32(56).int64(message.valueStoreReadOpsSuccessful);
    }
    if (message.valueStoreReadOpsNotFound !== "0") {
      writer.uint32(64).int64(message.valueStoreReadOpsNotFound);
    }
    if (message.valueStoreReadBatches !== "0") {
      writer.uint32(80).int64(message.valueStoreReadBatches);
    }
    if (message.valueStoreWriteBatches !== "0") {
      writer.uint32(88).int64(message.valueStoreWriteBatches);
    }
    if (message.analysisCacheBytesReceived !== "0") {
      writer.uint32(96).int64(message.analysisCacheBytesReceived);
    }
    if (message.analysisCacheKeyBytesSent !== "0") {
      writer.uint32(104).int64(message.analysisCacheKeyBytesSent);
    }
    if (message.analysisCacheOps !== "0") {
      writer.uint32(112).int64(message.analysisCacheOps);
    }
    if (message.analysisCacheBatches !== "0") {
      writer.uint32(120).int64(message.analysisCacheBatches);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildMetrics_RemoteAnalysisCacheStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildMetrics_RemoteAnalysisCacheStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cacheHits = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cacheMisses = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.valueStoreValueBytesReceived = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.valueStoreValueBytesSent = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.valueStoreKeyBytesSent = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.valueStoreWriteOps = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.valueStoreReadOpsSuccessful = reader.int64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.valueStoreReadOpsNotFound = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.valueStoreReadBatches = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.valueStoreWriteBatches = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.analysisCacheBytesReceived = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.analysisCacheKeyBytesSent = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.analysisCacheOps = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.analysisCacheBatches = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildMetrics_RemoteAnalysisCacheStatistics {
    return {
      cacheHits: isSet(object.cacheHits) ? globalThis.String(object.cacheHits) : "0",
      cacheMisses: isSet(object.cacheMisses) ? globalThis.String(object.cacheMisses) : "0",
      valueStoreValueBytesReceived: isSet(object.valueStoreValueBytesReceived)
        ? globalThis.String(object.valueStoreValueBytesReceived)
        : "0",
      valueStoreValueBytesSent: isSet(object.valueStoreValueBytesSent)
        ? globalThis.String(object.valueStoreValueBytesSent)
        : "0",
      valueStoreKeyBytesSent: isSet(object.valueStoreKeyBytesSent)
        ? globalThis.String(object.valueStoreKeyBytesSent)
        : "0",
      valueStoreWriteOps: isSet(object.valueStoreWriteOps) ? globalThis.String(object.valueStoreWriteOps) : "0",
      valueStoreReadOpsSuccessful: isSet(object.valueStoreReadOpsSuccessful)
        ? globalThis.String(object.valueStoreReadOpsSuccessful)
        : "0",
      valueStoreReadOpsNotFound: isSet(object.valueStoreReadOpsNotFound)
        ? globalThis.String(object.valueStoreReadOpsNotFound)
        : "0",
      valueStoreReadBatches: isSet(object.valueStoreReadBatches)
        ? globalThis.String(object.valueStoreReadBatches)
        : "0",
      valueStoreWriteBatches: isSet(object.valueStoreWriteBatches)
        ? globalThis.String(object.valueStoreWriteBatches)
        : "0",
      analysisCacheBytesReceived: isSet(object.analysisCacheBytesReceived)
        ? globalThis.String(object.analysisCacheBytesReceived)
        : "0",
      analysisCacheKeyBytesSent: isSet(object.analysisCacheKeyBytesSent)
        ? globalThis.String(object.analysisCacheKeyBytesSent)
        : "0",
      analysisCacheOps: isSet(object.analysisCacheOps) ? globalThis.String(object.analysisCacheOps) : "0",
      analysisCacheBatches: isSet(object.analysisCacheBatches) ? globalThis.String(object.analysisCacheBatches) : "0",
    };
  },

  toJSON(message: BuildMetrics_RemoteAnalysisCacheStatistics): unknown {
    const obj: any = {};
    if (message.cacheHits !== "0") {
      obj.cacheHits = message.cacheHits;
    }
    if (message.cacheMisses !== "0") {
      obj.cacheMisses = message.cacheMisses;
    }
    if (message.valueStoreValueBytesReceived !== "0") {
      obj.valueStoreValueBytesReceived = message.valueStoreValueBytesReceived;
    }
    if (message.valueStoreValueBytesSent !== "0") {
      obj.valueStoreValueBytesSent = message.valueStoreValueBytesSent;
    }
    if (message.valueStoreKeyBytesSent !== "0") {
      obj.valueStoreKeyBytesSent = message.valueStoreKeyBytesSent;
    }
    if (message.valueStoreWriteOps !== "0") {
      obj.valueStoreWriteOps = message.valueStoreWriteOps;
    }
    if (message.valueStoreReadOpsSuccessful !== "0") {
      obj.valueStoreReadOpsSuccessful = message.valueStoreReadOpsSuccessful;
    }
    if (message.valueStoreReadOpsNotFound !== "0") {
      obj.valueStoreReadOpsNotFound = message.valueStoreReadOpsNotFound;
    }
    if (message.valueStoreReadBatches !== "0") {
      obj.valueStoreReadBatches = message.valueStoreReadBatches;
    }
    if (message.valueStoreWriteBatches !== "0") {
      obj.valueStoreWriteBatches = message.valueStoreWriteBatches;
    }
    if (message.analysisCacheBytesReceived !== "0") {
      obj.analysisCacheBytesReceived = message.analysisCacheBytesReceived;
    }
    if (message.analysisCacheKeyBytesSent !== "0") {
      obj.analysisCacheKeyBytesSent = message.analysisCacheKeyBytesSent;
    }
    if (message.analysisCacheOps !== "0") {
      obj.analysisCacheOps = message.analysisCacheOps;
    }
    if (message.analysisCacheBatches !== "0") {
      obj.analysisCacheBatches = message.analysisCacheBatches;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildMetrics_RemoteAnalysisCacheStatistics>, I>>(
    base?: I,
  ): BuildMetrics_RemoteAnalysisCacheStatistics {
    return BuildMetrics_RemoteAnalysisCacheStatistics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildMetrics_RemoteAnalysisCacheStatistics>, I>>(
    object: I,
  ): BuildMetrics_RemoteAnalysisCacheStatistics {
    const message = createBaseBuildMetrics_RemoteAnalysisCacheStatistics();
    message.cacheHits = object.cacheHits ?? "0";
    message.cacheMisses = object.cacheMisses ?? "0";
    message.valueStoreValueBytesReceived = object.valueStoreValueBytesReceived ?? "0";
    message.valueStoreValueBytesSent = object.valueStoreValueBytesSent ?? "0";
    message.valueStoreKeyBytesSent = object.valueStoreKeyBytesSent ?? "0";
    message.valueStoreWriteOps = object.valueStoreWriteOps ?? "0";
    message.valueStoreReadOpsSuccessful = object.valueStoreReadOpsSuccessful ?? "0";
    message.valueStoreReadOpsNotFound = object.valueStoreReadOpsNotFound ?? "0";
    message.valueStoreReadBatches = object.valueStoreReadBatches ?? "0";
    message.valueStoreWriteBatches = object.valueStoreWriteBatches ?? "0";
    message.analysisCacheBytesReceived = object.analysisCacheBytesReceived ?? "0";
    message.analysisCacheKeyBytesSent = object.analysisCacheKeyBytesSent ?? "0";
    message.analysisCacheOps = object.analysisCacheOps ?? "0";
    message.analysisCacheBatches = object.analysisCacheBatches ?? "0";
    return message;
  },
};

function createBaseBuildToolLogs(): BuildToolLogs {
  return { log: [] };
}

export const BuildToolLogs: MessageFns<BuildToolLogs> = {
  encode(message: BuildToolLogs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.log) {
      File.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildToolLogs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildToolLogs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.log.push(File.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildToolLogs {
    return { log: globalThis.Array.isArray(object?.log) ? object.log.map((e: any) => File.fromJSON(e)) : [] };
  },

  toJSON(message: BuildToolLogs): unknown {
    const obj: any = {};
    if (message.log?.length) {
      obj.log = message.log.map((e) => File.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildToolLogs>, I>>(base?: I): BuildToolLogs {
    return BuildToolLogs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildToolLogs>, I>>(object: I): BuildToolLogs {
    const message = createBaseBuildToolLogs();
    message.log = object.log?.map((e) => File.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConvenienceSymlinksIdentified(): ConvenienceSymlinksIdentified {
  return { convenienceSymlinks: [] };
}

export const ConvenienceSymlinksIdentified: MessageFns<ConvenienceSymlinksIdentified> = {
  encode(message: ConvenienceSymlinksIdentified, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.convenienceSymlinks) {
      ConvenienceSymlink.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvenienceSymlinksIdentified {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvenienceSymlinksIdentified();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.convenienceSymlinks.push(ConvenienceSymlink.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvenienceSymlinksIdentified {
    return {
      convenienceSymlinks: globalThis.Array.isArray(object?.convenienceSymlinks)
        ? object.convenienceSymlinks.map((e: any) => ConvenienceSymlink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConvenienceSymlinksIdentified): unknown {
    const obj: any = {};
    if (message.convenienceSymlinks?.length) {
      obj.convenienceSymlinks = message.convenienceSymlinks.map((e) => ConvenienceSymlink.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConvenienceSymlinksIdentified>, I>>(base?: I): ConvenienceSymlinksIdentified {
    return ConvenienceSymlinksIdentified.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConvenienceSymlinksIdentified>, I>>(
    object: I,
  ): ConvenienceSymlinksIdentified {
    const message = createBaseConvenienceSymlinksIdentified();
    message.convenienceSymlinks = object.convenienceSymlinks?.map((e) => ConvenienceSymlink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConvenienceSymlink(): ConvenienceSymlink {
  return { path: "", action: 0, target: "" };
}

export const ConvenienceSymlink: MessageFns<ConvenienceSymlink> = {
  encode(message: ConvenienceSymlink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvenienceSymlink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvenienceSymlink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvenienceSymlink {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      action: isSet(object.action) ? convenienceSymlink_ActionFromJSON(object.action) : 0,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
    };
  },

  toJSON(message: ConvenienceSymlink): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.action !== 0) {
      obj.action = convenienceSymlink_ActionToJSON(message.action);
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConvenienceSymlink>, I>>(base?: I): ConvenienceSymlink {
    return ConvenienceSymlink.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConvenienceSymlink>, I>>(object: I): ConvenienceSymlink {
    const message = createBaseConvenienceSymlink();
    message.path = object.path ?? "";
    message.action = object.action ?? 0;
    message.target = object.target ?? "";
    return message;
  },
};

function createBaseExecRequestConstructed(): ExecRequestConstructed {
  return {
    workingDirectory: new Uint8Array(0),
    argv: [],
    environmentVariable: [],
    environmentVariableToClear: [],
    shouldExec: false,
  };
}

export const ExecRequestConstructed: MessageFns<ExecRequestConstructed> = {
  encode(message: ExecRequestConstructed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workingDirectory.length !== 0) {
      writer.uint32(10).bytes(message.workingDirectory);
    }
    for (const v of message.argv) {
      writer.uint32(18).bytes(v!);
    }
    for (const v of message.environmentVariable) {
      EnvironmentVariable.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.environmentVariableToClear) {
      writer.uint32(34).bytes(v!);
    }
    if (message.shouldExec !== false) {
      writer.uint32(40).bool(message.shouldExec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecRequestConstructed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecRequestConstructed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workingDirectory = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.argv.push(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.environmentVariable.push(EnvironmentVariable.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.environmentVariableToClear.push(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.shouldExec = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecRequestConstructed {
    return {
      workingDirectory: isSet(object.workingDirectory) ? bytesFromBase64(object.workingDirectory) : new Uint8Array(0),
      argv: globalThis.Array.isArray(object?.argv) ? object.argv.map((e: any) => bytesFromBase64(e)) : [],
      environmentVariable: globalThis.Array.isArray(object?.environmentVariable)
        ? object.environmentVariable.map((e: any) => EnvironmentVariable.fromJSON(e))
        : [],
      environmentVariableToClear: globalThis.Array.isArray(object?.environmentVariableToClear)
        ? object.environmentVariableToClear.map((e: any) => bytesFromBase64(e))
        : [],
      shouldExec: isSet(object.shouldExec) ? globalThis.Boolean(object.shouldExec) : false,
    };
  },

  toJSON(message: ExecRequestConstructed): unknown {
    const obj: any = {};
    if (message.workingDirectory.length !== 0) {
      obj.workingDirectory = base64FromBytes(message.workingDirectory);
    }
    if (message.argv?.length) {
      obj.argv = message.argv.map((e) => base64FromBytes(e));
    }
    if (message.environmentVariable?.length) {
      obj.environmentVariable = message.environmentVariable.map((e) => EnvironmentVariable.toJSON(e));
    }
    if (message.environmentVariableToClear?.length) {
      obj.environmentVariableToClear = message.environmentVariableToClear.map((e) => base64FromBytes(e));
    }
    if (message.shouldExec !== false) {
      obj.shouldExec = message.shouldExec;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecRequestConstructed>, I>>(base?: I): ExecRequestConstructed {
    return ExecRequestConstructed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecRequestConstructed>, I>>(object: I): ExecRequestConstructed {
    const message = createBaseExecRequestConstructed();
    message.workingDirectory = object.workingDirectory ?? new Uint8Array(0);
    message.argv = object.argv?.map((e) => e) || [];
    message.environmentVariable = object.environmentVariable?.map((e) => EnvironmentVariable.fromPartial(e)) || [];
    message.environmentVariableToClear = object.environmentVariableToClear?.map((e) => e) || [];
    message.shouldExec = object.shouldExec ?? false;
    return message;
  },
};

function createBaseEnvironmentVariable(): EnvironmentVariable {
  return { name: new Uint8Array(0), value: new Uint8Array(0) };
}

export const EnvironmentVariable: MessageFns<EnvironmentVariable> = {
  encode(message: EnvironmentVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentVariable {
    return {
      name: isSet(object.name) ? bytesFromBase64(object.name) : new Uint8Array(0),
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: EnvironmentVariable): unknown {
    const obj: any = {};
    if (message.name.length !== 0) {
      obj.name = base64FromBytes(message.name);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvironmentVariable>, I>>(base?: I): EnvironmentVariable {
    return EnvironmentVariable.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvironmentVariable>, I>>(object: I): EnvironmentVariable {
    const message = createBaseEnvironmentVariable();
    message.name = object.name ?? new Uint8Array(0);
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBuildEvent(): BuildEvent {
  return {
    id: undefined,
    children: [],
    lastMessage: false,
    progress: undefined,
    aborted: undefined,
    started: undefined,
    unstructuredCommandLine: undefined,
    structuredCommandLine: undefined,
    optionsParsed: undefined,
    workspaceStatus: undefined,
    fetch: undefined,
    configuration: undefined,
    expanded: undefined,
    configured: undefined,
    action: undefined,
    namedSetOfFiles: undefined,
    completed: undefined,
    testResult: undefined,
    testProgress: undefined,
    testSummary: undefined,
    targetSummary: undefined,
    finished: undefined,
    buildToolLogs: undefined,
    buildMetrics: undefined,
    workspaceInfo: undefined,
    buildMetadata: undefined,
    convenienceSymlinksIdentified: undefined,
    execRequest: undefined,
  };
}

export const BuildEvent: MessageFns<BuildEvent> = {
  encode(message: BuildEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      BuildEventId.encode(message.id, writer.uint32(10).fork()).join();
    }
    for (const v of message.children) {
      BuildEventId.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.lastMessage !== false) {
      writer.uint32(160).bool(message.lastMessage);
    }
    if (message.progress !== undefined) {
      Progress.encode(message.progress, writer.uint32(26).fork()).join();
    }
    if (message.aborted !== undefined) {
      Aborted.encode(message.aborted, writer.uint32(34).fork()).join();
    }
    if (message.started !== undefined) {
      BuildStarted.encode(message.started, writer.uint32(42).fork()).join();
    }
    if (message.unstructuredCommandLine !== undefined) {
      UnstructuredCommandLine.encode(message.unstructuredCommandLine, writer.uint32(98).fork()).join();
    }
    if (message.structuredCommandLine !== undefined) {
      CommandLine.encode(message.structuredCommandLine, writer.uint32(178).fork()).join();
    }
    if (message.optionsParsed !== undefined) {
      OptionsParsed.encode(message.optionsParsed, writer.uint32(106).fork()).join();
    }
    if (message.workspaceStatus !== undefined) {
      WorkspaceStatus.encode(message.workspaceStatus, writer.uint32(130).fork()).join();
    }
    if (message.fetch !== undefined) {
      Fetch.encode(message.fetch, writer.uint32(170).fork()).join();
    }
    if (message.configuration !== undefined) {
      Configuration.encode(message.configuration, writer.uint32(138).fork()).join();
    }
    if (message.expanded !== undefined) {
      PatternExpanded.encode(message.expanded, writer.uint32(50).fork()).join();
    }
    if (message.configured !== undefined) {
      TargetConfigured.encode(message.configured, writer.uint32(146).fork()).join();
    }
    if (message.action !== undefined) {
      ActionExecuted.encode(message.action, writer.uint32(58).fork()).join();
    }
    if (message.namedSetOfFiles !== undefined) {
      NamedSetOfFiles.encode(message.namedSetOfFiles, writer.uint32(122).fork()).join();
    }
    if (message.completed !== undefined) {
      TargetComplete.encode(message.completed, writer.uint32(66).fork()).join();
    }
    if (message.testResult !== undefined) {
      TestResult.encode(message.testResult, writer.uint32(82).fork()).join();
    }
    if (message.testProgress !== undefined) {
      TestProgress.encode(message.testProgress, writer.uint32(242).fork()).join();
    }
    if (message.testSummary !== undefined) {
      TestSummary.encode(message.testSummary, writer.uint32(74).fork()).join();
    }
    if (message.targetSummary !== undefined) {
      TargetSummary.encode(message.targetSummary, writer.uint32(226).fork()).join();
    }
    if (message.finished !== undefined) {
      BuildFinished.encode(message.finished, writer.uint32(114).fork()).join();
    }
    if (message.buildToolLogs !== undefined) {
      BuildToolLogs.encode(message.buildToolLogs, writer.uint32(186).fork()).join();
    }
    if (message.buildMetrics !== undefined) {
      BuildMetrics.encode(message.buildMetrics, writer.uint32(194).fork()).join();
    }
    if (message.workspaceInfo !== undefined) {
      WorkspaceConfig.encode(message.workspaceInfo, writer.uint32(202).fork()).join();
    }
    if (message.buildMetadata !== undefined) {
      BuildMetadata.encode(message.buildMetadata, writer.uint32(210).fork()).join();
    }
    if (message.convenienceSymlinksIdentified !== undefined) {
      ConvenienceSymlinksIdentified.encode(message.convenienceSymlinksIdentified, writer.uint32(218).fork()).join();
    }
    if (message.execRequest !== undefined) {
      ExecRequestConstructed.encode(message.execRequest, writer.uint32(234).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuildEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = BuildEventId.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.children.push(BuildEventId.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.lastMessage = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.progress = Progress.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.aborted = Aborted.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.started = BuildStarted.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.unstructuredCommandLine = UnstructuredCommandLine.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.structuredCommandLine = CommandLine.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.optionsParsed = OptionsParsed.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.workspaceStatus = WorkspaceStatus.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.fetch = Fetch.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.configuration = Configuration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expanded = PatternExpanded.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.configured = TargetConfigured.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.action = ActionExecuted.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.namedSetOfFiles = NamedSetOfFiles.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.completed = TargetComplete.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.testResult = TestResult.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.testProgress = TestProgress.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.testSummary = TestSummary.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.targetSummary = TargetSummary.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.finished = BuildFinished.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.buildToolLogs = BuildToolLogs.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.buildMetrics = BuildMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.workspaceInfo = WorkspaceConfig.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.buildMetadata = BuildMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.convenienceSymlinksIdentified = ConvenienceSymlinksIdentified.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.execRequest = ExecRequestConstructed.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildEvent {
    return {
      id: isSet(object.id) ? BuildEventId.fromJSON(object.id) : undefined,
      children: globalThis.Array.isArray(object?.children)
        ? object.children.map((e: any) => BuildEventId.fromJSON(e))
        : [],
      lastMessage: isSet(object.lastMessage) ? globalThis.Boolean(object.lastMessage) : false,
      progress: isSet(object.progress) ? Progress.fromJSON(object.progress) : undefined,
      aborted: isSet(object.aborted) ? Aborted.fromJSON(object.aborted) : undefined,
      started: isSet(object.started) ? BuildStarted.fromJSON(object.started) : undefined,
      unstructuredCommandLine: isSet(object.unstructuredCommandLine)
        ? UnstructuredCommandLine.fromJSON(object.unstructuredCommandLine)
        : undefined,
      structuredCommandLine: isSet(object.structuredCommandLine)
        ? CommandLine.fromJSON(object.structuredCommandLine)
        : undefined,
      optionsParsed: isSet(object.optionsParsed) ? OptionsParsed.fromJSON(object.optionsParsed) : undefined,
      workspaceStatus: isSet(object.workspaceStatus) ? WorkspaceStatus.fromJSON(object.workspaceStatus) : undefined,
      fetch: isSet(object.fetch) ? Fetch.fromJSON(object.fetch) : undefined,
      configuration: isSet(object.configuration) ? Configuration.fromJSON(object.configuration) : undefined,
      expanded: isSet(object.expanded) ? PatternExpanded.fromJSON(object.expanded) : undefined,
      configured: isSet(object.configured) ? TargetConfigured.fromJSON(object.configured) : undefined,
      action: isSet(object.action) ? ActionExecuted.fromJSON(object.action) : undefined,
      namedSetOfFiles: isSet(object.namedSetOfFiles) ? NamedSetOfFiles.fromJSON(object.namedSetOfFiles) : undefined,
      completed: isSet(object.completed) ? TargetComplete.fromJSON(object.completed) : undefined,
      testResult: isSet(object.testResult) ? TestResult.fromJSON(object.testResult) : undefined,
      testProgress: isSet(object.testProgress) ? TestProgress.fromJSON(object.testProgress) : undefined,
      testSummary: isSet(object.testSummary) ? TestSummary.fromJSON(object.testSummary) : undefined,
      targetSummary: isSet(object.targetSummary) ? TargetSummary.fromJSON(object.targetSummary) : undefined,
      finished: isSet(object.finished) ? BuildFinished.fromJSON(object.finished) : undefined,
      buildToolLogs: isSet(object.buildToolLogs) ? BuildToolLogs.fromJSON(object.buildToolLogs) : undefined,
      buildMetrics: isSet(object.buildMetrics) ? BuildMetrics.fromJSON(object.buildMetrics) : undefined,
      workspaceInfo: isSet(object.workspaceInfo) ? WorkspaceConfig.fromJSON(object.workspaceInfo) : undefined,
      buildMetadata: isSet(object.buildMetadata) ? BuildMetadata.fromJSON(object.buildMetadata) : undefined,
      convenienceSymlinksIdentified: isSet(object.convenienceSymlinksIdentified)
        ? ConvenienceSymlinksIdentified.fromJSON(object.convenienceSymlinksIdentified)
        : undefined,
      execRequest: isSet(object.execRequest) ? ExecRequestConstructed.fromJSON(object.execRequest) : undefined,
    };
  },

  toJSON(message: BuildEvent): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = BuildEventId.toJSON(message.id);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => BuildEventId.toJSON(e));
    }
    if (message.lastMessage !== false) {
      obj.lastMessage = message.lastMessage;
    }
    if (message.progress !== undefined) {
      obj.progress = Progress.toJSON(message.progress);
    }
    if (message.aborted !== undefined) {
      obj.aborted = Aborted.toJSON(message.aborted);
    }
    if (message.started !== undefined) {
      obj.started = BuildStarted.toJSON(message.started);
    }
    if (message.unstructuredCommandLine !== undefined) {
      obj.unstructuredCommandLine = UnstructuredCommandLine.toJSON(message.unstructuredCommandLine);
    }
    if (message.structuredCommandLine !== undefined) {
      obj.structuredCommandLine = CommandLine.toJSON(message.structuredCommandLine);
    }
    if (message.optionsParsed !== undefined) {
      obj.optionsParsed = OptionsParsed.toJSON(message.optionsParsed);
    }
    if (message.workspaceStatus !== undefined) {
      obj.workspaceStatus = WorkspaceStatus.toJSON(message.workspaceStatus);
    }
    if (message.fetch !== undefined) {
      obj.fetch = Fetch.toJSON(message.fetch);
    }
    if (message.configuration !== undefined) {
      obj.configuration = Configuration.toJSON(message.configuration);
    }
    if (message.expanded !== undefined) {
      obj.expanded = PatternExpanded.toJSON(message.expanded);
    }
    if (message.configured !== undefined) {
      obj.configured = TargetConfigured.toJSON(message.configured);
    }
    if (message.action !== undefined) {
      obj.action = ActionExecuted.toJSON(message.action);
    }
    if (message.namedSetOfFiles !== undefined) {
      obj.namedSetOfFiles = NamedSetOfFiles.toJSON(message.namedSetOfFiles);
    }
    if (message.completed !== undefined) {
      obj.completed = TargetComplete.toJSON(message.completed);
    }
    if (message.testResult !== undefined) {
      obj.testResult = TestResult.toJSON(message.testResult);
    }
    if (message.testProgress !== undefined) {
      obj.testProgress = TestProgress.toJSON(message.testProgress);
    }
    if (message.testSummary !== undefined) {
      obj.testSummary = TestSummary.toJSON(message.testSummary);
    }
    if (message.targetSummary !== undefined) {
      obj.targetSummary = TargetSummary.toJSON(message.targetSummary);
    }
    if (message.finished !== undefined) {
      obj.finished = BuildFinished.toJSON(message.finished);
    }
    if (message.buildToolLogs !== undefined) {
      obj.buildToolLogs = BuildToolLogs.toJSON(message.buildToolLogs);
    }
    if (message.buildMetrics !== undefined) {
      obj.buildMetrics = BuildMetrics.toJSON(message.buildMetrics);
    }
    if (message.workspaceInfo !== undefined) {
      obj.workspaceInfo = WorkspaceConfig.toJSON(message.workspaceInfo);
    }
    if (message.buildMetadata !== undefined) {
      obj.buildMetadata = BuildMetadata.toJSON(message.buildMetadata);
    }
    if (message.convenienceSymlinksIdentified !== undefined) {
      obj.convenienceSymlinksIdentified = ConvenienceSymlinksIdentified.toJSON(message.convenienceSymlinksIdentified);
    }
    if (message.execRequest !== undefined) {
      obj.execRequest = ExecRequestConstructed.toJSON(message.execRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildEvent>, I>>(base?: I): BuildEvent {
    return BuildEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildEvent>, I>>(object: I): BuildEvent {
    const message = createBaseBuildEvent();
    message.id = (object.id !== undefined && object.id !== null) ? BuildEventId.fromPartial(object.id) : undefined;
    message.children = object.children?.map((e) => BuildEventId.fromPartial(e)) || [];
    message.lastMessage = object.lastMessage ?? false;
    message.progress = (object.progress !== undefined && object.progress !== null)
      ? Progress.fromPartial(object.progress)
      : undefined;
    message.aborted = (object.aborted !== undefined && object.aborted !== null)
      ? Aborted.fromPartial(object.aborted)
      : undefined;
    message.started = (object.started !== undefined && object.started !== null)
      ? BuildStarted.fromPartial(object.started)
      : undefined;
    message.unstructuredCommandLine =
      (object.unstructuredCommandLine !== undefined && object.unstructuredCommandLine !== null)
        ? UnstructuredCommandLine.fromPartial(object.unstructuredCommandLine)
        : undefined;
    message.structuredCommandLine =
      (object.structuredCommandLine !== undefined && object.structuredCommandLine !== null)
        ? CommandLine.fromPartial(object.structuredCommandLine)
        : undefined;
    message.optionsParsed = (object.optionsParsed !== undefined && object.optionsParsed !== null)
      ? OptionsParsed.fromPartial(object.optionsParsed)
      : undefined;
    message.workspaceStatus = (object.workspaceStatus !== undefined && object.workspaceStatus !== null)
      ? WorkspaceStatus.fromPartial(object.workspaceStatus)
      : undefined;
    message.fetch = (object.fetch !== undefined && object.fetch !== null) ? Fetch.fromPartial(object.fetch) : undefined;
    message.configuration = (object.configuration !== undefined && object.configuration !== null)
      ? Configuration.fromPartial(object.configuration)
      : undefined;
    message.expanded = (object.expanded !== undefined && object.expanded !== null)
      ? PatternExpanded.fromPartial(object.expanded)
      : undefined;
    message.configured = (object.configured !== undefined && object.configured !== null)
      ? TargetConfigured.fromPartial(object.configured)
      : undefined;
    message.action = (object.action !== undefined && object.action !== null)
      ? ActionExecuted.fromPartial(object.action)
      : undefined;
    message.namedSetOfFiles = (object.namedSetOfFiles !== undefined && object.namedSetOfFiles !== null)
      ? NamedSetOfFiles.fromPartial(object.namedSetOfFiles)
      : undefined;
    message.completed = (object.completed !== undefined && object.completed !== null)
      ? TargetComplete.fromPartial(object.completed)
      : undefined;
    message.testResult = (object.testResult !== undefined && object.testResult !== null)
      ? TestResult.fromPartial(object.testResult)
      : undefined;
    message.testProgress = (object.testProgress !== undefined && object.testProgress !== null)
      ? TestProgress.fromPartial(object.testProgress)
      : undefined;
    message.testSummary = (object.testSummary !== undefined && object.testSummary !== null)
      ? TestSummary.fromPartial(object.testSummary)
      : undefined;
    message.targetSummary = (object.targetSummary !== undefined && object.targetSummary !== null)
      ? TargetSummary.fromPartial(object.targetSummary)
      : undefined;
    message.finished = (object.finished !== undefined && object.finished !== null)
      ? BuildFinished.fromPartial(object.finished)
      : undefined;
    message.buildToolLogs = (object.buildToolLogs !== undefined && object.buildToolLogs !== null)
      ? BuildToolLogs.fromPartial(object.buildToolLogs)
      : undefined;
    message.buildMetrics = (object.buildMetrics !== undefined && object.buildMetrics !== null)
      ? BuildMetrics.fromPartial(object.buildMetrics)
      : undefined;
    message.workspaceInfo = (object.workspaceInfo !== undefined && object.workspaceInfo !== null)
      ? WorkspaceConfig.fromPartial(object.workspaceInfo)
      : undefined;
    message.buildMetadata = (object.buildMetadata !== undefined && object.buildMetadata !== null)
      ? BuildMetadata.fromPartial(object.buildMetadata)
      : undefined;
    message.convenienceSymlinksIdentified =
      (object.convenienceSymlinksIdentified !== undefined && object.convenienceSymlinksIdentified !== null)
        ? ConvenienceSymlinksIdentified.fromPartial(object.convenienceSymlinksIdentified)
        : undefined;
    message.execRequest = (object.execRequest !== undefined && object.execRequest !== null)
      ? ExecRequestConstructed.fromPartial(object.execRequest)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
