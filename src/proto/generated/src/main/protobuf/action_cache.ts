// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: src/main/protobuf/action_cache.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "blaze";

/** Information about the action cache behavior during a single build. */
export interface ActionCacheStatistics {
  /**
   * Size of the action cache in bytes.
   *
   * This is computed by the code that persists the action cache to disk and
   * represents the size of the written files, which has no direct relation to
   * the number of entries in the cache.
   */
  sizeInBytes: string;
  /** Time it took to save the action cache to disk. */
  saveTimeInMs: string;
  /** Cache counters. */
  hits: number;
  misses: number;
  /** Breakdown of the cache misses based on the reasons behind them. */
  missDetails: ActionCacheStatistics_MissDetail[];
  /**
   * Time it took to load the action cache from disk. Reported as 0 if the
   * action cache has not been loaded in this invocation.
   */
  loadTimeInMs: string;
}

/** Reasons for not finding an action in the cache. */
export enum ActionCacheStatistics_MissReason {
  /** DIFFERENT_ACTION_KEY - currently not used */
  DIFFERENT_ACTION_KEY = 0,
  /** DIFFERENT_DEPS - currently not used */
  DIFFERENT_DEPS = 1,
  /** DIFFERENT_ENVIRONMENT - currently not used */
  DIFFERENT_ENVIRONMENT = 2,
  /** DIFFERENT_FILES - currently not used */
  DIFFERENT_FILES = 3,
  /** CORRUPTED_CACHE_ENTRY - A cache entry was found, but it was corrupted and we ignored it. */
  CORRUPTED_CACHE_ENTRY = 4,
  /** NOT_CACHED - No cache entry was found. */
  NOT_CACHED = 5,
  /** UNCONDITIONAL_EXECUTION - Unconditional execution was requested. */
  UNCONDITIONAL_EXECUTION = 6,
  /**
   * DIGEST_MISMATCH - A cache entry was found, but it contained a different digest.
   * This could be due to a change in the command line, input or output file
   * paths or contents, environment variables, or certain build flags.
   */
  DIGEST_MISMATCH = 7,
  UNRECOGNIZED = -1,
}

export function actionCacheStatistics_MissReasonFromJSON(object: any): ActionCacheStatistics_MissReason {
  switch (object) {
    case 0:
    case "DIFFERENT_ACTION_KEY":
      return ActionCacheStatistics_MissReason.DIFFERENT_ACTION_KEY;
    case 1:
    case "DIFFERENT_DEPS":
      return ActionCacheStatistics_MissReason.DIFFERENT_DEPS;
    case 2:
    case "DIFFERENT_ENVIRONMENT":
      return ActionCacheStatistics_MissReason.DIFFERENT_ENVIRONMENT;
    case 3:
    case "DIFFERENT_FILES":
      return ActionCacheStatistics_MissReason.DIFFERENT_FILES;
    case 4:
    case "CORRUPTED_CACHE_ENTRY":
      return ActionCacheStatistics_MissReason.CORRUPTED_CACHE_ENTRY;
    case 5:
    case "NOT_CACHED":
      return ActionCacheStatistics_MissReason.NOT_CACHED;
    case 6:
    case "UNCONDITIONAL_EXECUTION":
      return ActionCacheStatistics_MissReason.UNCONDITIONAL_EXECUTION;
    case 7:
    case "DIGEST_MISMATCH":
      return ActionCacheStatistics_MissReason.DIGEST_MISMATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActionCacheStatistics_MissReason.UNRECOGNIZED;
  }
}

export function actionCacheStatistics_MissReasonToJSON(object: ActionCacheStatistics_MissReason): string {
  switch (object) {
    case ActionCacheStatistics_MissReason.DIFFERENT_ACTION_KEY:
      return "DIFFERENT_ACTION_KEY";
    case ActionCacheStatistics_MissReason.DIFFERENT_DEPS:
      return "DIFFERENT_DEPS";
    case ActionCacheStatistics_MissReason.DIFFERENT_ENVIRONMENT:
      return "DIFFERENT_ENVIRONMENT";
    case ActionCacheStatistics_MissReason.DIFFERENT_FILES:
      return "DIFFERENT_FILES";
    case ActionCacheStatistics_MissReason.CORRUPTED_CACHE_ENTRY:
      return "CORRUPTED_CACHE_ENTRY";
    case ActionCacheStatistics_MissReason.NOT_CACHED:
      return "NOT_CACHED";
    case ActionCacheStatistics_MissReason.UNCONDITIONAL_EXECUTION:
      return "UNCONDITIONAL_EXECUTION";
    case ActionCacheStatistics_MissReason.DIGEST_MISMATCH:
      return "DIGEST_MISMATCH";
    case ActionCacheStatistics_MissReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Detailed information for a particular miss reason. */
export interface ActionCacheStatistics_MissDetail {
  reason: ActionCacheStatistics_MissReason;
  count: number;
}

function createBaseActionCacheStatistics(): ActionCacheStatistics {
  return { sizeInBytes: "0", saveTimeInMs: "0", hits: 0, misses: 0, missDetails: [], loadTimeInMs: "0" };
}

export const ActionCacheStatistics: MessageFns<ActionCacheStatistics> = {
  encode(message: ActionCacheStatistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeInBytes !== "0") {
      writer.uint32(8).uint64(message.sizeInBytes);
    }
    if (message.saveTimeInMs !== "0") {
      writer.uint32(16).uint64(message.saveTimeInMs);
    }
    if (message.hits !== 0) {
      writer.uint32(24).int32(message.hits);
    }
    if (message.misses !== 0) {
      writer.uint32(32).int32(message.misses);
    }
    for (const v of message.missDetails) {
      ActionCacheStatistics_MissDetail.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.loadTimeInMs !== "0") {
      writer.uint32(48).uint64(message.loadTimeInMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionCacheStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionCacheStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sizeInBytes = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.saveTimeInMs = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hits = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.misses = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.missDetails.push(ActionCacheStatistics_MissDetail.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.loadTimeInMs = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionCacheStatistics {
    return {
      sizeInBytes: isSet(object.sizeInBytes) ? globalThis.String(object.sizeInBytes) : "0",
      saveTimeInMs: isSet(object.saveTimeInMs) ? globalThis.String(object.saveTimeInMs) : "0",
      hits: isSet(object.hits) ? globalThis.Number(object.hits) : 0,
      misses: isSet(object.misses) ? globalThis.Number(object.misses) : 0,
      missDetails: globalThis.Array.isArray(object?.missDetails)
        ? object.missDetails.map((e: any) => ActionCacheStatistics_MissDetail.fromJSON(e))
        : [],
      loadTimeInMs: isSet(object.loadTimeInMs) ? globalThis.String(object.loadTimeInMs) : "0",
    };
  },

  toJSON(message: ActionCacheStatistics): unknown {
    const obj: any = {};
    if (message.sizeInBytes !== "0") {
      obj.sizeInBytes = message.sizeInBytes;
    }
    if (message.saveTimeInMs !== "0") {
      obj.saveTimeInMs = message.saveTimeInMs;
    }
    if (message.hits !== 0) {
      obj.hits = Math.round(message.hits);
    }
    if (message.misses !== 0) {
      obj.misses = Math.round(message.misses);
    }
    if (message.missDetails?.length) {
      obj.missDetails = message.missDetails.map((e) => ActionCacheStatistics_MissDetail.toJSON(e));
    }
    if (message.loadTimeInMs !== "0") {
      obj.loadTimeInMs = message.loadTimeInMs;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionCacheStatistics>, I>>(base?: I): ActionCacheStatistics {
    return ActionCacheStatistics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionCacheStatistics>, I>>(object: I): ActionCacheStatistics {
    const message = createBaseActionCacheStatistics();
    message.sizeInBytes = object.sizeInBytes ?? "0";
    message.saveTimeInMs = object.saveTimeInMs ?? "0";
    message.hits = object.hits ?? 0;
    message.misses = object.misses ?? 0;
    message.missDetails = object.missDetails?.map((e) => ActionCacheStatistics_MissDetail.fromPartial(e)) || [];
    message.loadTimeInMs = object.loadTimeInMs ?? "0";
    return message;
  },
};

function createBaseActionCacheStatistics_MissDetail(): ActionCacheStatistics_MissDetail {
  return { reason: 0, count: 0 };
}

export const ActionCacheStatistics_MissDetail: MessageFns<ActionCacheStatistics_MissDetail> = {
  encode(message: ActionCacheStatistics_MissDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionCacheStatistics_MissDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionCacheStatistics_MissDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionCacheStatistics_MissDetail {
    return {
      reason: isSet(object.reason) ? actionCacheStatistics_MissReasonFromJSON(object.reason) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ActionCacheStatistics_MissDetail): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = actionCacheStatistics_MissReasonToJSON(message.reason);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActionCacheStatistics_MissDetail>, I>>(
    base?: I,
  ): ActionCacheStatistics_MissDetail {
    return ActionCacheStatistics_MissDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActionCacheStatistics_MissDetail>, I>>(
    object: I,
  ): ActionCacheStatistics_MissDetail {
    const message = createBaseActionCacheStatistics_MissDetail();
    message.reason = object.reason ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
