// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: src/main/protobuf/invocation_policy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { StrategyPolicy } from "./strategy_policy";

export const protobufPackage = "blaze.invocation_policy";

/**
 * The --invocation_policy flag takes a base64-encoded binary-serialized or text
 * formatted InvocationPolicy message.
 */
export interface InvocationPolicy {
  /**
   * Order matters.
   * After expanding policies on expansion flags or flags with implicit
   * requirements, only the final policy on a specific flag will be enforced
   * onto the user's command line.
   */
  flagPolicies: FlagPolicy[];
  strategyPolicy?: StrategyPolicy | undefined;
}

/** A policy for controlling the value of a flag. */
export interface FlagPolicy {
  /**
   * The name of the flag to enforce this policy on.
   *
   * Note that this should be the full name of the flag, not the abbreviated
   * name of the flag. If the user specifies the abbreviated name of a flag,
   * that flag will be matched using its full name.
   *
   * The "no" prefix will not be parsed, so for boolean flags, use
   * the flag's full name and explicitly set it to true or false.
   */
  flagName?:
    | string
    | undefined;
  /**
   * If set, this flag policy is applied only if one of the given commands or a
   * command that inherits from one of the given commands is being run. For
   * instance, if "build" is one of the commands here, then this policy will
   * apply to any command that inherits from build, such as info, coverage, or
   * test. If empty, this flag policy is applied for all commands. This allows
   * the policy setter to add all policies to the proto without having to
   * determine which Bazel command the user is actually running. Additionally,
   * Bazel allows multiple flags to be defined by the same name, and the
   * specific flag definition is determined by the command.
   */
  commands: string[];
  setValue?: SetValue | undefined;
  useDefault?: UseDefault | undefined;
  disallowValues?: DisallowValues | undefined;
  allowValues?: AllowValues | undefined;
  customErrorMessage?: string | undefined;
}

export interface SetValue {
  /**
   * Use this value for the specified flag, overriding any default or user-set
   * value (unless behavior = APPEND for repeatable flags).
   *
   * This field is repeated for repeatable flags. It is an error to set
   * multiple values for a flag that is not actually a repeatable flag.
   * This requires at least 1 value, if even the empty string.
   *
   * If the flag allows multiple values, all of its values are replaced with the
   * value or values from the policy (i.e., no diffing or merging is performed),
   * unless behavior = APPEND (see below).
   *
   * Note that some flags are tricky. For example, some flags look like boolean
   * flags, but are actually Void expansion flags that expand into other flags.
   * The Bazel flag parser will accept "--void_flag=false", but because
   * the flag is Void, the "=false" is ignored. It can get even trickier, like
   * "--novoid_flag" which is also an expansion flag with the type Void whose
   * name is explicitly "novoid_flag" and which expands into other flags that
   * are the opposite of "--void_flag". For expansion flags, it's best to
   * explicitly override the flags they expand into.
   *
   * Other flags may be differently tricky: A flag could have a converter that
   * converts some string to a list of values, but that flag may not itself have
   * allowMultiple set to true.
   *
   * An example is "--test_tag_filters": this flag sets its converter to
   * CommaSeparatedOptionListConverter, but does not set allowMultiple to true.
   * So "--test_tag_filters=foo,bar" results in ["foo", "bar"], however
   * "--test_tag_filters=foo --test_tag_filters=bar" results in just ["bar"]
   * since the 2nd value overrides the 1st.
   *
   * Similarly, "--test_tag_filters=foo,bar --test_tag_filters=baz,qux" results
   * in ["baz", "qux"]. For flags like these, the policy should specify
   * "foo,bar" instead of separately specifying "foo" and "bar" so that the
   * converter is appropriately invoked.
   *
   * Note that the opposite is not necessarily
   * true: for a flag that specifies allowMultiple=true, "--flag=foo,bar"
   * may fail to parse or result in an unexpected value.
   */
  flagValue: string[];
  /**
   * Defines how invocation policy should interact with user settings for the
   * same flag.
   */
  behavior?: SetValue_Behavior | undefined;
}

export enum SetValue_Behavior {
  UNDEFINED = 0,
  /**
   * ALLOW_OVERRIDES - Change the flag value but allow it to be overridden by explicit settings
   * from command line/config expansion/rc files.
   * Matching old flag values: append = false, overridable = true.
   */
  ALLOW_OVERRIDES = 1,
  /**
   * APPEND - Append a new value for a repeatable flag, leave old values and allow
   * further overrides.
   * Matching old flag values: append = true, overridable = false.
   */
  APPEND = 2,
  /**
   * FINAL_VALUE_IGNORE_OVERRIDES - Set a final value of the flag. Any overrides provided by the user for
   * this flag will be silently ignored.
   * Matching old flag values: append = false, overridable = false.
   */
  FINAL_VALUE_IGNORE_OVERRIDES = 3,
  /**
   * FINAL_VALUE_THROW_ON_OVERRIDE - Set a final value of the flag and throw an error if the user provides
   * an override.
   * Matching old flag values: append = false, overridable = false.
   */
  FINAL_VALUE_THROW_ON_OVERRIDE = 4,
  UNRECOGNIZED = -1,
}

export function setValue_BehaviorFromJSON(object: any): SetValue_Behavior {
  switch (object) {
    case 0:
    case "UNDEFINED":
      return SetValue_Behavior.UNDEFINED;
    case 1:
    case "ALLOW_OVERRIDES":
      return SetValue_Behavior.ALLOW_OVERRIDES;
    case 2:
    case "APPEND":
      return SetValue_Behavior.APPEND;
    case 3:
    case "FINAL_VALUE_IGNORE_OVERRIDES":
      return SetValue_Behavior.FINAL_VALUE_IGNORE_OVERRIDES;
    case 4:
    case "FINAL_VALUE_THROW_ON_OVERRIDE":
      return SetValue_Behavior.FINAL_VALUE_THROW_ON_OVERRIDE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SetValue_Behavior.UNRECOGNIZED;
  }
}

export function setValue_BehaviorToJSON(object: SetValue_Behavior): string {
  switch (object) {
    case SetValue_Behavior.UNDEFINED:
      return "UNDEFINED";
    case SetValue_Behavior.ALLOW_OVERRIDES:
      return "ALLOW_OVERRIDES";
    case SetValue_Behavior.APPEND:
      return "APPEND";
    case SetValue_Behavior.FINAL_VALUE_IGNORE_OVERRIDES:
      return "FINAL_VALUE_IGNORE_OVERRIDES";
    case SetValue_Behavior.FINAL_VALUE_THROW_ON_OVERRIDE:
      return "FINAL_VALUE_THROW_ON_OVERRIDE";
    case SetValue_Behavior.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Use the default value of the flag, as defined by Bazel (or equivalently, do
 * not allow the user to set this flag).
 *
 * Note on implementation: UseDefault sets the default by clearing the flag,
 * so that when the value is requested and no flag is found, the flag parser
 * returns the default. This is mostly relevant for expansion flags: it will
 * erase user values in *all* flags that the expansion flag expands to. Only
 * use this on expansion flags if this is acceptable behavior. Since the last
 * policy wins, later policies on this same flag will still remove the
 * expanded UseDefault, so there is a way around, but it's really best not to
 * use this on expansion flags at all.
 */
export interface UseDefault {
}

export interface DisallowValues {
  /**
   * It is an error for the user to use any of these values (that is, the Bazel
   * command will fail), unless new_value or use_default is set.
   *
   * For repeatable flags, if any one of the values in the flag matches a value
   * in the list of disallowed values, an error is thrown.
   *
   * Care must be taken for flags with complicated converters. For example,
   * it's possible for a repeated flag to be of type List<List<T>>, so that
   * "--foo=a,b --foo=c,d" results in foo=[["a","b"], ["c", "d"]]. In this case,
   * it is not possible to disallow just "b", nor will ["b", "a"] match, nor
   * will ["b", "c"] (but ["a", "b"] will still match).
   */
  disallowedValues: string[];
  /**
   * If set and if the value of the flag is disallowed (including the default
   * value of the flag if the user doesn't specify a value), use this value as
   * the value of the flag instead of raising an error. This does not apply to
   * repeatable flags and is ignored if the flag is a repeatable flag.
   */
  newValue?:
    | string
    | undefined;
  /**
   * If set and if the value of the flag is disallowed, use the default value
   * of the flag instead of raising an error. Unlike new_value, this works for
   * repeatable flags, but note that the default value for repeatable flags is
   * always empty.
   *
   * Note that it is an error to disallow the default value of the flag and
   * to set use_default, unless the flag is a repeatable flag where the
   * default value is always the empty list.
   */
  useDefault?: UseDefault | undefined;
}

export interface AllowValues {
  /**
   * It is an error for the user to use any value not in this list, unless
   * new_value or use_default is set.
   */
  allowedValues: string[];
  /**
   * If set and if the value of the flag is disallowed (including the default
   * value of the flag if the user doesn't specify a value), use this value as
   * the value of the flag instead of raising an error. This does not apply to
   * repeatable flags and is ignored if the flag is a repeatable flag.
   */
  newValue?:
    | string
    | undefined;
  /**
   * If set and if the value of the flag is disallowed, use the default value
   * of the flag instead of raising an error. Unlike new_value, this works for
   * repeatable flags, but note that the default value for repeatable flags is
   * always empty.
   *
   * Note that it is an error to disallow the default value of the flag and
   * to set use_default, unless the flag is a repeatable flag where the
   * default value is always the empty list.
   */
  useDefault?: UseDefault | undefined;
}

function createBaseInvocationPolicy(): InvocationPolicy {
  return { flagPolicies: [], strategyPolicy: undefined };
}

export const InvocationPolicy: MessageFns<InvocationPolicy> = {
  encode(message: InvocationPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flagPolicies) {
      FlagPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.strategyPolicy !== undefined) {
      StrategyPolicy.encode(message.strategyPolicy, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvocationPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvocationPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flagPolicies.push(FlagPolicy.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.strategyPolicy = StrategyPolicy.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvocationPolicy {
    return {
      flagPolicies: globalThis.Array.isArray(object?.flagPolicies)
        ? object.flagPolicies.map((e: any) => FlagPolicy.fromJSON(e))
        : [],
      strategyPolicy: isSet(object.strategyPolicy) ? StrategyPolicy.fromJSON(object.strategyPolicy) : undefined,
    };
  },

  toJSON(message: InvocationPolicy): unknown {
    const obj: any = {};
    if (message.flagPolicies?.length) {
      obj.flagPolicies = message.flagPolicies.map((e) => FlagPolicy.toJSON(e));
    }
    if (message.strategyPolicy !== undefined) {
      obj.strategyPolicy = StrategyPolicy.toJSON(message.strategyPolicy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InvocationPolicy>, I>>(base?: I): InvocationPolicy {
    return InvocationPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InvocationPolicy>, I>>(object: I): InvocationPolicy {
    const message = createBaseInvocationPolicy();
    message.flagPolicies = object.flagPolicies?.map((e) => FlagPolicy.fromPartial(e)) || [];
    message.strategyPolicy = (object.strategyPolicy !== undefined && object.strategyPolicy !== null)
      ? StrategyPolicy.fromPartial(object.strategyPolicy)
      : undefined;
    return message;
  },
};

function createBaseFlagPolicy(): FlagPolicy {
  return {
    flagName: "",
    commands: [],
    setValue: undefined,
    useDefault: undefined,
    disallowValues: undefined,
    allowValues: undefined,
    customErrorMessage: "",
  };
}

export const FlagPolicy: MessageFns<FlagPolicy> = {
  encode(message: FlagPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flagName !== undefined && message.flagName !== "") {
      writer.uint32(10).string(message.flagName);
    }
    for (const v of message.commands) {
      writer.uint32(18).string(v!);
    }
    if (message.setValue !== undefined) {
      SetValue.encode(message.setValue, writer.uint32(26).fork()).join();
    }
    if (message.useDefault !== undefined) {
      UseDefault.encode(message.useDefault, writer.uint32(34).fork()).join();
    }
    if (message.disallowValues !== undefined) {
      DisallowValues.encode(message.disallowValues, writer.uint32(42).fork()).join();
    }
    if (message.allowValues !== undefined) {
      AllowValues.encode(message.allowValues, writer.uint32(50).fork()).join();
    }
    if (message.customErrorMessage !== undefined && message.customErrorMessage !== "") {
      writer.uint32(58).string(message.customErrorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlagPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlagPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flagName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commands.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.setValue = SetValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.useDefault = UseDefault.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.disallowValues = DisallowValues.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.allowValues = AllowValues.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.customErrorMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlagPolicy {
    return {
      flagName: isSet(object.flagName) ? globalThis.String(object.flagName) : "",
      commands: globalThis.Array.isArray(object?.commands) ? object.commands.map((e: any) => globalThis.String(e)) : [],
      setValue: isSet(object.setValue) ? SetValue.fromJSON(object.setValue) : undefined,
      useDefault: isSet(object.useDefault) ? UseDefault.fromJSON(object.useDefault) : undefined,
      disallowValues: isSet(object.disallowValues) ? DisallowValues.fromJSON(object.disallowValues) : undefined,
      allowValues: isSet(object.allowValues) ? AllowValues.fromJSON(object.allowValues) : undefined,
      customErrorMessage: isSet(object.customErrorMessage) ? globalThis.String(object.customErrorMessage) : "",
    };
  },

  toJSON(message: FlagPolicy): unknown {
    const obj: any = {};
    if (message.flagName !== undefined && message.flagName !== "") {
      obj.flagName = message.flagName;
    }
    if (message.commands?.length) {
      obj.commands = message.commands;
    }
    if (message.setValue !== undefined) {
      obj.setValue = SetValue.toJSON(message.setValue);
    }
    if (message.useDefault !== undefined) {
      obj.useDefault = UseDefault.toJSON(message.useDefault);
    }
    if (message.disallowValues !== undefined) {
      obj.disallowValues = DisallowValues.toJSON(message.disallowValues);
    }
    if (message.allowValues !== undefined) {
      obj.allowValues = AllowValues.toJSON(message.allowValues);
    }
    if (message.customErrorMessage !== undefined && message.customErrorMessage !== "") {
      obj.customErrorMessage = message.customErrorMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlagPolicy>, I>>(base?: I): FlagPolicy {
    return FlagPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlagPolicy>, I>>(object: I): FlagPolicy {
    const message = createBaseFlagPolicy();
    message.flagName = object.flagName ?? "";
    message.commands = object.commands?.map((e) => e) || [];
    message.setValue = (object.setValue !== undefined && object.setValue !== null)
      ? SetValue.fromPartial(object.setValue)
      : undefined;
    message.useDefault = (object.useDefault !== undefined && object.useDefault !== null)
      ? UseDefault.fromPartial(object.useDefault)
      : undefined;
    message.disallowValues = (object.disallowValues !== undefined && object.disallowValues !== null)
      ? DisallowValues.fromPartial(object.disallowValues)
      : undefined;
    message.allowValues = (object.allowValues !== undefined && object.allowValues !== null)
      ? AllowValues.fromPartial(object.allowValues)
      : undefined;
    message.customErrorMessage = object.customErrorMessage ?? "";
    return message;
  },
};

function createBaseSetValue(): SetValue {
  return { flagValue: [], behavior: 0 };
}

export const SetValue: MessageFns<SetValue> = {
  encode(message: SetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flagValue) {
      writer.uint32(10).string(v!);
    }
    if (message.behavior !== undefined && message.behavior !== 0) {
      writer.uint32(32).int32(message.behavior);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flagValue.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.behavior = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetValue {
    return {
      flagValue: globalThis.Array.isArray(object?.flagValue)
        ? object.flagValue.map((e: any) => globalThis.String(e))
        : [],
      behavior: isSet(object.behavior) ? setValue_BehaviorFromJSON(object.behavior) : 0,
    };
  },

  toJSON(message: SetValue): unknown {
    const obj: any = {};
    if (message.flagValue?.length) {
      obj.flagValue = message.flagValue;
    }
    if (message.behavior !== undefined && message.behavior !== 0) {
      obj.behavior = setValue_BehaviorToJSON(message.behavior);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetValue>, I>>(base?: I): SetValue {
    return SetValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetValue>, I>>(object: I): SetValue {
    const message = createBaseSetValue();
    message.flagValue = object.flagValue?.map((e) => e) || [];
    message.behavior = object.behavior ?? 0;
    return message;
  },
};

function createBaseUseDefault(): UseDefault {
  return {};
}

export const UseDefault: MessageFns<UseDefault> = {
  encode(_: UseDefault, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UseDefault {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUseDefault();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UseDefault {
    return {};
  },

  toJSON(_: UseDefault): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UseDefault>, I>>(base?: I): UseDefault {
    return UseDefault.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UseDefault>, I>>(_: I): UseDefault {
    const message = createBaseUseDefault();
    return message;
  },
};

function createBaseDisallowValues(): DisallowValues {
  return { disallowedValues: [], newValue: undefined, useDefault: undefined };
}

export const DisallowValues: MessageFns<DisallowValues> = {
  encode(message: DisallowValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.disallowedValues) {
      writer.uint32(10).string(v!);
    }
    if (message.newValue !== undefined) {
      writer.uint32(26).string(message.newValue);
    }
    if (message.useDefault !== undefined) {
      UseDefault.encode(message.useDefault, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisallowValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisallowValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.disallowedValues.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.useDefault = UseDefault.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisallowValues {
    return {
      disallowedValues: globalThis.Array.isArray(object?.disallowedValues)
        ? object.disallowedValues.map((e: any) => globalThis.String(e))
        : [],
      newValue: isSet(object.newValue) ? globalThis.String(object.newValue) : undefined,
      useDefault: isSet(object.useDefault) ? UseDefault.fromJSON(object.useDefault) : undefined,
    };
  },

  toJSON(message: DisallowValues): unknown {
    const obj: any = {};
    if (message.disallowedValues?.length) {
      obj.disallowedValues = message.disallowedValues;
    }
    if (message.newValue !== undefined) {
      obj.newValue = message.newValue;
    }
    if (message.useDefault !== undefined) {
      obj.useDefault = UseDefault.toJSON(message.useDefault);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DisallowValues>, I>>(base?: I): DisallowValues {
    return DisallowValues.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DisallowValues>, I>>(object: I): DisallowValues {
    const message = createBaseDisallowValues();
    message.disallowedValues = object.disallowedValues?.map((e) => e) || [];
    message.newValue = object.newValue ?? undefined;
    message.useDefault = (object.useDefault !== undefined && object.useDefault !== null)
      ? UseDefault.fromPartial(object.useDefault)
      : undefined;
    return message;
  },
};

function createBaseAllowValues(): AllowValues {
  return { allowedValues: [], newValue: undefined, useDefault: undefined };
}

export const AllowValues: MessageFns<AllowValues> = {
  encode(message: AllowValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedValues) {
      writer.uint32(10).string(v!);
    }
    if (message.newValue !== undefined) {
      writer.uint32(26).string(message.newValue);
    }
    if (message.useDefault !== undefined) {
      UseDefault.encode(message.useDefault, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllowValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllowValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allowedValues.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.useDefault = UseDefault.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllowValues {
    return {
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => globalThis.String(e))
        : [],
      newValue: isSet(object.newValue) ? globalThis.String(object.newValue) : undefined,
      useDefault: isSet(object.useDefault) ? UseDefault.fromJSON(object.useDefault) : undefined,
    };
  },

  toJSON(message: AllowValues): unknown {
    const obj: any = {};
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues;
    }
    if (message.newValue !== undefined) {
      obj.newValue = message.newValue;
    }
    if (message.useDefault !== undefined) {
      obj.useDefault = UseDefault.toJSON(message.useDefault);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllowValues>, I>>(base?: I): AllowValues {
    return AllowValues.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllowValues>, I>>(object: I): AllowValues {
    const message = createBaseAllowValues();
    message.allowedValues = object.allowedValues?.map((e) => e) || [];
    message.newValue = object.newValue ?? undefined;
    message.useDefault = (object.useDefault !== undefined && object.useDefault !== null)
      ? UseDefault.fromPartial(object.useDefault)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
